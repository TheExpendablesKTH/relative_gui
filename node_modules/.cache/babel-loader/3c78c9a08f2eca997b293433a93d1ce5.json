{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nclass DefaultAudioMixController {\n  constructor(logger) {\n    this.logger = logger;\n    this.audioDevice = null;\n    this.audioElement = null;\n    this.audioStream = null;\n    this.browserBehavior = new DefaultBrowserBehavior_1.default();\n  }\n\n  bindAudioElement(element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!element) {\n        throw new Error(`Cannot bind audio element: ${element}`);\n      }\n\n      this.audioElement = element;\n      this.audioElement.autoplay = true;\n      return this.bindAudioMix();\n    });\n  }\n\n  unbindAudioElement() {\n    if (!this.audioElement) {\n      return;\n    }\n\n    this.audioElement.srcObject = null;\n    this.audioElement = null;\n  }\n\n  bindAudioStream(stream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!stream) {\n        return;\n      }\n\n      this.audioStream = stream;\n\n      try {\n        yield this.bindAudioMix();\n      } catch (error) {\n        /* istanbul ignore else */\n        if (this.logger) {\n          this.logger.warn(`Failed to bind audio stream: ${error}`);\n        }\n      }\n    });\n  }\n\n  bindAudioDevice(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      /**\n       * Throw error if browser doesn't even support setSinkId\n       * Read more: https://caniuse.com/?search=setSinkId\n       */\n      if (device && !this.browserBehavior.supportsSetSinkId()) {\n        throw new Error('Cannot select audio output device. This browser does not support setSinkId.');\n      } // Always set device -- we might be setting it back to `null` to reselect\n      // the default, and even in that case we need to call `bindAudioMix` in\n      // order to update the sink ID to the empty string.\n\n\n      this.audioDevice = device;\n      return this.bindAudioMix();\n    });\n  }\n\n  bindAudioMix() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.audioElement) {\n        return;\n      }\n\n      if (this.audioStream) {\n        this.audioElement.srcObject = this.audioStream;\n      } // In usual operation, the output device is undefined, and so is the element\n      // sink ID. In this case, don't throw an error -- we're being called as a side\n      // effect of just binding the audio element, not choosing an output device.\n\n\n      const shouldSetSinkId = ((_a = this.audioDevice) === null || _a === void 0 ? void 0 : _a.deviceId) !== this.audioElement.sinkId;\n\n      if (shouldSetSinkId && typeof this.audioElement.sinkId === 'undefined') {\n        throw new Error('Cannot select audio output device. This browser does not support setSinkId.');\n      }\n\n      const newSinkId = this.audioDevice ? this.audioDevice.deviceId : '';\n      const oldSinkId = this.audioElement.sinkId;\n\n      if (newSinkId === oldSinkId) {\n        return;\n      } // Take the existing stream and temporarily unbind it while we change\n      // the sink ID.\n\n\n      const existingAudioElement = this.audioElement;\n      const existingStream = this.audioStream;\n\n      if (this.browserBehavior.hasChromiumWebRTC()) {\n        existingAudioElement.srcObject = null;\n      }\n\n      if (shouldSetSinkId) {\n        try {\n          yield existingAudioElement.setSinkId(newSinkId);\n        } catch (error) {\n          (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(`Failed to set sinkId for audio element: ${error}`);\n          throw error;\n        }\n      }\n\n      if (this.browserBehavior.hasChromiumWebRTC()) {\n        existingAudioElement.srcObject = existingStream;\n      }\n    });\n  }\n\n}\n\nexports.default = DefaultAudioMixController;","map":{"version":3,"sources":["../../src/audiomixcontroller/DefaultAudioMixController.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\nclass DefaultAudioMixController {\n    constructor(logger) {\n        this.logger = logger;\n        this.audioDevice = null;\n        this.audioElement = null;\n        this.audioStream = null;\n        this.browserBehavior = new DefaultBrowserBehavior_1.default();\n    }\n    bindAudioElement(element) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!element) {\n                throw new Error(`Cannot bind audio element: ${element}`);\n            }\n            this.audioElement = element;\n            this.audioElement.autoplay = true;\n            return this.bindAudioMix();\n        });\n    }\n    unbindAudioElement() {\n        if (!this.audioElement) {\n            return;\n        }\n        this.audioElement.srcObject = null;\n        this.audioElement = null;\n    }\n    bindAudioStream(stream) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!stream) {\n                return;\n            }\n            this.audioStream = stream;\n            try {\n                yield this.bindAudioMix();\n            }\n            catch (error) {\n                /* istanbul ignore else */\n                if (this.logger) {\n                    this.logger.warn(`Failed to bind audio stream: ${error}`);\n                }\n            }\n        });\n    }\n    bindAudioDevice(device) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /**\n             * Throw error if browser doesn't even support setSinkId\n             * Read more: https://caniuse.com/?search=setSinkId\n             */\n            if (device && !this.browserBehavior.supportsSetSinkId()) {\n                throw new Error('Cannot select audio output device. This browser does not support setSinkId.');\n            }\n            // Always set device -- we might be setting it back to `null` to reselect\n            // the default, and even in that case we need to call `bindAudioMix` in\n            // order to update the sink ID to the empty string.\n            this.audioDevice = device;\n            return this.bindAudioMix();\n        });\n    }\n    bindAudioMix() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.audioElement) {\n                return;\n            }\n            if (this.audioStream) {\n                this.audioElement.srcObject = this.audioStream;\n            }\n            // In usual operation, the output device is undefined, and so is the element\n            // sink ID. In this case, don't throw an error -- we're being called as a side\n            // effect of just binding the audio element, not choosing an output device.\n            const shouldSetSinkId = ((_a = this.audioDevice) === null || _a === void 0 ? void 0 : _a.deviceId) !== this.audioElement.sinkId;\n            if (shouldSetSinkId &&\n                typeof this.audioElement.sinkId === 'undefined') {\n                throw new Error('Cannot select audio output device. This browser does not support setSinkId.');\n            }\n            const newSinkId = this.audioDevice ? this.audioDevice.deviceId : '';\n            const oldSinkId = this.audioElement.sinkId;\n            if (newSinkId === oldSinkId) {\n                return;\n            }\n            // Take the existing stream and temporarily unbind it while we change\n            // the sink ID.\n            const existingAudioElement = this\n                .audioElement;\n            const existingStream = this.audioStream;\n            if (this.browserBehavior.hasChromiumWebRTC()) {\n                existingAudioElement.srcObject = null;\n            }\n            if (shouldSetSinkId) {\n                try {\n                    yield existingAudioElement.setSinkId(newSinkId);\n                }\n                catch (error) {\n                    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(`Failed to set sinkId for audio element: ${error}`);\n                    throw error;\n                }\n            }\n            if (this.browserBehavior.hasChromiumWebRTC()) {\n                existingAudioElement.srcObject = existingStream;\n            }\n        });\n    }\n}\nexports.default = DefaultAudioMixController;\n//# sourceMappingURL=DefaultAudioMixController.js.map"]},"metadata":{},"sourceType":"script"}