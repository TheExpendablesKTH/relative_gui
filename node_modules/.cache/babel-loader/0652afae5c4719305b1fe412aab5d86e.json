{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst TimeoutScheduler_1 = require(\"../scheduler/TimeoutScheduler\");\n\nclass DefaultReconnectController {\n  constructor(reconnectTimeoutMs, backoffPolicy) {\n    this.reconnectTimeoutMs = reconnectTimeoutMs;\n    this.backoffPolicy = backoffPolicy;\n    this.shouldReconnect = true;\n    this.onlyRestartPeerConnection = false;\n    this.firstConnectionAttempted = false;\n    this.firstConnectionAttemptTimestampMs = 0;\n    this.lastActiveTimestampMs = Infinity;\n    this._isFirstConnection = true;\n    this.backoffTimer = null;\n    this.backoffCancel = null;\n    this.reset();\n  }\n\n  timeSpentReconnectingMs() {\n    if (!this.firstConnectionAttempted) {\n      return 0;\n    }\n\n    return Date.now() - this.firstConnectionAttemptTimestampMs;\n  }\n\n  hasPastReconnectDeadline() {\n    if (Date.now() - this.lastActiveTimestampMs >= this.reconnectTimeoutMs) {\n      return true;\n    }\n\n    return this.timeSpentReconnectingMs() >= this.reconnectTimeoutMs;\n  }\n\n  reset() {\n    this.cancel();\n    this.shouldReconnect = true;\n    this.onlyRestartPeerConnection = false;\n    this.firstConnectionAttempted = false;\n    this.firstConnectionAttemptTimestampMs = 0;\n    this.lastActiveTimestampMs = Infinity;\n    this.backoffPolicy.reset();\n  }\n\n  startedConnectionAttempt(isFirstConnection) {\n    this._isFirstConnection = isFirstConnection;\n\n    if (!this.firstConnectionAttempted) {\n      this.firstConnectionAttempted = true;\n      this.firstConnectionAttemptTimestampMs = Date.now();\n    }\n  }\n\n  hasStartedConnectionAttempt() {\n    return this.firstConnectionAttempted;\n  }\n\n  isFirstConnection() {\n    return this._isFirstConnection;\n  }\n\n  disableReconnect() {\n    this.shouldReconnect = false;\n  }\n\n  enableRestartPeerConnection() {\n    this.onlyRestartPeerConnection = true;\n  }\n\n  cancel() {\n    this.disableReconnect();\n\n    if (this.backoffTimer) {\n      this.backoffTimer.stop();\n\n      if (this.backoffCancel) {\n        this.backoffCancel();\n        this.backoffCancel = null;\n      }\n    }\n  }\n\n  retryWithBackoff(retryFunc, cancelFunc) {\n    const willRetry = this.shouldReconnect && !this.hasPastReconnectDeadline();\n\n    if (willRetry) {\n      this.backoffCancel = cancelFunc;\n      this.backoffTimer = new TimeoutScheduler_1.default(this.backoffPolicy.nextBackoffAmountMs());\n      this.backoffTimer.start(() => {\n        this.backoffCancel = null;\n        retryFunc();\n      });\n    }\n\n    return willRetry;\n  }\n\n  shouldOnlyRestartPeerConnection() {\n    return this.onlyRestartPeerConnection;\n  }\n\n  clone() {\n    return new DefaultReconnectController(this.reconnectTimeoutMs, this.backoffPolicy);\n  }\n\n  setLastActiveTimestampMs(timestampMs) {\n    this.lastActiveTimestampMs = timestampMs;\n  }\n\n}\n\nexports.default = DefaultReconnectController;","map":{"version":3,"sources":["../../src/reconnectcontroller/DefaultReconnectController.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TimeoutScheduler_1 = require(\"../scheduler/TimeoutScheduler\");\nclass DefaultReconnectController {\n    constructor(reconnectTimeoutMs, backoffPolicy) {\n        this.reconnectTimeoutMs = reconnectTimeoutMs;\n        this.backoffPolicy = backoffPolicy;\n        this.shouldReconnect = true;\n        this.onlyRestartPeerConnection = false;\n        this.firstConnectionAttempted = false;\n        this.firstConnectionAttemptTimestampMs = 0;\n        this.lastActiveTimestampMs = Infinity;\n        this._isFirstConnection = true;\n        this.backoffTimer = null;\n        this.backoffCancel = null;\n        this.reset();\n    }\n    timeSpentReconnectingMs() {\n        if (!this.firstConnectionAttempted) {\n            return 0;\n        }\n        return Date.now() - this.firstConnectionAttemptTimestampMs;\n    }\n    hasPastReconnectDeadline() {\n        if (Date.now() - this.lastActiveTimestampMs >= this.reconnectTimeoutMs) {\n            return true;\n        }\n        return this.timeSpentReconnectingMs() >= this.reconnectTimeoutMs;\n    }\n    reset() {\n        this.cancel();\n        this.shouldReconnect = true;\n        this.onlyRestartPeerConnection = false;\n        this.firstConnectionAttempted = false;\n        this.firstConnectionAttemptTimestampMs = 0;\n        this.lastActiveTimestampMs = Infinity;\n        this.backoffPolicy.reset();\n    }\n    startedConnectionAttempt(isFirstConnection) {\n        this._isFirstConnection = isFirstConnection;\n        if (!this.firstConnectionAttempted) {\n            this.firstConnectionAttempted = true;\n            this.firstConnectionAttemptTimestampMs = Date.now();\n        }\n    }\n    hasStartedConnectionAttempt() {\n        return this.firstConnectionAttempted;\n    }\n    isFirstConnection() {\n        return this._isFirstConnection;\n    }\n    disableReconnect() {\n        this.shouldReconnect = false;\n    }\n    enableRestartPeerConnection() {\n        this.onlyRestartPeerConnection = true;\n    }\n    cancel() {\n        this.disableReconnect();\n        if (this.backoffTimer) {\n            this.backoffTimer.stop();\n            if (this.backoffCancel) {\n                this.backoffCancel();\n                this.backoffCancel = null;\n            }\n        }\n    }\n    retryWithBackoff(retryFunc, cancelFunc) {\n        const willRetry = this.shouldReconnect && !this.hasPastReconnectDeadline();\n        if (willRetry) {\n            this.backoffCancel = cancelFunc;\n            this.backoffTimer = new TimeoutScheduler_1.default(this.backoffPolicy.nextBackoffAmountMs());\n            this.backoffTimer.start(() => {\n                this.backoffCancel = null;\n                retryFunc();\n            });\n        }\n        return willRetry;\n    }\n    shouldOnlyRestartPeerConnection() {\n        return this.onlyRestartPeerConnection;\n    }\n    clone() {\n        return new DefaultReconnectController(this.reconnectTimeoutMs, this.backoffPolicy);\n    }\n    setLastActiveTimestampMs(timestampMs) {\n        this.lastActiveTimestampMs = timestampMs;\n    }\n}\nexports.default = DefaultReconnectController;\n//# sourceMappingURL=DefaultReconnectController.js.map"]},"metadata":{},"sourceType":"script"}