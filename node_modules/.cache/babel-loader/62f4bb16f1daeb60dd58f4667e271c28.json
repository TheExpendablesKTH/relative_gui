{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Maybe_1 = require(\"../maybe/Maybe\");\n\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\n\nconst SimulcastLayers_1 = require(\"../simulcastlayers/SimulcastLayers\");\n\nconst SimulcastTransceiverController_1 = require(\"../transceivercontroller/SimulcastTransceiverController\");\n\nconst DefaultVideoCaptureAndEncodeParameter_1 = require(\"../videocaptureandencodeparameter/DefaultVideoCaptureAndEncodeParameter\");\n\nconst BitrateParameters_1 = require(\"./BitrateParameters\");\n/**\n * [[DefaultSimulcastUplinkPolicy]] determines capture and encode\n *  parameters that reacts to estimated uplink bandwidth\n */\n\n\nclass DefaultSimulcastUplinkPolicy {\n  constructor(selfAttendeeId, logger) {\n    this.selfAttendeeId = selfAttendeeId;\n    this.logger = logger;\n    this.numSenders = 0;\n    this.numParticipants = -1;\n    this.newQualityMap = new Map();\n    this.currentQualityMap = new Map();\n    this.newActiveStreams = 1\n    /* kHiAndLow */\n    ;\n    this.currentActiveStreams = 1\n    /* kHiAndLow */\n    ;\n    this.lastUplinkBandwidthKbps = DefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps;\n    this.startTimeMs = 0;\n    this.lastUpdatedMs = Date.now();\n    this.videoIndex = null;\n    this.currLocalDescriptions = [];\n    this.nextLocalDescriptions = [];\n    this.observerQueue = new Set();\n    this.optimalParameters = new DefaultVideoCaptureAndEncodeParameter_1.default(0, 0, 0, 0, true);\n    this.parametersInEffect = new DefaultVideoCaptureAndEncodeParameter_1.default(0, 0, 0, 0, true);\n    this.lastUplinkBandwidthKbps = DefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps;\n    this.currentQualityMap = this.fillEncodingParamWithBitrates([300, 0, 1200]);\n    this.newQualityMap = this.fillEncodingParamWithBitrates([300, 0, 1200]);\n  }\n\n  updateConnectionMetric({\n    uplinkKbps = 0\n  }) {\n    if (isNaN(uplinkKbps)) {\n      return;\n    } // Check if startup period in order to ignore estimate when video first enabled.\n    // If only audio was active then the estimate will be very low\n\n\n    if (this.startTimeMs === 0) {\n      this.startTimeMs = Date.now();\n    }\n\n    if (Date.now() - this.startTimeMs < DefaultSimulcastUplinkPolicy.startupDurationMs) {\n      this.lastUplinkBandwidthKbps = DefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps;\n    } else {\n      this.lastUplinkBandwidthKbps = uplinkKbps;\n    }\n\n    this.logger.debug(() => {\n      return `simulcast: uplink policy update metrics ${this.lastUplinkBandwidthKbps}`;\n    });\n    let holdTime = DefaultSimulcastUplinkPolicy.holdDownDurationMs;\n\n    if (this.currentActiveStreams === 3\n    /* kLow */\n    ) {\n        holdTime = DefaultSimulcastUplinkPolicy.holdDownDurationMs * 2;\n      } else if (this.currentActiveStreams === 2\n    /* kMidAndLow */\n    && uplinkKbps <= DefaultSimulcastUplinkPolicy.kMidDisabledRate || this.currentActiveStreams === 1\n    /* kHiAndLow */\n    && uplinkKbps <= DefaultSimulcastUplinkPolicy.kHiDisabledRate) {\n      holdTime = DefaultSimulcastUplinkPolicy.holdDownDurationMs / 2;\n    }\n\n    if (Date.now() < this.lastUpdatedMs + holdTime) {\n      return;\n    }\n\n    this.newQualityMap = this.calculateEncodingParameters(false);\n  }\n\n  calculateEncodingParameters(numSendersChanged) {\n    // bitrates parameter min is not used for now\n    const newBitrates = [new BitrateParameters_1.default(), new BitrateParameters_1.default(), new BitrateParameters_1.default()];\n    let hysteresisIncrease = 0,\n        hysteresisDecrease = 0;\n\n    if (this.currentActiveStreams === 0\n    /* kHi */\n    ) {\n        // Don't trigger redetermination based on rate if only one simulcast stream\n        hysteresisIncrease = this.lastUplinkBandwidthKbps + 1;\n        hysteresisDecrease = 0;\n      } else if (this.currentActiveStreams === 1\n    /* kHiAndLow */\n    ) {\n        hysteresisIncrease = 2400;\n        hysteresisDecrease = DefaultSimulcastUplinkPolicy.kHiDisabledRate;\n      } else if (this.currentActiveStreams === 2\n    /* kMidAndLow */\n    ) {\n        hysteresisIncrease = 1000;\n        hysteresisDecrease = DefaultSimulcastUplinkPolicy.kMidDisabledRate;\n      } else {\n      hysteresisIncrease = 300;\n      hysteresisDecrease = 0;\n    }\n\n    if (numSendersChanged || this.lastUplinkBandwidthKbps >= hysteresisIncrease || this.lastUplinkBandwidthKbps <= hysteresisDecrease) {\n      if (this.numParticipants >= 0 && this.numParticipants <= 2) {\n        // Simulcast disabled\n        this.newActiveStreams = 0\n        /* kHi */\n        ;\n        newBitrates[0].maxBitrateKbps = 0;\n        newBitrates[1].maxBitrateKbps = 0;\n        newBitrates[2].maxBitrateKbps = 1200;\n      } else if (this.numSenders <= 4 && this.lastUplinkBandwidthKbps >= DefaultSimulcastUplinkPolicy.kHiDisabledRate) {\n        // 320x192+ (640x384)  + 1280x768\n        this.newActiveStreams = 1\n        /* kHiAndLow */\n        ;\n        newBitrates[0].maxBitrateKbps = 300;\n        newBitrates[1].maxBitrateKbps = 0;\n        newBitrates[2].maxBitrateKbps = 1200;\n      } else if (this.lastUplinkBandwidthKbps >= DefaultSimulcastUplinkPolicy.kMidDisabledRate) {\n        // 320x192 + 640x384 + (1280x768)\n        this.newActiveStreams = 2\n        /* kMidAndLow */\n        ;\n        newBitrates[0].maxBitrateKbps = this.lastUplinkBandwidthKbps >= 350 ? 200 : 150;\n        newBitrates[1].maxBitrateKbps = this.numSenders <= 6 ? 600 : 350;\n        newBitrates[2].maxBitrateKbps = 0;\n      } else {\n        // 320x192 + 640x384 + (1280x768)\n        this.newActiveStreams = 3\n        /* kLow */\n        ;\n        newBitrates[0].maxBitrateKbps = 300;\n        newBitrates[1].maxBitrateKbps = 0;\n        newBitrates[2].maxBitrateKbps = 0;\n      }\n\n      const bitrates = newBitrates.map((v, _i, _a) => {\n        return v.maxBitrateKbps;\n      });\n      this.newQualityMap = this.fillEncodingParamWithBitrates(bitrates);\n\n      if (!this.encodingParametersEqual()) {\n        this.logger.info(`simulcast: policy:calculateEncodingParameters bw:${this.lastUplinkBandwidthKbps} numSources:${this.numSenders} numClients:${this.numParticipants} newQualityMap: ${this.getQualityMapString(this.newQualityMap)}`);\n      }\n    }\n\n    return this.newQualityMap;\n  }\n\n  chooseMediaTrackConstraints() {\n    // Changing MediaTrackConstraints causes a restart of video input and possible small\n    // scaling changes.  Always use 720p for now\n    const trackConstraint = {\n      width: {\n        ideal: 1280\n      },\n      height: {\n        ideal: 768\n      },\n      frameRate: {\n        ideal: 15\n      }\n    };\n    return trackConstraint;\n  }\n\n  chooseEncodingParameters() {\n    this.currentQualityMap = this.newQualityMap;\n    this.currentActiveStreams = this.newActiveStreams;\n\n    if (this.activeStreamsToPublish !== this.newActiveStreams) {\n      this.activeStreamsToPublish = this.newActiveStreams;\n      this.publishEncodingSimulcastLayer();\n    }\n\n    return this.currentQualityMap;\n  }\n\n  updateIndex(videoIndex) {\n    // the +1 for self is assuming that we intend to send video, since\n    // the context here is VideoUplinkBandwidthPolicy\n    const numSenders = videoIndex.numberOfVideoPublishingParticipantsExcludingSelf(this.selfAttendeeId) + 1;\n    const numParticipants = videoIndex.numberOfParticipants();\n    const numSendersChanged = numSenders !== this.numSenders;\n    const numParticipantsChanged = numParticipants > 2 && this.numParticipants <= 2 || numParticipants <= 2 && this.numParticipants > 2;\n    this.numSenders = numSenders;\n    this.numParticipants = numParticipants;\n    this.optimalParameters = new DefaultVideoCaptureAndEncodeParameter_1.default(this.captureWidth(), this.captureHeight(), this.captureFrameRate(), this.maxBandwidthKbps(), false);\n    this.videoIndex = videoIndex;\n    this.newQualityMap = this.calculateEncodingParameters(numSendersChanged || numParticipantsChanged);\n  }\n\n  wantsResubscribe() {\n    let constraintDiff = !this.encodingParametersEqual();\n    this.nextLocalDescriptions = this.videoIndex.localStreamDescriptions();\n\n    for (let i = 0; i < this.nextLocalDescriptions.length; i++) {\n      const streamId = this.nextLocalDescriptions[i].streamId;\n\n      if (streamId !== 0 && !!streamId) {\n        const prevIndex = this.currLocalDescriptions.findIndex(val => {\n          return val.streamId === streamId;\n        });\n\n        if (prevIndex !== -1) {\n          if (this.nextLocalDescriptions[i].disabledByWebRTC !== this.currLocalDescriptions[prevIndex].disabledByWebRTC) {\n            constraintDiff = true;\n          }\n        }\n      }\n    }\n\n    if (constraintDiff) {\n      this.lastUpdatedMs = Date.now();\n    }\n\n    this.currLocalDescriptions = this.nextLocalDescriptions;\n    return constraintDiff;\n  }\n\n  compareEncodingParameter(encoding1, encoding2) {\n    return JSON.stringify(encoding1) === JSON.stringify(encoding2);\n  }\n\n  encodingParametersEqual() {\n    let different = false;\n\n    for (const ridName of SimulcastTransceiverController_1.default.NAME_ARR_ASCENDING) {\n      different = different || !this.compareEncodingParameter(this.newQualityMap.get(ridName), this.currentQualityMap.get(ridName));\n\n      if (different) {\n        break;\n      }\n    }\n\n    return !different;\n  }\n\n  chooseCaptureAndEncodeParameters() {\n    // should deprecate in this policy\n    this.parametersInEffect = this.optimalParameters.clone();\n    return this.parametersInEffect.clone();\n  }\n\n  captureWidth() {\n    // should deprecate in this policy\n    const width = 1280;\n    return width;\n  }\n\n  captureHeight() {\n    // should deprecate in this policy\n    const height = 768;\n    return height;\n  }\n\n  captureFrameRate() {\n    // should deprecate in this policy\n    return 15;\n  }\n\n  maxBandwidthKbps() {\n    // should deprecate in this policy\n    return 1400;\n  }\n\n  setIdealMaxBandwidthKbps(_idealMaxBandwidthKbps) {// should deprecate in this policy\n  }\n\n  setHasBandwidthPriority(_hasBandwidthPriority) {// should deprecate in this policy\n  }\n\n  fillEncodingParamWithBitrates(bitratesKbps) {\n    const newMap = new Map();\n    const toBps = 1000;\n    const nameArr = SimulcastTransceiverController_1.default.NAME_ARR_ASCENDING;\n    const bitrateArr = bitratesKbps;\n    let scale = 4;\n\n    for (let i = 0; i < nameArr.length; i++) {\n      const ridName = nameArr[i];\n      newMap.set(ridName, {\n        rid: ridName,\n        active: bitrateArr[i] > 0 ? true : false,\n        scaleResolutionDownBy: scale,\n        maxBitrate: bitrateArr[i] * toBps\n      });\n      scale = scale / 2;\n    }\n\n    return newMap;\n  }\n\n  getQualityMapString(params) {\n    let qualityString = '';\n    const localDescriptions = this.videoIndex.localStreamDescriptions();\n\n    if (localDescriptions.length === 3) {\n      params.forEach(value => {\n        let disabledByWebRTC = false;\n        if (value.rid === 'low') disabledByWebRTC = localDescriptions[0].disabledByWebRTC;else if (value.rid === 'mid') disabledByWebRTC = localDescriptions[1].disabledByWebRTC;else disabledByWebRTC = localDescriptions[2].disabledByWebRTC;\n        qualityString += `{ rid: ${value.rid} active:${value.active} disabledByWebRTC: ${disabledByWebRTC} maxBitrate:${value.maxBitrate}}`;\n      });\n    }\n\n    return qualityString;\n  }\n\n  getEncodingSimulcastLayer(activeStreams) {\n    switch (activeStreams) {\n      case 0\n      /* kHi */\n      :\n        return SimulcastLayers_1.default.High;\n\n      case 1\n      /* kHiAndLow */\n      :\n        return SimulcastLayers_1.default.LowAndHigh;\n\n      case 2\n      /* kMidAndLow */\n      :\n        return SimulcastLayers_1.default.LowAndMedium;\n\n      case 3\n      /* kLow */\n      :\n        return SimulcastLayers_1.default.Low;\n    }\n  }\n\n  publishEncodingSimulcastLayer() {\n    const simulcastLayers = this.getEncodingSimulcastLayer(this.activeStreamsToPublish);\n    this.forEachObserver(observer => {\n      Maybe_1.default.of(observer.encodingSimulcastLayersDidChange).map(f => f.bind(observer)(simulcastLayers));\n    });\n  }\n\n  addObserver(observer) {\n    this.logger.info('adding simulcast uplink observer');\n    this.observerQueue.add(observer);\n  }\n\n  removeObserver(observer) {\n    this.logger.info('removing simulcast uplink observer');\n    this.observerQueue.delete(observer);\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observerQueue) {\n      AsyncScheduler_1.default.nextTick(() => {\n        if (this.observerQueue.has(observer)) {\n          observerFunc(observer);\n        }\n      });\n    }\n  }\n\n}\n\nexports.default = DefaultSimulcastUplinkPolicy;\nDefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps = 1200;\nDefaultSimulcastUplinkPolicy.startupDurationMs = 6000;\nDefaultSimulcastUplinkPolicy.holdDownDurationMs = 4000;\nDefaultSimulcastUplinkPolicy.defaultMaxFrameRate = 15; // Current rough estimates where webrtc disables streams\n\nDefaultSimulcastUplinkPolicy.kHiDisabledRate = 700;\nDefaultSimulcastUplinkPolicy.kMidDisabledRate = 240;","map":{"version":3,"sources":["../../src/videouplinkbandwidthpolicy/DefaultSimulcastUplinkPolicy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Maybe_1 = require(\"../maybe/Maybe\");\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\nconst SimulcastLayers_1 = require(\"../simulcastlayers/SimulcastLayers\");\nconst SimulcastTransceiverController_1 = require(\"../transceivercontroller/SimulcastTransceiverController\");\nconst DefaultVideoCaptureAndEncodeParameter_1 = require(\"../videocaptureandencodeparameter/DefaultVideoCaptureAndEncodeParameter\");\nconst BitrateParameters_1 = require(\"./BitrateParameters\");\n/**\n * [[DefaultSimulcastUplinkPolicy]] determines capture and encode\n *  parameters that reacts to estimated uplink bandwidth\n */\nclass DefaultSimulcastUplinkPolicy {\n    constructor(selfAttendeeId, logger) {\n        this.selfAttendeeId = selfAttendeeId;\n        this.logger = logger;\n        this.numSenders = 0;\n        this.numParticipants = -1;\n        this.newQualityMap = new Map();\n        this.currentQualityMap = new Map();\n        this.newActiveStreams = 1 /* kHiAndLow */;\n        this.currentActiveStreams = 1 /* kHiAndLow */;\n        this.lastUplinkBandwidthKbps = DefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps;\n        this.startTimeMs = 0;\n        this.lastUpdatedMs = Date.now();\n        this.videoIndex = null;\n        this.currLocalDescriptions = [];\n        this.nextLocalDescriptions = [];\n        this.observerQueue = new Set();\n        this.optimalParameters = new DefaultVideoCaptureAndEncodeParameter_1.default(0, 0, 0, 0, true);\n        this.parametersInEffect = new DefaultVideoCaptureAndEncodeParameter_1.default(0, 0, 0, 0, true);\n        this.lastUplinkBandwidthKbps = DefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps;\n        this.currentQualityMap = this.fillEncodingParamWithBitrates([300, 0, 1200]);\n        this.newQualityMap = this.fillEncodingParamWithBitrates([300, 0, 1200]);\n    }\n    updateConnectionMetric({ uplinkKbps = 0 }) {\n        if (isNaN(uplinkKbps)) {\n            return;\n        }\n        // Check if startup period in order to ignore estimate when video first enabled.\n        // If only audio was active then the estimate will be very low\n        if (this.startTimeMs === 0) {\n            this.startTimeMs = Date.now();\n        }\n        if (Date.now() - this.startTimeMs < DefaultSimulcastUplinkPolicy.startupDurationMs) {\n            this.lastUplinkBandwidthKbps = DefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps;\n        }\n        else {\n            this.lastUplinkBandwidthKbps = uplinkKbps;\n        }\n        this.logger.debug(() => {\n            return `simulcast: uplink policy update metrics ${this.lastUplinkBandwidthKbps}`;\n        });\n        let holdTime = DefaultSimulcastUplinkPolicy.holdDownDurationMs;\n        if (this.currentActiveStreams === 3 /* kLow */) {\n            holdTime = DefaultSimulcastUplinkPolicy.holdDownDurationMs * 2;\n        }\n        else if ((this.currentActiveStreams === 2 /* kMidAndLow */ &&\n            uplinkKbps <= DefaultSimulcastUplinkPolicy.kMidDisabledRate) ||\n            (this.currentActiveStreams === 1 /* kHiAndLow */ &&\n                uplinkKbps <= DefaultSimulcastUplinkPolicy.kHiDisabledRate)) {\n            holdTime = DefaultSimulcastUplinkPolicy.holdDownDurationMs / 2;\n        }\n        if (Date.now() < this.lastUpdatedMs + holdTime) {\n            return;\n        }\n        this.newQualityMap = this.calculateEncodingParameters(false);\n    }\n    calculateEncodingParameters(numSendersChanged) {\n        // bitrates parameter min is not used for now\n        const newBitrates = [\n            new BitrateParameters_1.default(),\n            new BitrateParameters_1.default(),\n            new BitrateParameters_1.default(),\n        ];\n        let hysteresisIncrease = 0, hysteresisDecrease = 0;\n        if (this.currentActiveStreams === 0 /* kHi */) {\n            // Don't trigger redetermination based on rate if only one simulcast stream\n            hysteresisIncrease = this.lastUplinkBandwidthKbps + 1;\n            hysteresisDecrease = 0;\n        }\n        else if (this.currentActiveStreams === 1 /* kHiAndLow */) {\n            hysteresisIncrease = 2400;\n            hysteresisDecrease = DefaultSimulcastUplinkPolicy.kHiDisabledRate;\n        }\n        else if (this.currentActiveStreams === 2 /* kMidAndLow */) {\n            hysteresisIncrease = 1000;\n            hysteresisDecrease = DefaultSimulcastUplinkPolicy.kMidDisabledRate;\n        }\n        else {\n            hysteresisIncrease = 300;\n            hysteresisDecrease = 0;\n        }\n        if (numSendersChanged ||\n            this.lastUplinkBandwidthKbps >= hysteresisIncrease ||\n            this.lastUplinkBandwidthKbps <= hysteresisDecrease) {\n            if (this.numParticipants >= 0 && this.numParticipants <= 2) {\n                // Simulcast disabled\n                this.newActiveStreams = 0 /* kHi */;\n                newBitrates[0].maxBitrateKbps = 0;\n                newBitrates[1].maxBitrateKbps = 0;\n                newBitrates[2].maxBitrateKbps = 1200;\n            }\n            else if (this.numSenders <= 4 &&\n                this.lastUplinkBandwidthKbps >= DefaultSimulcastUplinkPolicy.kHiDisabledRate) {\n                // 320x192+ (640x384)  + 1280x768\n                this.newActiveStreams = 1 /* kHiAndLow */;\n                newBitrates[0].maxBitrateKbps = 300;\n                newBitrates[1].maxBitrateKbps = 0;\n                newBitrates[2].maxBitrateKbps = 1200;\n            }\n            else if (this.lastUplinkBandwidthKbps >= DefaultSimulcastUplinkPolicy.kMidDisabledRate) {\n                // 320x192 + 640x384 + (1280x768)\n                this.newActiveStreams = 2 /* kMidAndLow */;\n                newBitrates[0].maxBitrateKbps = this.lastUplinkBandwidthKbps >= 350 ? 200 : 150;\n                newBitrates[1].maxBitrateKbps = this.numSenders <= 6 ? 600 : 350;\n                newBitrates[2].maxBitrateKbps = 0;\n            }\n            else {\n                // 320x192 + 640x384 + (1280x768)\n                this.newActiveStreams = 3 /* kLow */;\n                newBitrates[0].maxBitrateKbps = 300;\n                newBitrates[1].maxBitrateKbps = 0;\n                newBitrates[2].maxBitrateKbps = 0;\n            }\n            const bitrates = newBitrates.map((v, _i, _a) => {\n                return v.maxBitrateKbps;\n            });\n            this.newQualityMap = this.fillEncodingParamWithBitrates(bitrates);\n            if (!this.encodingParametersEqual()) {\n                this.logger.info(`simulcast: policy:calculateEncodingParameters bw:${this.lastUplinkBandwidthKbps} numSources:${this.numSenders} numClients:${this.numParticipants} newQualityMap: ${this.getQualityMapString(this.newQualityMap)}`);\n            }\n        }\n        return this.newQualityMap;\n    }\n    chooseMediaTrackConstraints() {\n        // Changing MediaTrackConstraints causes a restart of video input and possible small\n        // scaling changes.  Always use 720p for now\n        const trackConstraint = {\n            width: { ideal: 1280 },\n            height: { ideal: 768 },\n            frameRate: { ideal: 15 },\n        };\n        return trackConstraint;\n    }\n    chooseEncodingParameters() {\n        this.currentQualityMap = this.newQualityMap;\n        this.currentActiveStreams = this.newActiveStreams;\n        if (this.activeStreamsToPublish !== this.newActiveStreams) {\n            this.activeStreamsToPublish = this.newActiveStreams;\n            this.publishEncodingSimulcastLayer();\n        }\n        return this.currentQualityMap;\n    }\n    updateIndex(videoIndex) {\n        // the +1 for self is assuming that we intend to send video, since\n        // the context here is VideoUplinkBandwidthPolicy\n        const numSenders = videoIndex.numberOfVideoPublishingParticipantsExcludingSelf(this.selfAttendeeId) + 1;\n        const numParticipants = videoIndex.numberOfParticipants();\n        const numSendersChanged = numSenders !== this.numSenders;\n        const numParticipantsChanged = (numParticipants > 2 && this.numParticipants <= 2) ||\n            (numParticipants <= 2 && this.numParticipants > 2);\n        this.numSenders = numSenders;\n        this.numParticipants = numParticipants;\n        this.optimalParameters = new DefaultVideoCaptureAndEncodeParameter_1.default(this.captureWidth(), this.captureHeight(), this.captureFrameRate(), this.maxBandwidthKbps(), false);\n        this.videoIndex = videoIndex;\n        this.newQualityMap = this.calculateEncodingParameters(numSendersChanged || numParticipantsChanged);\n    }\n    wantsResubscribe() {\n        let constraintDiff = !this.encodingParametersEqual();\n        this.nextLocalDescriptions = this.videoIndex.localStreamDescriptions();\n        for (let i = 0; i < this.nextLocalDescriptions.length; i++) {\n            const streamId = this.nextLocalDescriptions[i].streamId;\n            if (streamId !== 0 && !!streamId) {\n                const prevIndex = this.currLocalDescriptions.findIndex(val => {\n                    return val.streamId === streamId;\n                });\n                if (prevIndex !== -1) {\n                    if (this.nextLocalDescriptions[i].disabledByWebRTC !==\n                        this.currLocalDescriptions[prevIndex].disabledByWebRTC) {\n                        constraintDiff = true;\n                    }\n                }\n            }\n        }\n        if (constraintDiff) {\n            this.lastUpdatedMs = Date.now();\n        }\n        this.currLocalDescriptions = this.nextLocalDescriptions;\n        return constraintDiff;\n    }\n    compareEncodingParameter(encoding1, encoding2) {\n        return JSON.stringify(encoding1) === JSON.stringify(encoding2);\n    }\n    encodingParametersEqual() {\n        let different = false;\n        for (const ridName of SimulcastTransceiverController_1.default.NAME_ARR_ASCENDING) {\n            different =\n                different ||\n                    !this.compareEncodingParameter(this.newQualityMap.get(ridName), this.currentQualityMap.get(ridName));\n            if (different) {\n                break;\n            }\n        }\n        return !different;\n    }\n    chooseCaptureAndEncodeParameters() {\n        // should deprecate in this policy\n        this.parametersInEffect = this.optimalParameters.clone();\n        return this.parametersInEffect.clone();\n    }\n    captureWidth() {\n        // should deprecate in this policy\n        const width = 1280;\n        return width;\n    }\n    captureHeight() {\n        // should deprecate in this policy\n        const height = 768;\n        return height;\n    }\n    captureFrameRate() {\n        // should deprecate in this policy\n        return 15;\n    }\n    maxBandwidthKbps() {\n        // should deprecate in this policy\n        return 1400;\n    }\n    setIdealMaxBandwidthKbps(_idealMaxBandwidthKbps) {\n        // should deprecate in this policy\n    }\n    setHasBandwidthPriority(_hasBandwidthPriority) {\n        // should deprecate in this policy\n    }\n    fillEncodingParamWithBitrates(bitratesKbps) {\n        const newMap = new Map();\n        const toBps = 1000;\n        const nameArr = SimulcastTransceiverController_1.default.NAME_ARR_ASCENDING;\n        const bitrateArr = bitratesKbps;\n        let scale = 4;\n        for (let i = 0; i < nameArr.length; i++) {\n            const ridName = nameArr[i];\n            newMap.set(ridName, {\n                rid: ridName,\n                active: bitrateArr[i] > 0 ? true : false,\n                scaleResolutionDownBy: scale,\n                maxBitrate: bitrateArr[i] * toBps,\n            });\n            scale = scale / 2;\n        }\n        return newMap;\n    }\n    getQualityMapString(params) {\n        let qualityString = '';\n        const localDescriptions = this.videoIndex.localStreamDescriptions();\n        if (localDescriptions.length === 3) {\n            params.forEach((value) => {\n                let disabledByWebRTC = false;\n                if (value.rid === 'low')\n                    disabledByWebRTC = localDescriptions[0].disabledByWebRTC;\n                else if (value.rid === 'mid')\n                    disabledByWebRTC = localDescriptions[1].disabledByWebRTC;\n                else\n                    disabledByWebRTC = localDescriptions[2].disabledByWebRTC;\n                qualityString += `{ rid: ${value.rid} active:${value.active} disabledByWebRTC: ${disabledByWebRTC} maxBitrate:${value.maxBitrate}}`;\n            });\n        }\n        return qualityString;\n    }\n    getEncodingSimulcastLayer(activeStreams) {\n        switch (activeStreams) {\n            case 0 /* kHi */:\n                return SimulcastLayers_1.default.High;\n            case 1 /* kHiAndLow */:\n                return SimulcastLayers_1.default.LowAndHigh;\n            case 2 /* kMidAndLow */:\n                return SimulcastLayers_1.default.LowAndMedium;\n            case 3 /* kLow */:\n                return SimulcastLayers_1.default.Low;\n        }\n    }\n    publishEncodingSimulcastLayer() {\n        const simulcastLayers = this.getEncodingSimulcastLayer(this.activeStreamsToPublish);\n        this.forEachObserver(observer => {\n            Maybe_1.default.of(observer.encodingSimulcastLayersDidChange).map(f => f.bind(observer)(simulcastLayers));\n        });\n    }\n    addObserver(observer) {\n        this.logger.info('adding simulcast uplink observer');\n        this.observerQueue.add(observer);\n    }\n    removeObserver(observer) {\n        this.logger.info('removing simulcast uplink observer');\n        this.observerQueue.delete(observer);\n    }\n    forEachObserver(observerFunc) {\n        for (const observer of this.observerQueue) {\n            AsyncScheduler_1.default.nextTick(() => {\n                if (this.observerQueue.has(observer)) {\n                    observerFunc(observer);\n                }\n            });\n        }\n    }\n}\nexports.default = DefaultSimulcastUplinkPolicy;\nDefaultSimulcastUplinkPolicy.defaultUplinkBandwidthKbps = 1200;\nDefaultSimulcastUplinkPolicy.startupDurationMs = 6000;\nDefaultSimulcastUplinkPolicy.holdDownDurationMs = 4000;\nDefaultSimulcastUplinkPolicy.defaultMaxFrameRate = 15;\n// Current rough estimates where webrtc disables streams\nDefaultSimulcastUplinkPolicy.kHiDisabledRate = 700;\nDefaultSimulcastUplinkPolicy.kMidDisabledRate = 240;\n//# sourceMappingURL=DefaultSimulcastUplinkPolicy.js.map"]},"metadata":{},"sourceType":"script"}