{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass DefaultTransceiverController {\n  constructor(logger, browserBehavior) {\n    this.logger = logger;\n    this.browserBehavior = browserBehavior;\n    this._localCameraTransceiver = null;\n    this._localAudioTransceiver = null;\n    this.videoSubscriptions = [];\n    this.defaultMediaStream = null;\n    this.peer = null;\n  }\n\n  setEncodingParameters(_params) {\n    return;\n  }\n\n  static setVideoSendingBitrateKbpsForSender(sender, bitrateKbps, _logger) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!sender || bitrateKbps <= 0) {\n        return;\n      }\n\n      const param = sender.getParameters();\n\n      if (!param.encodings) {\n        param.encodings = [{}];\n      }\n\n      for (const encodeParam of param.encodings) {\n        encodeParam.maxBitrate = bitrateKbps * 1000;\n      }\n\n      yield sender.setParameters(param);\n    });\n  }\n\n  static replaceAudioTrackForSender(sender, track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!sender) {\n        return false;\n      }\n\n      yield sender.replaceTrack(track);\n      return true;\n    });\n  }\n\n  localAudioTransceiver() {\n    return this._localAudioTransceiver;\n  }\n\n  localVideoTransceiver() {\n    return this._localCameraTransceiver;\n  }\n\n  setVideoSendingBitrateKbps(bitrateKbps) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // this won't set bandwidth limitation for video in Chrome\n      if (!this._localCameraTransceiver || this._localCameraTransceiver.direction !== 'sendrecv') {\n        return;\n      }\n\n      const sender = this._localCameraTransceiver.sender;\n      yield DefaultTransceiverController.setVideoSendingBitrateKbpsForSender(sender, bitrateKbps, this.logger);\n    });\n  }\n\n  setPeer(peer) {\n    this.peer = peer;\n  }\n\n  reset() {\n    this._localCameraTransceiver = null;\n    this._localAudioTransceiver = null;\n    this.videoSubscriptions = [];\n    this.defaultMediaStream = null;\n    this.peer = null;\n  }\n\n  useTransceivers() {\n    if (!this.peer || !this.browserBehavior.requiresUnifiedPlan()) {\n      return false;\n    }\n\n    return typeof this.peer.getTransceivers !== 'undefined';\n  }\n\n  hasVideoInput() {\n    if (!this._localCameraTransceiver || this._localCameraTransceiver.direction !== 'sendrecv') return false;\n    return true;\n  }\n\n  trackIsVideoInput(track) {\n    if (!this._localCameraTransceiver) {\n      return false;\n    }\n\n    return track === this._localCameraTransceiver.sender.track || track === this._localCameraTransceiver.receiver.track;\n  }\n\n  setupLocalTransceivers() {\n    if (!this.useTransceivers()) {\n      return;\n    }\n\n    if (!this.defaultMediaStream && typeof MediaStream !== 'undefined') {\n      this.defaultMediaStream = new MediaStream();\n    }\n\n    if (!this._localAudioTransceiver) {\n      this._localAudioTransceiver = this.peer.addTransceiver('audio', {\n        direction: 'inactive',\n        streams: [this.defaultMediaStream]\n      });\n    }\n\n    if (!this._localCameraTransceiver) {\n      this._localCameraTransceiver = this.peer.addTransceiver('video', {\n        direction: 'inactive',\n        streams: [this.defaultMediaStream]\n      });\n    }\n  }\n\n  replaceAudioTrack(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._localAudioTransceiver || this._localAudioTransceiver.direction !== 'sendrecv') {\n        this.logger.info(`audio transceiver direction is not set up or not activated`);\n        return false;\n      }\n\n      yield this._localAudioTransceiver.sender.replaceTrack(track);\n      return true;\n    });\n  }\n\n  setAudioInput(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.setTransceiverInput(this._localAudioTransceiver, track);\n      return;\n    });\n  }\n\n  setVideoInput(track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.setTransceiverInput(this._localCameraTransceiver, track);\n      return;\n    });\n  }\n\n  updateVideoTransceivers(videoStreamIndex, videosToReceive) {\n    if (!this.useTransceivers()) {\n      return videosToReceive.array();\n    } // See https://blog.mozilla.org/webrtc/rtcrtptransceiver-explored/ for details on transceivers\n\n\n    const transceivers = this.peer.getTransceivers(); // Subscription index 0 is reserved for transmitting camera.\n    // We mark inactive slots with 0 in the subscription array.\n\n    this.videoSubscriptions = [0];\n    videosToReceive = videosToReceive.clone();\n    this.updateTransceivers(transceivers, videoStreamIndex, videosToReceive);\n    this.logger.debug(() => {\n      return this.debugDumpTransceivers();\n    });\n    return this.videoSubscriptions;\n  }\n\n  updateTransceivers(transceivers, videoStreamIndex, videosToReceive) {\n    const videosRemaining = videosToReceive.array(); // Start by handling existing videos\n    // Begin counting out index in the the subscription array at 1 since the camera.\n    // Always occupies position 0 (whether active or not).\n\n    let n = 1;\n\n    for (const transceiver of transceivers) {\n      if (transceiver === this._localCameraTransceiver || !this.transceiverIsVideo(transceiver)) {\n        continue;\n      }\n\n      this.videoSubscriptions[n] = 0;\n\n      if (transceiver.direction !== 'inactive') {\n        // See if we want this existing transceiver\n        // by convention with the video host, msid is equal to the media section mid, prefixed with the string \"v_\"\n        // we use this to get the streamId for the track\n        const streamId = videoStreamIndex.streamIdForTrack('v_' + transceiver.mid);\n\n        if (streamId !== undefined) {\n          for (const [index, recvStreamId] of videosRemaining.entries()) {\n            if (videoStreamIndex.StreamIdsInSameGroup(streamId, recvStreamId)) {\n              transceiver.direction = 'recvonly';\n              this.videoSubscriptions[n] = recvStreamId;\n              videosRemaining.splice(index, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      n += 1;\n    } // Next fill in open slots and remove unused\n\n\n    n = 1;\n\n    for (const transceiver of transceivers) {\n      if (transceiver === this._localCameraTransceiver || !this.transceiverIsVideo(transceiver)) {\n        continue;\n      }\n\n      if (transceiver.direction === 'inactive' && videosRemaining.length > 0) {\n        // Fill available slot\n        transceiver.direction = 'recvonly';\n        const streamId = videosRemaining.shift();\n        this.videoSubscriptions[n] = streamId;\n      } else {\n        // Remove if no longer subscribed\n        if (this.videoSubscriptions[n] === 0) {\n          transceiver.direction = 'inactive';\n        }\n      }\n\n      n += 1;\n    } // add transceivers for the remaining subscriptions\n\n\n    for (const index of videosRemaining) {\n      // @ts-ignore\n      const transceiver = this.peer.addTransceiver('video', {\n        direction: 'recvonly',\n        streams: [this.defaultMediaStream]\n      });\n      this.videoSubscriptions.push(index);\n      this.logger.info(`adding transceiver mid: ${transceiver.mid} subscription: ${index} direction: recvonly`);\n    }\n  }\n\n  transceiverIsVideo(transceiver) {\n    return transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === 'video' || transceiver.sender && transceiver.sender.track && transceiver.sender.track.kind === 'video';\n  }\n\n  debugDumpTransceivers() {\n    let msg = '';\n    let n = 0;\n\n    for (const transceiver of this.peer.getTransceivers()) {\n      if (!this.transceiverIsVideo(transceiver)) {\n        continue;\n      }\n\n      msg += `transceiver index=${n} mid=${transceiver.mid} subscription=${this.videoSubscriptions[n]} direction=${transceiver.direction}\\n`;\n      n += 1;\n    }\n\n    return msg;\n  }\n\n  setTransceiverInput(transceiver, track) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!transceiver) {\n        return;\n      }\n\n      if (track) {\n        transceiver.direction = 'sendrecv';\n      } else {\n        transceiver.direction = 'inactive';\n      }\n\n      yield transceiver.sender.replaceTrack(track);\n    });\n  }\n\n}\n\nexports.default = DefaultTransceiverController;","map":{"version":3,"sources":["../../src/transceivercontroller/DefaultTransceiverController.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass DefaultTransceiverController {\n    constructor(logger, browserBehavior) {\n        this.logger = logger;\n        this.browserBehavior = browserBehavior;\n        this._localCameraTransceiver = null;\n        this._localAudioTransceiver = null;\n        this.videoSubscriptions = [];\n        this.defaultMediaStream = null;\n        this.peer = null;\n    }\n    setEncodingParameters(_params) {\n        return;\n    }\n    static setVideoSendingBitrateKbpsForSender(sender, bitrateKbps, _logger) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!sender || bitrateKbps <= 0) {\n                return;\n            }\n            const param = sender.getParameters();\n            if (!param.encodings) {\n                param.encodings = [{}];\n            }\n            for (const encodeParam of param.encodings) {\n                encodeParam.maxBitrate = bitrateKbps * 1000;\n            }\n            yield sender.setParameters(param);\n        });\n    }\n    static replaceAudioTrackForSender(sender, track) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!sender) {\n                return false;\n            }\n            yield sender.replaceTrack(track);\n            return true;\n        });\n    }\n    localAudioTransceiver() {\n        return this._localAudioTransceiver;\n    }\n    localVideoTransceiver() {\n        return this._localCameraTransceiver;\n    }\n    setVideoSendingBitrateKbps(bitrateKbps) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // this won't set bandwidth limitation for video in Chrome\n            if (!this._localCameraTransceiver || this._localCameraTransceiver.direction !== 'sendrecv') {\n                return;\n            }\n            const sender = this._localCameraTransceiver.sender;\n            yield DefaultTransceiverController.setVideoSendingBitrateKbpsForSender(sender, bitrateKbps, this.logger);\n        });\n    }\n    setPeer(peer) {\n        this.peer = peer;\n    }\n    reset() {\n        this._localCameraTransceiver = null;\n        this._localAudioTransceiver = null;\n        this.videoSubscriptions = [];\n        this.defaultMediaStream = null;\n        this.peer = null;\n    }\n    useTransceivers() {\n        if (!this.peer || !this.browserBehavior.requiresUnifiedPlan()) {\n            return false;\n        }\n        return typeof this.peer.getTransceivers !== 'undefined';\n    }\n    hasVideoInput() {\n        if (!this._localCameraTransceiver || this._localCameraTransceiver.direction !== 'sendrecv')\n            return false;\n        return true;\n    }\n    trackIsVideoInput(track) {\n        if (!this._localCameraTransceiver) {\n            return false;\n        }\n        return (track === this._localCameraTransceiver.sender.track ||\n            track === this._localCameraTransceiver.receiver.track);\n    }\n    setupLocalTransceivers() {\n        if (!this.useTransceivers()) {\n            return;\n        }\n        if (!this.defaultMediaStream && typeof MediaStream !== 'undefined') {\n            this.defaultMediaStream = new MediaStream();\n        }\n        if (!this._localAudioTransceiver) {\n            this._localAudioTransceiver = this.peer.addTransceiver('audio', {\n                direction: 'inactive',\n                streams: [this.defaultMediaStream],\n            });\n        }\n        if (!this._localCameraTransceiver) {\n            this._localCameraTransceiver = this.peer.addTransceiver('video', {\n                direction: 'inactive',\n                streams: [this.defaultMediaStream],\n            });\n        }\n    }\n    replaceAudioTrack(track) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._localAudioTransceiver || this._localAudioTransceiver.direction !== 'sendrecv') {\n                this.logger.info(`audio transceiver direction is not set up or not activated`);\n                return false;\n            }\n            yield this._localAudioTransceiver.sender.replaceTrack(track);\n            return true;\n        });\n    }\n    setAudioInput(track) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.setTransceiverInput(this._localAudioTransceiver, track);\n            return;\n        });\n    }\n    setVideoInput(track) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.setTransceiverInput(this._localCameraTransceiver, track);\n            return;\n        });\n    }\n    updateVideoTransceivers(videoStreamIndex, videosToReceive) {\n        if (!this.useTransceivers()) {\n            return videosToReceive.array();\n        }\n        // See https://blog.mozilla.org/webrtc/rtcrtptransceiver-explored/ for details on transceivers\n        const transceivers = this.peer.getTransceivers();\n        // Subscription index 0 is reserved for transmitting camera.\n        // We mark inactive slots with 0 in the subscription array.\n        this.videoSubscriptions = [0];\n        videosToReceive = videosToReceive.clone();\n        this.updateTransceivers(transceivers, videoStreamIndex, videosToReceive);\n        this.logger.debug(() => {\n            return this.debugDumpTransceivers();\n        });\n        return this.videoSubscriptions;\n    }\n    updateTransceivers(transceivers, videoStreamIndex, videosToReceive) {\n        const videosRemaining = videosToReceive.array();\n        // Start by handling existing videos\n        // Begin counting out index in the the subscription array at 1 since the camera.\n        // Always occupies position 0 (whether active or not).\n        let n = 1;\n        for (const transceiver of transceivers) {\n            if (transceiver === this._localCameraTransceiver || !this.transceiverIsVideo(transceiver)) {\n                continue;\n            }\n            this.videoSubscriptions[n] = 0;\n            if (transceiver.direction !== 'inactive') {\n                // See if we want this existing transceiver\n                // by convention with the video host, msid is equal to the media section mid, prefixed with the string \"v_\"\n                // we use this to get the streamId for the track\n                const streamId = videoStreamIndex.streamIdForTrack('v_' + transceiver.mid);\n                if (streamId !== undefined) {\n                    for (const [index, recvStreamId] of videosRemaining.entries()) {\n                        if (videoStreamIndex.StreamIdsInSameGroup(streamId, recvStreamId)) {\n                            transceiver.direction = 'recvonly';\n                            this.videoSubscriptions[n] = recvStreamId;\n                            videosRemaining.splice(index, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            n += 1;\n        }\n        // Next fill in open slots and remove unused\n        n = 1;\n        for (const transceiver of transceivers) {\n            if (transceiver === this._localCameraTransceiver || !this.transceiverIsVideo(transceiver)) {\n                continue;\n            }\n            if (transceiver.direction === 'inactive' && videosRemaining.length > 0) {\n                // Fill available slot\n                transceiver.direction = 'recvonly';\n                const streamId = videosRemaining.shift();\n                this.videoSubscriptions[n] = streamId;\n            }\n            else {\n                // Remove if no longer subscribed\n                if (this.videoSubscriptions[n] === 0) {\n                    transceiver.direction = 'inactive';\n                }\n            }\n            n += 1;\n        }\n        // add transceivers for the remaining subscriptions\n        for (const index of videosRemaining) {\n            // @ts-ignore\n            const transceiver = this.peer.addTransceiver('video', {\n                direction: 'recvonly',\n                streams: [this.defaultMediaStream],\n            });\n            this.videoSubscriptions.push(index);\n            this.logger.info(`adding transceiver mid: ${transceiver.mid} subscription: ${index} direction: recvonly`);\n        }\n    }\n    transceiverIsVideo(transceiver) {\n        return ((transceiver.receiver &&\n            transceiver.receiver.track &&\n            transceiver.receiver.track.kind === 'video') ||\n            (transceiver.sender && transceiver.sender.track && transceiver.sender.track.kind === 'video'));\n    }\n    debugDumpTransceivers() {\n        let msg = '';\n        let n = 0;\n        for (const transceiver of this.peer.getTransceivers()) {\n            if (!this.transceiverIsVideo(transceiver)) {\n                continue;\n            }\n            msg += `transceiver index=${n} mid=${transceiver.mid} subscription=${this.videoSubscriptions[n]} direction=${transceiver.direction}\\n`;\n            n += 1;\n        }\n        return msg;\n    }\n    setTransceiverInput(transceiver, track) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!transceiver) {\n                return;\n            }\n            if (track) {\n                transceiver.direction = 'sendrecv';\n            }\n            else {\n                transceiver.direction = 'inactive';\n            }\n            yield transceiver.sender.replaceTrack(track);\n        });\n    }\n}\nexports.default = DefaultTransceiverController;\n//# sourceMappingURL=DefaultTransceiverController.js.map"]},"metadata":{},"sourceType":"script"}