{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\n\nclass DefaultActiveSpeakerDetector {\n  constructor(realtimeController, selfAttendeeId, hasBandwidthPriorityCallback, waitIntervalMs = 1000, updateIntervalMs = 200) {\n    this.realtimeController = realtimeController;\n    this.selfAttendeeId = selfAttendeeId;\n    this.hasBandwidthPriorityCallback = hasBandwidthPriorityCallback;\n    this.waitIntervalMs = waitIntervalMs;\n    this.updateIntervalMs = updateIntervalMs;\n    this.speakerScores = {};\n    this.speakerMuteState = {};\n    this.detectorCallbackToHandler = new Map();\n    this.detectorCallbackToScoresTimer = new Map();\n    this.detectorCallbackToActivityTimer = new Map();\n    this.hasBandwidthPriority = false;\n    this.mostRecentUpdateTimestamp = {};\n  }\n\n  needUpdate(attendeeId) {\n    if (!this.activeSpeakers) {\n      return true;\n    }\n\n    return this.speakerScores[attendeeId] === 0 && this.activeSpeakers.includes(attendeeId) || this.speakerScores[attendeeId] > 0 && !this.activeSpeakers.includes(attendeeId);\n  }\n\n  updateActiveSpeakers(policy, callback, attendeeId) {\n    if (!this.needUpdate(attendeeId)) {\n      return;\n    }\n\n    const sortedSpeakers = [];\n    const attendeeIds = Object.keys(this.speakerScores);\n\n    for (let i = 0; i < attendeeIds.length; i++) {\n      const attendeeId = attendeeIds[i];\n      sortedSpeakers.push({\n        attendeeId: attendeeId,\n        activeScore: this.speakerScores[attendeeId]\n      });\n    }\n\n    const sortedAttendeeIds = sortedSpeakers.sort((s1, s2) => s2.activeScore - s1.activeScore).filter(function (s) {\n      return s.activeScore > 0;\n    }).map(function (s) {\n      return s.attendeeId;\n    });\n    this.activeSpeakers = sortedAttendeeIds;\n    callback(sortedAttendeeIds);\n    const selfIsActive = sortedAttendeeIds.length > 0 && sortedAttendeeIds[0] === this.selfAttendeeId;\n    const hasBandwidthPriority = selfIsActive && policy.prioritizeVideoSendBandwidthForActiveSpeaker();\n    const hasBandwidthPriorityDidChange = this.hasBandwidthPriority !== hasBandwidthPriority;\n\n    if (hasBandwidthPriorityDidChange) {\n      this.hasBandwidthPriority = hasBandwidthPriority;\n      this.hasBandwidthPriorityCallback(hasBandwidthPriority);\n    }\n  }\n\n  updateScore(policy, callback, attendeeId, volume, muted) {\n    const activeScore = policy.calculateScore(attendeeId, volume, muted);\n\n    if (this.speakerScores[attendeeId] !== activeScore) {\n      this.speakerScores[attendeeId] = activeScore;\n      this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n      this.updateActiveSpeakers(policy, callback, attendeeId);\n    }\n  }\n\n  subscribe(policy, callback, scoresCallback, scoresCallbackIntervalMs) {\n    const handler = (attendeeId, present) => {\n      if (!present) {\n        this.speakerScores[attendeeId] = 0;\n        this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n        this.updateActiveSpeakers(policy, callback, attendeeId);\n        return;\n      }\n\n      this.realtimeController.realtimeSubscribeToVolumeIndicator(attendeeId, (attendeeId, volume, muted, _signalStrength) => {\n        this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n\n        if (muted !== null) {\n          this.speakerMuteState[attendeeId] = muted;\n        }\n\n        this.updateScore(policy, callback, attendeeId, volume, muted);\n      });\n    };\n\n    this.detectorCallbackToHandler.set(callback, handler);\n    const activityTimer = new IntervalScheduler_1.default(this.updateIntervalMs);\n    activityTimer.start(() => {\n      for (const attendeeId in this.speakerScores) {\n        if (Date.now() - this.mostRecentUpdateTimestamp[attendeeId] > this.waitIntervalMs) {\n          this.updateScore(policy, callback, attendeeId, 0, this.speakerMuteState[attendeeId]);\n        }\n      }\n    });\n    this.detectorCallbackToActivityTimer.set(callback, activityTimer);\n\n    if (scoresCallback && scoresCallbackIntervalMs) {\n      const scoresTimer = new IntervalScheduler_1.default(scoresCallbackIntervalMs);\n      scoresTimer.start(() => {\n        scoresCallback(this.speakerScores);\n      });\n      this.detectorCallbackToScoresTimer.set(callback, scoresTimer);\n    }\n\n    this.realtimeController.realtimeSubscribeToAttendeeIdPresence(handler);\n  }\n\n  unsubscribe(callback) {\n    const handler = this.detectorCallbackToHandler.get(callback);\n    this.detectorCallbackToHandler.delete(callback);\n\n    if (handler) {\n      this.realtimeController.realtimeUnsubscribeToAttendeeIdPresence(handler);\n    }\n\n    const activityTimer = this.detectorCallbackToActivityTimer.get(callback);\n\n    if (activityTimer) {\n      activityTimer.stop();\n      this.detectorCallbackToActivityTimer.delete(callback);\n    }\n\n    const scoresTimer = this.detectorCallbackToScoresTimer.get(callback);\n\n    if (scoresTimer) {\n      scoresTimer.stop();\n      this.detectorCallbackToHandler.delete(callback);\n    }\n  }\n\n  destroy() {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const handler of this.detectorCallbackToHandler.values()) {\n        this.realtimeController.realtimeUnsubscribeToAttendeeIdPresence(handler);\n      }\n\n      for (const activityTimer of this.detectorCallbackToActivityTimer.values()) {\n        activityTimer.stop();\n      }\n\n      for (const scoresTimer of this.detectorCallbackToScoresTimer.values()) {\n        scoresTimer.stop();\n      }\n\n      this.detectorCallbackToHandler.clear();\n      this.detectorCallbackToActivityTimer.clear();\n      this.detectorCallbackToScoresTimer.clear();\n    });\n  }\n\n}\n\nexports.default = DefaultActiveSpeakerDetector;","map":{"version":3,"sources":["../../src/activespeakerdetector/DefaultActiveSpeakerDetector.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAA,mBAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;;AASA,MAAqB,4BAArB,CAAiD;AAsB/C,EAAA,WAAA,CACU,kBADV,EAEU,cAFV,EAGU,4BAHV,EAIU,cAAA,GAAyB,IAJnC,EAKU,gBAAA,GAA2B,GALrC,EAKwC;AAJ9B,SAAA,kBAAA,GAAA,kBAAA;AACA,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,4BAAA,GAAA,4BAAA;AACA,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,gBAAA,GAAA,gBAAA;AA1BF,SAAA,aAAA,GAAkD,EAAlD;AACA,SAAA,gBAAA,GAAsD,EAAtD;AAIA,SAAA,yBAAA,GAAoE,IAAI,GAAJ,EAApE;AAIA,SAAA,6BAAA,GAA0E,IAAI,GAAJ,EAA1E;AAIA,SAAA,+BAAA,GAA4E,IAAI,GAAJ,EAA5E;AAIA,SAAA,oBAAA,GAAuB,KAAvB;AAEA,SAAA,yBAAA,GAA8D,EAA9D;AAQJ;;AAEI,EAAA,UAAU,CAAC,UAAD,EAAmB;AACnC,QAAI,CAAC,KAAK,cAAV,EAA0B;AACxB,aAAO,IAAP;AACD;;AACD,WACG,KAAK,aAAL,CAAmB,UAAnB,MAAmC,CAAnC,IAAwC,KAAK,cAAL,CAAoB,QAApB,CAA6B,UAA7B,CAAzC,IACC,KAAK,aAAL,CAAmB,UAAnB,IAAiC,CAAjC,IAAsC,CAAC,KAAK,cAAL,CAAoB,QAApB,CAA6B,UAA7B,CAF1C;AAID;;AAEO,EAAA,oBAAoB,CAC1B,MAD0B,EAE1B,QAF0B,EAG1B,UAH0B,EAGR;AAElB,QAAI,CAAC,KAAK,UAAL,CAAgB,UAAhB,CAAL,EAAkC;AAChC;AACD;;AACD,UAAM,cAAc,GAAkD,EAAtE;AAEA,UAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,aAAjB,CAApB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,YAAM,UAAU,GAAG,WAAW,CAAC,CAAD,CAA9B;AACA,MAAA,cAAc,CAAC,IAAf,CAAoB;AAAE,QAAA,UAAU,EAAE,UAAd;AAA0B,QAAA,WAAW,EAAE,KAAK,aAAL,CAAmB,UAAnB;AAAvC,OAApB;AACD;;AAED,UAAM,iBAAiB,GAAG,cAAc,CACrC,IADuB,CAClB,CAAC,EAAD,EAAK,EAAL,KAAY,EAAE,CAAC,WAAH,GAAiB,EAAE,CAAC,WADd,EAEvB,MAFuB,CAEhB,UAAU,CAAV,EAAW;AACjB,aAAO,CAAC,CAAC,WAAF,GAAgB,CAAvB;AACD,KAJuB,EAKvB,GALuB,CAKnB,UAAU,CAAV,EAAW;AACd,aAAO,CAAC,CAAC,UAAT;AACD,KAPuB,CAA1B;AAQA,SAAK,cAAL,GAAsB,iBAAtB;AACA,IAAA,QAAQ,CAAC,iBAAD,CAAR;AACA,UAAM,YAAY,GAChB,iBAAiB,CAAC,MAAlB,GAA2B,CAA3B,IAAgC,iBAAiB,CAAC,CAAD,CAAjB,KAAyB,KAAK,cADhE;AAEA,UAAM,oBAAoB,GACxB,YAAY,IAAI,MAAM,CAAC,4CAAP,EADlB;AAEA,UAAM,6BAA6B,GAAG,KAAK,oBAAL,KAA8B,oBAApE;;AACA,QAAI,6BAAJ,EAAmC;AACjC,WAAK,oBAAL,GAA4B,oBAA5B;AACA,WAAK,4BAAL,CAAkC,oBAAlC;AACD;AACF;;AAEO,EAAA,WAAW,CACjB,MADiB,EAEjB,QAFiB,EAGjB,UAHiB,EAIjB,MAJiB,EAKjB,KALiB,EAKI;AAErB,UAAM,WAAW,GAAG,MAAM,CAAC,cAAP,CAAsB,UAAtB,EAAkC,MAAlC,EAA0C,KAA1C,CAApB;;AACA,QAAI,KAAK,aAAL,CAAmB,UAAnB,MAAmC,WAAvC,EAAoD;AAClD,WAAK,aAAL,CAAmB,UAAnB,IAAiC,WAAjC;AACA,WAAK,yBAAL,CAA+B,UAA/B,IAA6C,IAAI,CAAC,GAAL,EAA7C;AACA,WAAK,oBAAL,CAA0B,MAA1B,EAAkC,QAAlC,EAA4C,UAA5C;AACD;AACF;;AAED,EAAA,SAAS,CACP,MADO,EAEP,QAFO,EAGP,cAHO,EAIP,wBAJO,EAI0B;AAEjC,UAAM,OAAO,GAAG,CAAC,UAAD,EAAqB,OAArB,KAA+C;AAC7D,UAAI,CAAC,OAAL,EAAc;AACZ,aAAK,aAAL,CAAmB,UAAnB,IAAiC,CAAjC;AACA,aAAK,yBAAL,CAA+B,UAA/B,IAA6C,IAAI,CAAC,GAAL,EAA7C;AACA,aAAK,oBAAL,CAA0B,MAA1B,EAAkC,QAAlC,EAA4C,UAA5C;AACA;AACD;;AACD,WAAK,kBAAL,CAAwB,kCAAxB,CACE,UADF,EAEE,CACE,UADF,EAEE,MAFF,EAGE,KAHF,EAIE,eAJF,KAKI;AACF,aAAK,yBAAL,CAA+B,UAA/B,IAA6C,IAAI,CAAC,GAAL,EAA7C;;AACA,YAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,eAAK,gBAAL,CAAsB,UAAtB,IAAoC,KAApC;AACD;;AACD,aAAK,WAAL,CAAiB,MAAjB,EAAyB,QAAzB,EAAmC,UAAnC,EAA+C,MAA/C,EAAuD,KAAvD;AACD,OAbH;AAeD,KAtBD;;AAuBA,SAAK,yBAAL,CAA+B,GAA/B,CAAmC,QAAnC,EAA6C,OAA7C;AAEA,UAAM,aAAa,GAAG,IAAI,mBAAA,CAAA,OAAJ,CAAsB,KAAK,gBAA3B,CAAtB;AACA,IAAA,aAAa,CAAC,KAAd,CAAoB,MAAK;AACvB,WAAK,MAAM,UAAX,IAAyB,KAAK,aAA9B,EAA6C;AAC3C,YAAI,IAAI,CAAC,GAAL,KAAa,KAAK,yBAAL,CAA+B,UAA/B,CAAb,GAA0D,KAAK,cAAnE,EAAmF;AACjF,eAAK,WAAL,CAAiB,MAAjB,EAAyB,QAAzB,EAAmC,UAAnC,EAA+C,CAA/C,EAAkD,KAAK,gBAAL,CAAsB,UAAtB,CAAlD;AACD;AACF;AACF,KAND;AAOA,SAAK,+BAAL,CAAqC,GAArC,CAAyC,QAAzC,EAAmD,aAAnD;;AAEA,QAAI,cAAc,IAAI,wBAAtB,EAAgD;AAC9C,YAAM,WAAW,GAAG,IAAI,mBAAA,CAAA,OAAJ,CAAsB,wBAAtB,CAApB;AACA,MAAA,WAAW,CAAC,KAAZ,CAAkB,MAAK;AACrB,QAAA,cAAc,CAAC,KAAK,aAAN,CAAd;AACD,OAFD;AAGA,WAAK,6BAAL,CAAmC,GAAnC,CAAuC,QAAvC,EAAiD,WAAjD;AACD;;AACD,SAAK,kBAAL,CAAwB,qCAAxB,CAA8D,OAA9D;AACD;;AAED,EAAA,WAAW,CAAC,QAAD,EAA2B;AACpC,UAAM,OAAO,GAAG,KAAK,yBAAL,CAA+B,GAA/B,CAAmC,QAAnC,CAAhB;AACA,SAAK,yBAAL,CAA+B,MAA/B,CAAsC,QAAtC;;AACA,QAAI,OAAJ,EAAa;AACX,WAAK,kBAAL,CAAwB,uCAAxB,CAAgE,OAAhE;AACD;;AAED,UAAM,aAAa,GAAG,KAAK,+BAAL,CAAqC,GAArC,CAAyC,QAAzC,CAAtB;;AACA,QAAI,aAAJ,EAAmB;AACjB,MAAA,aAAa,CAAC,IAAd;AACA,WAAK,+BAAL,CAAqC,MAArC,CAA4C,QAA5C;AACD;;AAED,UAAM,WAAW,GAAG,KAAK,6BAAL,CAAmC,GAAnC,CAAuC,QAAvC,CAApB;;AACA,QAAI,WAAJ,EAAiB;AACf,MAAA,WAAW,CAAC,IAAZ;AACA,WAAK,yBAAL,CAA+B,MAA/B,CAAsC,QAAtC;AACD;AACF;;AAEK,EAAA,OAAO,GAAA;;AACX,WAAK,MAAM,OAAX,IAAsB,KAAK,yBAAL,CAA+B,MAA/B,EAAtB,EAA+D;AAC7D,aAAK,kBAAL,CAAwB,uCAAxB,CAAgE,OAAhE;AACD;;AACD,WAAK,MAAM,aAAX,IAA4B,KAAK,+BAAL,CAAqC,MAArC,EAA5B,EAA2E;AACzE,QAAA,aAAa,CAAC,IAAd;AACD;;AACD,WAAK,MAAM,WAAX,IAA0B,KAAK,6BAAL,CAAmC,MAAnC,EAA1B,EAAuE;AACrE,QAAA,WAAW,CAAC,IAAZ;AACD;;AAED,WAAK,yBAAL,CAA+B,KAA/B;AACA,WAAK,+BAAL,CAAqC,KAArC;AACA,WAAK,6BAAL,CAAmC,KAAnC;AACD,K;AAAA;;AAjL8C;;AAAjD,OAAA,CAAA,OAAA,GAAA,4BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\nclass DefaultActiveSpeakerDetector {\n    constructor(realtimeController, selfAttendeeId, hasBandwidthPriorityCallback, waitIntervalMs = 1000, updateIntervalMs = 200) {\n        this.realtimeController = realtimeController;\n        this.selfAttendeeId = selfAttendeeId;\n        this.hasBandwidthPriorityCallback = hasBandwidthPriorityCallback;\n        this.waitIntervalMs = waitIntervalMs;\n        this.updateIntervalMs = updateIntervalMs;\n        this.speakerScores = {};\n        this.speakerMuteState = {};\n        this.detectorCallbackToHandler = new Map();\n        this.detectorCallbackToScoresTimer = new Map();\n        this.detectorCallbackToActivityTimer = new Map();\n        this.hasBandwidthPriority = false;\n        this.mostRecentUpdateTimestamp = {};\n    }\n    needUpdate(attendeeId) {\n        if (!this.activeSpeakers) {\n            return true;\n        }\n        return ((this.speakerScores[attendeeId] === 0 && this.activeSpeakers.includes(attendeeId)) ||\n            (this.speakerScores[attendeeId] > 0 && !this.activeSpeakers.includes(attendeeId)));\n    }\n    updateActiveSpeakers(policy, callback, attendeeId) {\n        if (!this.needUpdate(attendeeId)) {\n            return;\n        }\n        const sortedSpeakers = [];\n        const attendeeIds = Object.keys(this.speakerScores);\n        for (let i = 0; i < attendeeIds.length; i++) {\n            const attendeeId = attendeeIds[i];\n            sortedSpeakers.push({ attendeeId: attendeeId, activeScore: this.speakerScores[attendeeId] });\n        }\n        const sortedAttendeeIds = sortedSpeakers\n            .sort((s1, s2) => s2.activeScore - s1.activeScore)\n            .filter(function (s) {\n            return s.activeScore > 0;\n        })\n            .map(function (s) {\n            return s.attendeeId;\n        });\n        this.activeSpeakers = sortedAttendeeIds;\n        callback(sortedAttendeeIds);\n        const selfIsActive = sortedAttendeeIds.length > 0 && sortedAttendeeIds[0] === this.selfAttendeeId;\n        const hasBandwidthPriority = selfIsActive && policy.prioritizeVideoSendBandwidthForActiveSpeaker();\n        const hasBandwidthPriorityDidChange = this.hasBandwidthPriority !== hasBandwidthPriority;\n        if (hasBandwidthPriorityDidChange) {\n            this.hasBandwidthPriority = hasBandwidthPriority;\n            this.hasBandwidthPriorityCallback(hasBandwidthPriority);\n        }\n    }\n    updateScore(policy, callback, attendeeId, volume, muted) {\n        const activeScore = policy.calculateScore(attendeeId, volume, muted);\n        if (this.speakerScores[attendeeId] !== activeScore) {\n            this.speakerScores[attendeeId] = activeScore;\n            this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n            this.updateActiveSpeakers(policy, callback, attendeeId);\n        }\n    }\n    subscribe(policy, callback, scoresCallback, scoresCallbackIntervalMs) {\n        const handler = (attendeeId, present) => {\n            if (!present) {\n                this.speakerScores[attendeeId] = 0;\n                this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n                this.updateActiveSpeakers(policy, callback, attendeeId);\n                return;\n            }\n            this.realtimeController.realtimeSubscribeToVolumeIndicator(attendeeId, (attendeeId, volume, muted, _signalStrength) => {\n                this.mostRecentUpdateTimestamp[attendeeId] = Date.now();\n                if (muted !== null) {\n                    this.speakerMuteState[attendeeId] = muted;\n                }\n                this.updateScore(policy, callback, attendeeId, volume, muted);\n            });\n        };\n        this.detectorCallbackToHandler.set(callback, handler);\n        const activityTimer = new IntervalScheduler_1.default(this.updateIntervalMs);\n        activityTimer.start(() => {\n            for (const attendeeId in this.speakerScores) {\n                if (Date.now() - this.mostRecentUpdateTimestamp[attendeeId] > this.waitIntervalMs) {\n                    this.updateScore(policy, callback, attendeeId, 0, this.speakerMuteState[attendeeId]);\n                }\n            }\n        });\n        this.detectorCallbackToActivityTimer.set(callback, activityTimer);\n        if (scoresCallback && scoresCallbackIntervalMs) {\n            const scoresTimer = new IntervalScheduler_1.default(scoresCallbackIntervalMs);\n            scoresTimer.start(() => {\n                scoresCallback(this.speakerScores);\n            });\n            this.detectorCallbackToScoresTimer.set(callback, scoresTimer);\n        }\n        this.realtimeController.realtimeSubscribeToAttendeeIdPresence(handler);\n    }\n    unsubscribe(callback) {\n        const handler = this.detectorCallbackToHandler.get(callback);\n        this.detectorCallbackToHandler.delete(callback);\n        if (handler) {\n            this.realtimeController.realtimeUnsubscribeToAttendeeIdPresence(handler);\n        }\n        const activityTimer = this.detectorCallbackToActivityTimer.get(callback);\n        if (activityTimer) {\n            activityTimer.stop();\n            this.detectorCallbackToActivityTimer.delete(callback);\n        }\n        const scoresTimer = this.detectorCallbackToScoresTimer.get(callback);\n        if (scoresTimer) {\n            scoresTimer.stop();\n            this.detectorCallbackToHandler.delete(callback);\n        }\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const handler of this.detectorCallbackToHandler.values()) {\n                this.realtimeController.realtimeUnsubscribeToAttendeeIdPresence(handler);\n            }\n            for (const activityTimer of this.detectorCallbackToActivityTimer.values()) {\n                activityTimer.stop();\n            }\n            for (const scoresTimer of this.detectorCallbackToScoresTimer.values()) {\n                scoresTimer.stop();\n            }\n            this.detectorCallbackToHandler.clear();\n            this.detectorCallbackToActivityTimer.clear();\n            this.detectorCallbackToScoresTimer.clear();\n        });\n    }\n}\nexports.default = DefaultActiveSpeakerDetector;\n//# sourceMappingURL=DefaultActiveSpeakerDetector.js.map"]},"metadata":{},"sourceType":"script"}