{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst MeetingSessionStatus_1 = require(\"../meetingsession/MeetingSessionStatus\");\n\nconst MeetingSessionStatusCode_1 = require(\"../meetingsession/MeetingSessionStatusCode\");\n\nconst MeetingSessionTURNCredentials_1 = require(\"../meetingsession/MeetingSessionTURNCredentials\");\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst SignalingClientJoin_1 = require(\"../signalingclient/SignalingClientJoin\");\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[JoinAndReceiveIndexTask]] sends the JoinFrame and asynchronously waits for the server to send the [[SdkIndexFrame]].\n * It should run with the [[TimeoutTask]] as the subtask so it can get canceled after timeout.\n */\n\n\nclass JoinAndReceiveIndexTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'JoinAndReceiveIndexTask';\n    this.taskCanceler = null;\n    this.maxVideos = 16;\n  }\n\n  cancel() {\n    if (this.taskCanceler) {\n      this.taskCanceler.cancel();\n      this.taskCanceler = null;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const indexFrame = yield new Promise((resolve, reject) => {\n        const context = this.context;\n        context.turnCredentials = null;\n\n        class IndexFrameInterceptor {\n          constructor(signalingClient) {\n            this.signalingClient = signalingClient;\n          }\n\n          cancel() {\n            this.signalingClient.removeObserver(this);\n            reject(new Error(`JoinAndReceiveIndexTask got canceled while waiting for SdkIndexFrame`));\n          }\n\n          handleSignalingClientEvent(event) {\n            if (event.type === SignalingClientEventType_1.default.WebSocketClosed) {\n              context.logger.warn(`signaling connection closed by server with code ${event.closeCode} and reason: ${event.closeReason}`);\n              let statusCode = MeetingSessionStatusCode_1.default.SignalingBadRequest;\n\n              if (event.closeCode === 4410) {\n                context.logger.warn(`the meeting cannot be joined because it is has been ended`);\n                statusCode = MeetingSessionStatusCode_1.default.MeetingEnded;\n              } else if (event.closeCode >= 4500 && event.closeCode < 4600) {\n                statusCode = MeetingSessionStatusCode_1.default.SignalingInternalServerError;\n              }\n\n              context.audioVideoController.handleMeetingSessionStatus(new MeetingSessionStatus_1.default(statusCode), null);\n              return;\n            }\n\n            if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame) {\n              return;\n            }\n\n            if (event.message.type === SignalingProtocol_js_1.SdkSignalFrame.Type.JOIN_ACK) {\n              // @ts-ignore: force cast to SdkJoinAckFrame\n              const joinAckFrame = event.message.joinack;\n\n              if (joinAckFrame && joinAckFrame.turnCredentials) {\n                context.turnCredentials = new MeetingSessionTURNCredentials_1.default();\n                context.turnCredentials.username = joinAckFrame.turnCredentials.username;\n                context.turnCredentials.password = joinAckFrame.turnCredentials.password;\n                context.turnCredentials.ttl = joinAckFrame.turnCredentials.ttl;\n                context.turnCredentials.uris = joinAckFrame.turnCredentials.uris.map(uri => {\n                  return context.meetingSessionConfiguration.urls.urlRewriter(uri);\n                }).filter(uri => {\n                  return !!uri;\n                });\n              } else {\n                context.logger.error('missing TURN credentials in JoinAckFrame');\n              }\n\n              return;\n            }\n\n            if (event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.INDEX) {\n              return;\n            }\n\n            this.signalingClient.removeObserver(this); // @ts-ignore: force cast to SdkIndexFrame\n\n            const indexFrame = event.message.index;\n            resolve(indexFrame);\n          }\n\n        }\n\n        const interceptor = new IndexFrameInterceptor(this.context.signalingClient);\n        this.context.signalingClient.registerObserver(interceptor);\n        this.taskCanceler = interceptor;\n        this.context.signalingClient.join(new SignalingClientJoin_1.default(this.maxVideos, true));\n      });\n      this.context.logger.info(`received first index ${JSON.stringify(indexFrame)}`);\n      this.context.indexFrame = indexFrame;\n    });\n  }\n\n}\n\nexports.default = JoinAndReceiveIndexTask;","map":{"version":3,"sources":["../../src/task/JoinAndReceiveIndexTask.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,MAAA,sBAAA,GAAA,OAAA,CAAA,wCAAA,CAAA;;AACA,MAAA,0BAAA,GAAA,OAAA,CAAA,4CAAA,CAAA;;AACA,MAAA,+BAAA,GAAA,OAAA,CAAA,iDAAA,CAAA;;AAGA,MAAA,0BAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,qBAAA,GAAA,OAAA,CAAA,wCAAA,CAAA;;AAEA,MAAA,sBAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAEA;;;AAGG;;;AACH,MAAqB,uBAArB,SAAqD,UAAA,CAAA,OAArD,CAA6D;AAK3D,EAAA,WAAA,CAAoB,OAApB,EAAsD;AACpD,UAAM,OAAO,CAAC,MAAd;AADkB,SAAA,OAAA,GAAA,OAAA;AAJV,SAAA,QAAA,GAAW,yBAAX;AACF,SAAA,YAAA,GAAoC,IAApC;AACA,SAAA,SAAA,GAAY,EAAZ;AAIP;;AAED,EAAA,MAAM,GAAA;AACJ,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,MAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACD;AACF;;AAEK,EAAA,GAAG,GAAA;;AACP,YAAM,UAAU,GAAG,MAAM,IAAI,OAAJ,CAA2B,CAAC,OAAD,EAAU,MAAV,KAAoB;AACtE,cAAM,OAAO,GAAG,KAAK,OAArB;AACA,QAAA,OAAO,CAAC,eAAR,GAA0B,IAA1B;;AACA,cAAM,qBAAN,CAA2B;AACzB,UAAA,WAAA,CAAoB,eAApB,EAAoD;AAAhC,iBAAA,eAAA,GAAA,eAAA;AAAoC;;AAExD,UAAA,MAAM,GAAA;AACJ,iBAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC;AACA,YAAA,MAAM,CAAC,IAAI,KAAJ,CAAU,sEAAV,CAAD,CAAN;AACD;;AAED,UAAA,0BAA0B,CAAC,KAAD,EAA4B;AACpD,gBAAI,KAAK,CAAC,IAAN,KAAe,0BAAA,CAAA,OAAA,CAAyB,eAA5C,EAA6D;AAC3D,cAAA,OAAO,CAAC,MAAR,CAAe,IAAf,CACE,mDAAmD,KAAK,CAAC,SAAS,gBAAgB,KAAK,CAAC,WAAW,EADrG;AAGA,kBAAI,UAAU,GAA6B,0BAAA,CAAA,OAAA,CAAyB,mBAApE;;AACA,kBAAI,KAAK,CAAC,SAAN,KAAoB,IAAxB,EAA8B;AAC5B,gBAAA,OAAO,CAAC,MAAR,CAAe,IAAf,CAAoB,2DAApB;AACA,gBAAA,UAAU,GAAG,0BAAA,CAAA,OAAA,CAAyB,YAAtC;AACD,eAHD,MAGO,IAAI,KAAK,CAAC,SAAN,IAAmB,IAAnB,IAA2B,KAAK,CAAC,SAAN,GAAkB,IAAjD,EAAuD;AAC5D,gBAAA,UAAU,GAAG,0BAAA,CAAA,OAAA,CAAyB,4BAAtC;AACD;;AACD,cAAA,OAAO,CAAC,oBAAR,CAA6B,0BAA7B,CACE,IAAI,sBAAA,CAAA,OAAJ,CAAyB,UAAzB,CADF,EAEE,IAFF;AAIA;AACD;;AACD,gBAAI,KAAK,CAAC,IAAN,KAAe,0BAAA,CAAA,OAAA,CAAyB,mBAA5C,EAAiE;AAC/D;AACD;;AACD,gBAAI,KAAK,CAAC,OAAN,CAAc,IAAd,KAAuB,sBAAA,CAAA,cAAA,CAAe,IAAf,CAAoB,QAA/C,EAAyD;AACvD;AACA,oBAAM,YAAY,GAAoB,KAAK,CAAC,OAAN,CAAc,OAApD;;AACA,kBAAI,YAAY,IAAI,YAAY,CAAC,eAAjC,EAAkD;AAChD,gBAAA,OAAO,CAAC,eAAR,GAA0B,IAAI,+BAAA,CAAA,OAAJ,EAA1B;AACA,gBAAA,OAAO,CAAC,eAAR,CAAwB,QAAxB,GAAmC,YAAY,CAAC,eAAb,CAA6B,QAAhE;AACA,gBAAA,OAAO,CAAC,eAAR,CAAwB,QAAxB,GAAmC,YAAY,CAAC,eAAb,CAA6B,QAAhE;AACA,gBAAA,OAAO,CAAC,eAAR,CAAwB,GAAxB,GAA8B,YAAY,CAAC,eAAb,CAA6B,GAA3D;AACA,gBAAA,OAAO,CAAC,eAAR,CAAwB,IAAxB,GAA+B,YAAY,CAAC,eAAb,CAA6B,IAA7B,CAC5B,GAD4B,CACvB,GAAD,IAAwB;AAC3B,yBAAO,OAAO,CAAC,2BAAR,CAAoC,IAApC,CAAyC,WAAzC,CAAqD,GAArD,CAAP;AACD,iBAH4B,EAI5B,MAJ4B,CAIpB,GAAD,IAAgB;AACtB,yBAAO,CAAC,CAAC,GAAT;AACD,iBAN4B,CAA/B;AAOD,eAZD,MAYO;AACL,gBAAA,OAAO,CAAC,MAAR,CAAe,KAAf,CAAqB,0CAArB;AACD;;AACD;AACD;;AACD,gBAAI,KAAK,CAAC,OAAN,CAAc,IAAd,KAAuB,sBAAA,CAAA,cAAA,CAAe,IAAf,CAAoB,KAA/C,EAAsD;AACpD;AACD;;AACD,iBAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC,EA5CoD,CA6CpD;;AACA,kBAAM,UAAU,GAAkB,KAAK,CAAC,OAAN,CAAc,KAAhD;AACA,YAAA,OAAO,CAAC,UAAD,CAAP;AACD;;AAxDwB;;AA0D3B,cAAM,WAAW,GAAG,IAAI,qBAAJ,CAA0B,KAAK,OAAL,CAAa,eAAvC,CAApB;AACA,aAAK,OAAL,CAAa,eAAb,CAA6B,gBAA7B,CAA8C,WAA9C;AACA,aAAK,YAAL,GAAoB,WAApB;AACA,aAAK,OAAL,CAAa,eAAb,CAA6B,IAA7B,CAAkC,IAAI,qBAAA,CAAA,OAAJ,CAAwB,KAAK,SAA7B,EAAwC,IAAxC,CAAlC;AACD,OAjEwB,CAAzB;AAkEA,WAAK,OAAL,CAAa,MAAb,CAAoB,IAApB,CAAyB,wBAAwB,IAAI,CAAC,SAAL,CAAe,UAAf,CAA0B,EAA3E;AACA,WAAK,OAAL,CAAa,UAAb,GAA0B,UAA1B;AACD,K;AAAA;;AArF0D;;AAA7D,OAAA,CAAA,OAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MeetingSessionStatus_1 = require(\"../meetingsession/MeetingSessionStatus\");\nconst MeetingSessionStatusCode_1 = require(\"../meetingsession/MeetingSessionStatusCode\");\nconst MeetingSessionTURNCredentials_1 = require(\"../meetingsession/MeetingSessionTURNCredentials\");\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\nconst SignalingClientJoin_1 = require(\"../signalingclient/SignalingClientJoin\");\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[JoinAndReceiveIndexTask]] sends the JoinFrame and asynchronously waits for the server to send the [[SdkIndexFrame]].\n * It should run with the [[TimeoutTask]] as the subtask so it can get canceled after timeout.\n */\nclass JoinAndReceiveIndexTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'JoinAndReceiveIndexTask';\n        this.taskCanceler = null;\n        this.maxVideos = 16;\n    }\n    cancel() {\n        if (this.taskCanceler) {\n            this.taskCanceler.cancel();\n            this.taskCanceler = null;\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const indexFrame = yield new Promise((resolve, reject) => {\n                const context = this.context;\n                context.turnCredentials = null;\n                class IndexFrameInterceptor {\n                    constructor(signalingClient) {\n                        this.signalingClient = signalingClient;\n                    }\n                    cancel() {\n                        this.signalingClient.removeObserver(this);\n                        reject(new Error(`JoinAndReceiveIndexTask got canceled while waiting for SdkIndexFrame`));\n                    }\n                    handleSignalingClientEvent(event) {\n                        if (event.type === SignalingClientEventType_1.default.WebSocketClosed) {\n                            context.logger.warn(`signaling connection closed by server with code ${event.closeCode} and reason: ${event.closeReason}`);\n                            let statusCode = MeetingSessionStatusCode_1.default.SignalingBadRequest;\n                            if (event.closeCode === 4410) {\n                                context.logger.warn(`the meeting cannot be joined because it is has been ended`);\n                                statusCode = MeetingSessionStatusCode_1.default.MeetingEnded;\n                            }\n                            else if (event.closeCode >= 4500 && event.closeCode < 4600) {\n                                statusCode = MeetingSessionStatusCode_1.default.SignalingInternalServerError;\n                            }\n                            context.audioVideoController.handleMeetingSessionStatus(new MeetingSessionStatus_1.default(statusCode), null);\n                            return;\n                        }\n                        if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame) {\n                            return;\n                        }\n                        if (event.message.type === SignalingProtocol_js_1.SdkSignalFrame.Type.JOIN_ACK) {\n                            // @ts-ignore: force cast to SdkJoinAckFrame\n                            const joinAckFrame = event.message.joinack;\n                            if (joinAckFrame && joinAckFrame.turnCredentials) {\n                                context.turnCredentials = new MeetingSessionTURNCredentials_1.default();\n                                context.turnCredentials.username = joinAckFrame.turnCredentials.username;\n                                context.turnCredentials.password = joinAckFrame.turnCredentials.password;\n                                context.turnCredentials.ttl = joinAckFrame.turnCredentials.ttl;\n                                context.turnCredentials.uris = joinAckFrame.turnCredentials.uris\n                                    .map((uri) => {\n                                    return context.meetingSessionConfiguration.urls.urlRewriter(uri);\n                                })\n                                    .filter((uri) => {\n                                    return !!uri;\n                                });\n                            }\n                            else {\n                                context.logger.error('missing TURN credentials in JoinAckFrame');\n                            }\n                            return;\n                        }\n                        if (event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.INDEX) {\n                            return;\n                        }\n                        this.signalingClient.removeObserver(this);\n                        // @ts-ignore: force cast to SdkIndexFrame\n                        const indexFrame = event.message.index;\n                        resolve(indexFrame);\n                    }\n                }\n                const interceptor = new IndexFrameInterceptor(this.context.signalingClient);\n                this.context.signalingClient.registerObserver(interceptor);\n                this.taskCanceler = interceptor;\n                this.context.signalingClient.join(new SignalingClientJoin_1.default(this.maxVideos, true));\n            });\n            this.context.logger.info(`received first index ${JSON.stringify(indexFrame)}`);\n            this.context.indexFrame = indexFrame;\n        });\n    }\n}\nexports.default = JoinAndReceiveIndexTask;\n//# sourceMappingURL=JoinAndReceiveIndexTask.js.map"]},"metadata":{},"sourceType":"script"}