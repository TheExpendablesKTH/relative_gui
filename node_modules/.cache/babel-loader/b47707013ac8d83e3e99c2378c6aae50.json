{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Maybe_1 = require(\"../maybe/Maybe\");\n\nconst MeetingSessionVideoAvailability_1 = require(\"../meetingsession/MeetingSessionVideoAvailability\");\n\nconst DefaultModality_1 = require(\"../modality/DefaultModality\");\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[ReceiveVideoStreamIndexTask]] receives [[SdkIndexFrame]] and updates [[VideoUplinkBandwidthPolicy]] and [[VideoDownlinkBandwidthPolicy]].\n */\n\n\nclass ReceiveVideoStreamIndexTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'ReceiveVideoStreamIndexTask';\n  }\n\n  removeObserver() {\n    this.context.signalingClient.removeObserver(this);\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.handleIndexFrame(this.context.indexFrame);\n      this.context.signalingClient.registerObserver(this);\n      this.context.removableObservers.push(this);\n    });\n  }\n\n  handleSignalingClientEvent(event) {\n    if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame || event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.INDEX) {\n      return;\n    } // @ts-ignore: force cast to SdkIndexFrame\n\n\n    const indexFrame = event.message.index;\n    this.context.logger.info(`received new index ${JSON.stringify(indexFrame)}`);\n    this.handleIndexFrame(indexFrame);\n  }\n\n  handleIndexFrame(indexFrame) {\n    if (!indexFrame) {\n      return;\n    } // Filter out self content share video\n\n\n    const selfAttendeeId = this.context.audioVideoController.configuration.credentials.attendeeId;\n    indexFrame.sources = indexFrame.sources.filter(source => {\n      const modality = new DefaultModality_1.default(source.attendeeId);\n      return !(modality.base() === selfAttendeeId && modality.hasModality(DefaultModality_1.default.MODALITY_CONTENT));\n    });\n    const {\n      videoStreamIndex,\n      videoDownlinkBandwidthPolicy,\n      videoUplinkBandwidthPolicy\n    } = this.context;\n    const oldVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n    videoStreamIndex.integrateIndexFrame(indexFrame);\n    videoDownlinkBandwidthPolicy.updateIndex(videoStreamIndex);\n    videoUplinkBandwidthPolicy.updateIndex(videoStreamIndex);\n    this.resubscribe(videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy);\n    this.updateVideoAvailability(indexFrame);\n    this.handleIndexVideosPausedAtSource();\n    const newVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n\n    if (!this.areVideoSourcesEqual(oldVideoSources, newVideoSources)) {\n      this.context.audioVideoController.forEachObserver(observer => {\n        Maybe_1.default.of(observer.remoteVideoSourcesDidChange).map(f => f.bind(observer)(newVideoSources));\n      });\n    }\n  }\n\n  areVideoSourcesEqual(oldVideoSources, newVideoSources) {\n    if (oldVideoSources.length !== newVideoSources.length) {\n      return false;\n    }\n\n    const compare = (videoSourceA, videoSourceB) => videoSourceA.attendee.attendeeId.localeCompare(videoSourceB.attendee.attendeeId);\n\n    const sortedOldVideoSources = [...oldVideoSources].sort(compare);\n    const sortedNewVideoSources = [...newVideoSources].sort(compare);\n\n    for (let i = 0; i < sortedOldVideoSources.length; i++) {\n      if (sortedOldVideoSources[i].attendee.attendeeId !== sortedNewVideoSources[i].attendee.attendeeId) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  resubscribe(videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy) {\n    const resubscribeForDownlink = videoDownlinkBandwidthPolicy.wantsResubscribe();\n    const resubscribeForUplink = (this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.TX || this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.DUPLEX) && videoUplinkBandwidthPolicy.wantsResubscribe();\n    const shouldResubscribe = resubscribeForDownlink || resubscribeForUplink;\n    this.logger.info(`should resubscribe: ${shouldResubscribe} (downlink: ${resubscribeForDownlink} uplink: ${resubscribeForUplink})`);\n\n    if (!shouldResubscribe) {\n      return;\n    }\n\n    this.context.videosToReceive = videoDownlinkBandwidthPolicy.chooseSubscriptions();\n    this.context.videoCaptureAndEncodeParameter = videoUplinkBandwidthPolicy.chooseCaptureAndEncodeParameters();\n    this.logger.info(`trigger resubscribe for up=${resubscribeForUplink} down=${resubscribeForDownlink}; videosToReceive=[${this.context.videosToReceive.array()}] captureParams=${JSON.stringify(this.context.videoCaptureAndEncodeParameter)}`);\n    this.context.audioVideoController.update();\n  }\n\n  updateVideoAvailability(indexFrame) {\n    if (!this.context.videosToReceive) {\n      this.logger.error('videosToReceive must be set in the meeting context.');\n      return;\n    }\n\n    const videoAvailability = new MeetingSessionVideoAvailability_1.default();\n    videoAvailability.remoteVideoAvailable = !this.context.videosToReceive.empty();\n    videoAvailability.canStartLocalVideo = !indexFrame.atCapacity;\n\n    if (!this.context.lastKnownVideoAvailability || !this.context.lastKnownVideoAvailability.equal(videoAvailability)) {\n      this.context.lastKnownVideoAvailability = videoAvailability.clone();\n      this.context.audioVideoController.forEachObserver(observer => {\n        Maybe_1.default.of(observer.videoAvailabilityDidChange).map(f => f.bind(observer)(videoAvailability.clone()));\n      });\n    }\n  }\n\n  handleIndexVideosPausedAtSource() {\n    const streamsPausedAtSource = this.context.videoStreamIndex.streamsPausedAtSource();\n\n    for (const tile of this.context.videoTileController.getAllVideoTiles()) {\n      const tileState = tile.state();\n\n      if (streamsPausedAtSource.contain(tileState.streamId)) {\n        if (tile.markPoorConnection()) {\n          this.logger.info(`marks the tile ${tileState.tileId} as having a poor connection`);\n        }\n      } else {\n        if (tile.unmarkPoorConnection()) {\n          this.logger.info(`unmarks the tile ${tileState.tileId} as having a poor connection`);\n        }\n      }\n    }\n  }\n\n}\n\nexports.default = ReceiveVideoStreamIndexTask;","map":{"version":3,"sources":["../../src/task/ReceiveVideoStreamIndexTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Maybe_1 = require(\"../maybe/Maybe\");\nconst MeetingSessionVideoAvailability_1 = require(\"../meetingsession/MeetingSessionVideoAvailability\");\nconst DefaultModality_1 = require(\"../modality/DefaultModality\");\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[ReceiveVideoStreamIndexTask]] receives [[SdkIndexFrame]] and updates [[VideoUplinkBandwidthPolicy]] and [[VideoDownlinkBandwidthPolicy]].\n */\nclass ReceiveVideoStreamIndexTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'ReceiveVideoStreamIndexTask';\n    }\n    removeObserver() {\n        this.context.signalingClient.removeObserver(this);\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.handleIndexFrame(this.context.indexFrame);\n            this.context.signalingClient.registerObserver(this);\n            this.context.removableObservers.push(this);\n        });\n    }\n    handleSignalingClientEvent(event) {\n        if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame ||\n            event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.INDEX) {\n            return;\n        }\n        // @ts-ignore: force cast to SdkIndexFrame\n        const indexFrame = event.message.index;\n        this.context.logger.info(`received new index ${JSON.stringify(indexFrame)}`);\n        this.handleIndexFrame(indexFrame);\n    }\n    handleIndexFrame(indexFrame) {\n        if (!indexFrame) {\n            return;\n        }\n        // Filter out self content share video\n        const selfAttendeeId = this.context.audioVideoController.configuration.credentials.attendeeId;\n        indexFrame.sources = indexFrame.sources.filter(source => {\n            const modality = new DefaultModality_1.default(source.attendeeId);\n            return !(modality.base() === selfAttendeeId && modality.hasModality(DefaultModality_1.default.MODALITY_CONTENT));\n        });\n        const { videoStreamIndex, videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy, } = this.context;\n        const oldVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n        videoStreamIndex.integrateIndexFrame(indexFrame);\n        videoDownlinkBandwidthPolicy.updateIndex(videoStreamIndex);\n        videoUplinkBandwidthPolicy.updateIndex(videoStreamIndex);\n        this.resubscribe(videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy);\n        this.updateVideoAvailability(indexFrame);\n        this.handleIndexVideosPausedAtSource();\n        const newVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n        if (!this.areVideoSourcesEqual(oldVideoSources, newVideoSources)) {\n            this.context.audioVideoController.forEachObserver((observer) => {\n                Maybe_1.default.of(observer.remoteVideoSourcesDidChange).map(f => f.bind(observer)(newVideoSources));\n            });\n        }\n    }\n    areVideoSourcesEqual(oldVideoSources, newVideoSources) {\n        if (oldVideoSources.length !== newVideoSources.length) {\n            return false;\n        }\n        const compare = (videoSourceA, videoSourceB) => videoSourceA.attendee.attendeeId.localeCompare(videoSourceB.attendee.attendeeId);\n        const sortedOldVideoSources = [...oldVideoSources].sort(compare);\n        const sortedNewVideoSources = [...newVideoSources].sort(compare);\n        for (let i = 0; i < sortedOldVideoSources.length; i++) {\n            if (sortedOldVideoSources[i].attendee.attendeeId !==\n                sortedNewVideoSources[i].attendee.attendeeId) {\n                return false;\n            }\n        }\n        return true;\n    }\n    resubscribe(videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy) {\n        const resubscribeForDownlink = videoDownlinkBandwidthPolicy.wantsResubscribe();\n        const resubscribeForUplink = (this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.TX ||\n            this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.DUPLEX) &&\n            videoUplinkBandwidthPolicy.wantsResubscribe();\n        const shouldResubscribe = resubscribeForDownlink || resubscribeForUplink;\n        this.logger.info(`should resubscribe: ${shouldResubscribe} (downlink: ${resubscribeForDownlink} uplink: ${resubscribeForUplink})`);\n        if (!shouldResubscribe) {\n            return;\n        }\n        this.context.videosToReceive = videoDownlinkBandwidthPolicy.chooseSubscriptions();\n        this.context.videoCaptureAndEncodeParameter = videoUplinkBandwidthPolicy.chooseCaptureAndEncodeParameters();\n        this.logger.info(`trigger resubscribe for up=${resubscribeForUplink} down=${resubscribeForDownlink}; videosToReceive=[${this.context.videosToReceive.array()}] captureParams=${JSON.stringify(this.context.videoCaptureAndEncodeParameter)}`);\n        this.context.audioVideoController.update();\n    }\n    updateVideoAvailability(indexFrame) {\n        if (!this.context.videosToReceive) {\n            this.logger.error('videosToReceive must be set in the meeting context.');\n            return;\n        }\n        const videoAvailability = new MeetingSessionVideoAvailability_1.default();\n        videoAvailability.remoteVideoAvailable = !this.context.videosToReceive.empty();\n        videoAvailability.canStartLocalVideo = !indexFrame.atCapacity;\n        if (!this.context.lastKnownVideoAvailability ||\n            !this.context.lastKnownVideoAvailability.equal(videoAvailability)) {\n            this.context.lastKnownVideoAvailability = videoAvailability.clone();\n            this.context.audioVideoController.forEachObserver((observer) => {\n                Maybe_1.default.of(observer.videoAvailabilityDidChange).map(f => f.bind(observer)(videoAvailability.clone()));\n            });\n        }\n    }\n    handleIndexVideosPausedAtSource() {\n        const streamsPausedAtSource = this.context.videoStreamIndex.streamsPausedAtSource();\n        for (const tile of this.context.videoTileController.getAllVideoTiles()) {\n            const tileState = tile.state();\n            if (streamsPausedAtSource.contain(tileState.streamId)) {\n                if (tile.markPoorConnection()) {\n                    this.logger.info(`marks the tile ${tileState.tileId} as having a poor connection`);\n                }\n            }\n            else {\n                if (tile.unmarkPoorConnection()) {\n                    this.logger.info(`unmarks the tile ${tileState.tileId} as having a poor connection`);\n                }\n            }\n        }\n    }\n}\nexports.default = ReceiveVideoStreamIndexTask;\n//# sourceMappingURL=ReceiveVideoStreamIndexTask.js.map"]},"metadata":{},"sourceType":"script"}