{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst FullJitterBackoff_1 = require(\"../backoff/FullJitterBackoff\");\n\nconst Message_1 = require(\"../message/Message\");\n\nconst DefaultReconnectController_1 = require(\"../reconnectcontroller/DefaultReconnectController\");\n\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\n\nconst DefaultSigV4_1 = require(\"../sigv4/DefaultSigV4\");\n\nconst DefaultWebSocketAdapter_1 = require(\"../websocketadapter/DefaultWebSocketAdapter\");\n\nconst WebSocketReadyState_1 = require(\"../websocketadapter/WebSocketReadyState\");\n\nclass DefaultMessagingSession {\n  constructor(configuration, logger, webSocket, reconnectController, sigV4) {\n    this.configuration = configuration;\n    this.logger = logger;\n    this.webSocket = webSocket;\n    this.reconnectController = reconnectController;\n    this.sigV4 = sigV4;\n    this.observerQueue = new Set();\n\n    if (!this.webSocket) {\n      this.webSocket = new DefaultWebSocketAdapter_1.default(this.logger);\n    }\n\n    if (!this.reconnectController) {\n      this.reconnectController = new DefaultReconnectController_1.default(configuration.reconnectTimeoutMs, new FullJitterBackoff_1.default(configuration.reconnectFixedWaitMs, configuration.reconnectShortBackoffMs, configuration.reconnectLongBackoffMs));\n    }\n\n    if (!this.sigV4) {\n      this.sigV4 = new DefaultSigV4_1.default(this.configuration.chimeClient, this.configuration.awsClient);\n    }\n  }\n\n  addObserver(observer) {\n    this.logger.info('adding messaging observer');\n    this.observerQueue.add(observer);\n  }\n\n  removeObserver(observer) {\n    this.logger.info('removing messaging observer');\n    this.observerQueue.delete(observer);\n  }\n\n  start() {\n    if (this.isClosed()) {\n      this.startConnecting(false);\n    } else {\n      this.logger.info('messaging session already started');\n    }\n  }\n\n  stop() {\n    if (!this.isClosed()) {\n      this.isClosing = true;\n      this.webSocket.close();\n    } else {\n      this.logger.info('no existing connection needs closing');\n    }\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observerQueue) {\n      AsyncScheduler_1.default.nextTick(() => {\n        if (this.observerQueue.has(observer)) {\n          observerFunc(observer);\n        }\n      });\n    }\n  }\n\n  setUpEventListeners() {\n    this.webSocket.addEventListener('open', () => {\n      this.openEventHandler();\n    });\n    this.webSocket.addEventListener('message', event => {\n      this.receiveMessageHandler(event.data);\n    });\n    this.webSocket.addEventListener('close', event => {\n      this.closeEventHandler(event);\n    });\n    this.webSocket.addEventListener('error', () => {\n      this.logger.error(`WebSocket error`);\n    });\n  }\n\n  startConnecting(reconnecting) {\n    const signedUrl = this.prepareWebSocketUrl();\n    this.logger.info(`opening connection to ${signedUrl}`);\n\n    if (!reconnecting) {\n      this.reconnectController.reset();\n    }\n\n    if (this.reconnectController.hasStartedConnectionAttempt()) {\n      this.reconnectController.startedConnectionAttempt(false);\n    } else {\n      this.reconnectController.startedConnectionAttempt(true);\n    }\n\n    this.webSocket.create(signedUrl, [], true);\n    this.forEachObserver(observer => {\n      if (observer.messagingSessionDidStartConnecting) {\n        observer.messagingSessionDidStartConnecting(reconnecting);\n      }\n    });\n    this.setUpEventListeners();\n  }\n\n  prepareWebSocketUrl() {\n    const queryParams = new Map();\n    queryParams.set('userArn', [this.configuration.userArn]);\n    queryParams.set('sessionId', [this.configuration.messagingSessionId]);\n    return this.sigV4.signURL('GET', 'wss', 'chime', this.configuration.endpointUrl, '/connect', '', queryParams);\n  }\n\n  isClosed() {\n    return this.webSocket.readyState() === WebSocketReadyState_1.default.None || this.webSocket.readyState() === WebSocketReadyState_1.default.Closed;\n  }\n\n  openEventHandler() {\n    this.reconnectController.reset();\n    this.isFirstMessageReceived = false;\n  }\n\n  receiveMessageHandler(data) {\n    try {\n      const jsonData = JSON.parse(data);\n      const messageType = jsonData.Headers['x-amz-chime-event-type'];\n      const message = new Message_1.default(messageType, jsonData.Headers, jsonData.Payload || null);\n\n      if (!this.isFirstMessageReceived) {\n        // Since backend does authorization after the websocket open we cannot rely on open event for didStart\n        // as the socket will close if authorization fail after it open. So we trigger didStart on first message event\n        // instead\n        this.forEachObserver(observer => {\n          if (observer.messagingSessionDidStart) {\n            observer.messagingSessionDidStart();\n          }\n        });\n        this.isFirstMessageReceived = true;\n      }\n\n      this.forEachObserver(observer => {\n        if (observer.messagingSessionDidReceiveMessage) {\n          observer.messagingSessionDidReceiveMessage(message);\n        }\n      });\n    } catch (error) {\n      this.logger.error(`Messaging parsing failed: ${error}`);\n    }\n  }\n\n  closeEventHandler(event) {\n    this.logger.info(`WebSocket close: ${event.code} ${event.reason}`);\n    this.webSocket.destroy();\n\n    if (!this.isClosing && this.canReconnect(event.code) && this.reconnectController.retryWithBackoff(() => __awaiter(this, void 0, void 0, function* () {\n      this.startConnecting(true);\n    }), null)) {\n      return;\n    }\n\n    this.isClosing = false;\n\n    if (this.isFirstMessageReceived) {\n      this.forEachObserver(observer => {\n        if (observer.messagingSessionDidStop) {\n          observer.messagingSessionDidStop(event);\n        }\n      });\n    }\n  }\n\n  canReconnect(closeCode) {\n    // 4003 is Kicked closing event from the back end\n    return closeCode === 1001 || closeCode === 1006 || closeCode >= 1011 && closeCode <= 1014 || closeCode > 4000 && closeCode !== 4002 && closeCode !== 4003 && closeCode !== 4401;\n  }\n\n}\n\nexports.default = DefaultMessagingSession;","map":{"version":3,"sources":["../../src/messagingsession/DefaultMessagingSession.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst FullJitterBackoff_1 = require(\"../backoff/FullJitterBackoff\");\nconst Message_1 = require(\"../message/Message\");\nconst DefaultReconnectController_1 = require(\"../reconnectcontroller/DefaultReconnectController\");\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\nconst DefaultSigV4_1 = require(\"../sigv4/DefaultSigV4\");\nconst DefaultWebSocketAdapter_1 = require(\"../websocketadapter/DefaultWebSocketAdapter\");\nconst WebSocketReadyState_1 = require(\"../websocketadapter/WebSocketReadyState\");\nclass DefaultMessagingSession {\n    constructor(configuration, logger, webSocket, reconnectController, sigV4) {\n        this.configuration = configuration;\n        this.logger = logger;\n        this.webSocket = webSocket;\n        this.reconnectController = reconnectController;\n        this.sigV4 = sigV4;\n        this.observerQueue = new Set();\n        if (!this.webSocket) {\n            this.webSocket = new DefaultWebSocketAdapter_1.default(this.logger);\n        }\n        if (!this.reconnectController) {\n            this.reconnectController = new DefaultReconnectController_1.default(configuration.reconnectTimeoutMs, new FullJitterBackoff_1.default(configuration.reconnectFixedWaitMs, configuration.reconnectShortBackoffMs, configuration.reconnectLongBackoffMs));\n        }\n        if (!this.sigV4) {\n            this.sigV4 = new DefaultSigV4_1.default(this.configuration.chimeClient, this.configuration.awsClient);\n        }\n    }\n    addObserver(observer) {\n        this.logger.info('adding messaging observer');\n        this.observerQueue.add(observer);\n    }\n    removeObserver(observer) {\n        this.logger.info('removing messaging observer');\n        this.observerQueue.delete(observer);\n    }\n    start() {\n        if (this.isClosed()) {\n            this.startConnecting(false);\n        }\n        else {\n            this.logger.info('messaging session already started');\n        }\n    }\n    stop() {\n        if (!this.isClosed()) {\n            this.isClosing = true;\n            this.webSocket.close();\n        }\n        else {\n            this.logger.info('no existing connection needs closing');\n        }\n    }\n    forEachObserver(observerFunc) {\n        for (const observer of this.observerQueue) {\n            AsyncScheduler_1.default.nextTick(() => {\n                if (this.observerQueue.has(observer)) {\n                    observerFunc(observer);\n                }\n            });\n        }\n    }\n    setUpEventListeners() {\n        this.webSocket.addEventListener('open', () => {\n            this.openEventHandler();\n        });\n        this.webSocket.addEventListener('message', (event) => {\n            this.receiveMessageHandler(event.data);\n        });\n        this.webSocket.addEventListener('close', (event) => {\n            this.closeEventHandler(event);\n        });\n        this.webSocket.addEventListener('error', () => {\n            this.logger.error(`WebSocket error`);\n        });\n    }\n    startConnecting(reconnecting) {\n        const signedUrl = this.prepareWebSocketUrl();\n        this.logger.info(`opening connection to ${signedUrl}`);\n        if (!reconnecting) {\n            this.reconnectController.reset();\n        }\n        if (this.reconnectController.hasStartedConnectionAttempt()) {\n            this.reconnectController.startedConnectionAttempt(false);\n        }\n        else {\n            this.reconnectController.startedConnectionAttempt(true);\n        }\n        this.webSocket.create(signedUrl, [], true);\n        this.forEachObserver(observer => {\n            if (observer.messagingSessionDidStartConnecting) {\n                observer.messagingSessionDidStartConnecting(reconnecting);\n            }\n        });\n        this.setUpEventListeners();\n    }\n    prepareWebSocketUrl() {\n        const queryParams = new Map();\n        queryParams.set('userArn', [this.configuration.userArn]);\n        queryParams.set('sessionId', [this.configuration.messagingSessionId]);\n        return this.sigV4.signURL('GET', 'wss', 'chime', this.configuration.endpointUrl, '/connect', '', queryParams);\n    }\n    isClosed() {\n        return (this.webSocket.readyState() === WebSocketReadyState_1.default.None ||\n            this.webSocket.readyState() === WebSocketReadyState_1.default.Closed);\n    }\n    openEventHandler() {\n        this.reconnectController.reset();\n        this.isFirstMessageReceived = false;\n    }\n    receiveMessageHandler(data) {\n        try {\n            const jsonData = JSON.parse(data);\n            const messageType = jsonData.Headers['x-amz-chime-event-type'];\n            const message = new Message_1.default(messageType, jsonData.Headers, jsonData.Payload || null);\n            if (!this.isFirstMessageReceived) {\n                // Since backend does authorization after the websocket open we cannot rely on open event for didStart\n                // as the socket will close if authorization fail after it open. So we trigger didStart on first message event\n                // instead\n                this.forEachObserver(observer => {\n                    if (observer.messagingSessionDidStart) {\n                        observer.messagingSessionDidStart();\n                    }\n                });\n                this.isFirstMessageReceived = true;\n            }\n            this.forEachObserver(observer => {\n                if (observer.messagingSessionDidReceiveMessage) {\n                    observer.messagingSessionDidReceiveMessage(message);\n                }\n            });\n        }\n        catch (error) {\n            this.logger.error(`Messaging parsing failed: ${error}`);\n        }\n    }\n    closeEventHandler(event) {\n        this.logger.info(`WebSocket close: ${event.code} ${event.reason}`);\n        this.webSocket.destroy();\n        if (!this.isClosing &&\n            this.canReconnect(event.code) &&\n            this.reconnectController.retryWithBackoff(() => __awaiter(this, void 0, void 0, function* () {\n                this.startConnecting(true);\n            }), null)) {\n            return;\n        }\n        this.isClosing = false;\n        if (this.isFirstMessageReceived) {\n            this.forEachObserver(observer => {\n                if (observer.messagingSessionDidStop) {\n                    observer.messagingSessionDidStop(event);\n                }\n            });\n        }\n    }\n    canReconnect(closeCode) {\n        // 4003 is Kicked closing event from the back end\n        return (closeCode === 1001 ||\n            closeCode === 1006 ||\n            (closeCode >= 1011 && closeCode <= 1014) ||\n            (closeCode > 4000 && closeCode !== 4002 && closeCode !== 4003 && closeCode !== 4401));\n    }\n}\nexports.default = DefaultMessagingSession;\n//# sourceMappingURL=DefaultMessagingSession.js.map"]},"metadata":{},"sourceType":"script"}