{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Maybe_1 = require(\"../maybe/Maybe\");\n\nclass SignalingAndMetricsConnectionMonitor {\n  constructor(audioVideoController, realtimeController, videoTileController, connectionHealthData, pingPong, statsCollector) {\n    this.audioVideoController = audioVideoController;\n    this.realtimeController = realtimeController;\n    this.videoTileController = videoTileController;\n    this.connectionHealthData = connectionHealthData;\n    this.pingPong = pingPong;\n    this.statsCollector = statsCollector;\n    this.isActive = false;\n    this.hasSeenValidPacketMetricsBefore = false;\n    this.lastAvailableSendBandwidthKbps = 0;\n    this.lastAvailableRecvBandwidthKbps = 0;\n    this.realtimeController.realtimeSubscribeToLocalSignalStrengthChange(signalStrength => {\n      if (this.isActive) {\n        this.receiveSignalStrengthChange(signalStrength);\n      }\n    });\n  }\n\n  start() {\n    this.isActive = true;\n    this.pingPong.addObserver(this);\n    this.pingPong.start();\n    this.audioVideoController.addObserver(this);\n  }\n\n  stop() {\n    this.isActive = false;\n    this.pingPong.removeObserver(this);\n    this.pingPong.stop();\n    this.audioVideoController.removeObserver(this);\n  }\n\n  receiveSignalStrengthChange(signalStrength) {\n    if (signalStrength === 0) {\n      this.connectionHealthData.setLastNoSignalTimestampMs(Date.now());\n    } else if (signalStrength <= 0.5) {\n      this.connectionHealthData.setLastWeakSignalTimestampMs(Date.now());\n    } else {\n      this.connectionHealthData.setLastGoodSignalTimestampMs(Date.now());\n    }\n\n    this.updateConnectionHealth();\n  }\n\n  didReceivePong(_id, latencyMs, clockSkewMs) {\n    this.connectionHealthData.setConsecutiveMissedPongs(0);\n    this.statsCollector.logLatency('ping_pong', latencyMs);\n    this.statsCollector.logLatency('ping_pong_clock_skew', clockSkewMs);\n    this.updateConnectionHealth();\n  }\n\n  didMissPongs() {\n    this.connectionHealthData.setConsecutiveMissedPongs(this.connectionHealthData.consecutiveMissedPongs + 1);\n    this.updateConnectionHealth();\n  }\n\n  metricsDidReceive(clientMetricReport) {\n    let packetsReceived = 0;\n    let fractionPacketsLostInbound = 0;\n    const metricReport = clientMetricReport.getObservableMetrics();\n    const potentialPacketsReceived = metricReport.audioPacketsReceived;\n    const potentialFractionPacketsLostInbound = metricReport.audioPacketsReceivedFractionLoss;\n    let videoUpstreamBitrateKbps = 0;\n    const videoUpstreamPacketPerSecond = metricReport.videoPacketSentPerSecond;\n    const videoUpstreamBitrate = metricReport.videoUpstreamBitrate;\n    const availableSendBandwidth = metricReport.availableSendBandwidth || metricReport.availableOutgoingBitrate;\n    const availableRecvBandwidth = metricReport.availableReceiveBandwidth || metricReport.availableIncomingBitrate;\n    const audioSpeakerDelayMs = metricReport.audioSpeakerDelayMs;\n    const nackCountPerSecond = metricReport.nackCountReceivedPerSecond || metricReport.googNackCountReceivedPerSecond; // Firefox does not presently have aggregated bandwidth estimation\n\n    if (typeof availableSendBandwidth === 'number' && !isNaN(availableSendBandwidth)) {\n      this.updateAvailableSendBandwidth(availableSendBandwidth / 1000, nackCountPerSecond);\n    }\n\n    if (typeof availableRecvBandwidth === 'number' && !isNaN(availableRecvBandwidth)) {\n      this.updateAvailableReceiveBandwidth(availableRecvBandwidth / 1000);\n    }\n\n    if (typeof videoUpstreamBitrate === 'number' && !isNaN(videoUpstreamBitrate)) {\n      videoUpstreamBitrateKbps = videoUpstreamBitrate / 1000;\n    }\n\n    if (typeof audioSpeakerDelayMs === 'number' && !isNaN(audioSpeakerDelayMs)) {\n      this.connectionHealthData.setAudioSpeakerDelayMs(audioSpeakerDelayMs);\n    }\n\n    this.monitorVideoUplinkHealth(videoUpstreamBitrateKbps, videoUpstreamPacketPerSecond);\n\n    if (typeof potentialPacketsReceived === 'number' && typeof potentialFractionPacketsLostInbound === 'number') {\n      packetsReceived = potentialPacketsReceived;\n      fractionPacketsLostInbound = potentialFractionPacketsLostInbound;\n\n      if (packetsReceived < 0 || fractionPacketsLostInbound < 0) {\n        // TODO: getting negative numbers on this metric after reconnect sometimes\n        // For now, just skip the metric if it looks weird.\n        return;\n      }\n    } else {\n      return;\n    }\n\n    this.addToMinuteWindow(this.connectionHealthData.packetsReceivedInLastMinute, packetsReceived);\n    this.addToMinuteWindow(this.connectionHealthData.fractionPacketsLostInboundInLastMinute, fractionPacketsLostInbound);\n\n    if (packetsReceived > 0) {\n      this.hasSeenValidPacketMetricsBefore = true;\n      this.connectionHealthData.setConsecutiveStatsWithNoPackets(0);\n    } else if (this.hasSeenValidPacketMetricsBefore) {\n      this.connectionHealthData.setConsecutiveStatsWithNoPackets(this.connectionHealthData.consecutiveStatsWithNoPackets + 1);\n    }\n\n    if (packetsReceived === 0 || fractionPacketsLostInbound > 0) {\n      this.connectionHealthData.setLastPacketLossInboundTimestampMs(Date.now());\n    }\n\n    this.updateConnectionHealth();\n  }\n\n  addToMinuteWindow(array, value) {\n    array.unshift(value);\n\n    if (array.length > 60) {\n      array.pop();\n    }\n  }\n\n  updateAvailableSendBandwidth(sendBandwidthKbps, nackCountPerSecond) {\n    if (sendBandwidthKbps !== this.lastAvailableSendBandwidthKbps) {\n      if (this.lastAvailableSendBandwidthKbps === 0) {\n        this.lastAvailableSendBandwidthKbps = sendBandwidthKbps;\n        return;\n      }\n\n      const prevSendBandwidthKbps = this.lastAvailableSendBandwidthKbps;\n      this.lastAvailableSendBandwidthKbps = sendBandwidthKbps;\n      this.audioVideoController.forEachObserver(observer => {\n        Maybe_1.default.of(observer.videoSendBandwidthDidChange).map(f => f.bind(observer)(sendBandwidthKbps, prevSendBandwidthKbps, nackCountPerSecond));\n      });\n    }\n  }\n\n  updateAvailableReceiveBandwidth(recvBandwidthKbps) {\n    if (recvBandwidthKbps !== this.lastAvailableRecvBandwidthKbps) {\n      if (this.lastAvailableRecvBandwidthKbps === 0) {\n        this.lastAvailableRecvBandwidthKbps = recvBandwidthKbps;\n        return;\n      }\n\n      const prevRecvBandwidthKbps = this.lastAvailableRecvBandwidthKbps;\n      this.lastAvailableRecvBandwidthKbps = recvBandwidthKbps;\n      this.audioVideoController.forEachObserver(observer => {\n        Maybe_1.default.of(observer.videoReceiveBandwidthDidChange).map(f => f.bind(observer)(recvBandwidthKbps, prevRecvBandwidthKbps));\n      });\n    }\n  }\n\n  updateConnectionHealth() {\n    this.audioVideoController.forEachObserver(observer => {\n      Maybe_1.default.of(observer.connectionHealthDidChange).map(f => f.bind(observer)(this.connectionHealthData.clone()));\n    });\n  }\n\n  monitorVideoUplinkHealth(videoUpstreamBitrateKbps, videoUpstreamPacketsPerSecond) {\n    if (!this.videoTileController.hasStartedLocalVideoTile()) {\n      return;\n    }\n\n    this.audioVideoController.forEachObserver(observer => {\n      Maybe_1.default.of(observer.videoSendHealthDidChange).map(f => f.bind(observer)(videoUpstreamBitrateKbps, videoUpstreamPacketsPerSecond));\n    });\n  }\n\n}\n\nexports.default = SignalingAndMetricsConnectionMonitor;","map":{"version":3,"sources":["../../src/connectionmonitor/SignalingAndMetricsConnectionMonitor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Maybe_1 = require(\"../maybe/Maybe\");\nclass SignalingAndMetricsConnectionMonitor {\n    constructor(audioVideoController, realtimeController, videoTileController, connectionHealthData, pingPong, statsCollector) {\n        this.audioVideoController = audioVideoController;\n        this.realtimeController = realtimeController;\n        this.videoTileController = videoTileController;\n        this.connectionHealthData = connectionHealthData;\n        this.pingPong = pingPong;\n        this.statsCollector = statsCollector;\n        this.isActive = false;\n        this.hasSeenValidPacketMetricsBefore = false;\n        this.lastAvailableSendBandwidthKbps = 0;\n        this.lastAvailableRecvBandwidthKbps = 0;\n        this.realtimeController.realtimeSubscribeToLocalSignalStrengthChange((signalStrength) => {\n            if (this.isActive) {\n                this.receiveSignalStrengthChange(signalStrength);\n            }\n        });\n    }\n    start() {\n        this.isActive = true;\n        this.pingPong.addObserver(this);\n        this.pingPong.start();\n        this.audioVideoController.addObserver(this);\n    }\n    stop() {\n        this.isActive = false;\n        this.pingPong.removeObserver(this);\n        this.pingPong.stop();\n        this.audioVideoController.removeObserver(this);\n    }\n    receiveSignalStrengthChange(signalStrength) {\n        if (signalStrength === 0) {\n            this.connectionHealthData.setLastNoSignalTimestampMs(Date.now());\n        }\n        else if (signalStrength <= 0.5) {\n            this.connectionHealthData.setLastWeakSignalTimestampMs(Date.now());\n        }\n        else {\n            this.connectionHealthData.setLastGoodSignalTimestampMs(Date.now());\n        }\n        this.updateConnectionHealth();\n    }\n    didReceivePong(_id, latencyMs, clockSkewMs) {\n        this.connectionHealthData.setConsecutiveMissedPongs(0);\n        this.statsCollector.logLatency('ping_pong', latencyMs);\n        this.statsCollector.logLatency('ping_pong_clock_skew', clockSkewMs);\n        this.updateConnectionHealth();\n    }\n    didMissPongs() {\n        this.connectionHealthData.setConsecutiveMissedPongs(this.connectionHealthData.consecutiveMissedPongs + 1);\n        this.updateConnectionHealth();\n    }\n    metricsDidReceive(clientMetricReport) {\n        let packetsReceived = 0;\n        let fractionPacketsLostInbound = 0;\n        const metricReport = clientMetricReport.getObservableMetrics();\n        const potentialPacketsReceived = metricReport.audioPacketsReceived;\n        const potentialFractionPacketsLostInbound = metricReport.audioPacketsReceivedFractionLoss;\n        let videoUpstreamBitrateKbps = 0;\n        const videoUpstreamPacketPerSecond = metricReport.videoPacketSentPerSecond;\n        const videoUpstreamBitrate = metricReport.videoUpstreamBitrate;\n        const availableSendBandwidth = metricReport.availableSendBandwidth || metricReport.availableOutgoingBitrate;\n        const availableRecvBandwidth = metricReport.availableReceiveBandwidth || metricReport.availableIncomingBitrate;\n        const audioSpeakerDelayMs = metricReport.audioSpeakerDelayMs;\n        const nackCountPerSecond = metricReport.nackCountReceivedPerSecond || metricReport.googNackCountReceivedPerSecond;\n        // Firefox does not presently have aggregated bandwidth estimation\n        if (typeof availableSendBandwidth === 'number' && !isNaN(availableSendBandwidth)) {\n            this.updateAvailableSendBandwidth(availableSendBandwidth / 1000, nackCountPerSecond);\n        }\n        if (typeof availableRecvBandwidth === 'number' && !isNaN(availableRecvBandwidth)) {\n            this.updateAvailableReceiveBandwidth(availableRecvBandwidth / 1000);\n        }\n        if (typeof videoUpstreamBitrate === 'number' && !isNaN(videoUpstreamBitrate)) {\n            videoUpstreamBitrateKbps = videoUpstreamBitrate / 1000;\n        }\n        if (typeof audioSpeakerDelayMs === 'number' && !isNaN(audioSpeakerDelayMs)) {\n            this.connectionHealthData.setAudioSpeakerDelayMs(audioSpeakerDelayMs);\n        }\n        this.monitorVideoUplinkHealth(videoUpstreamBitrateKbps, videoUpstreamPacketPerSecond);\n        if (typeof potentialPacketsReceived === 'number' &&\n            typeof potentialFractionPacketsLostInbound === 'number') {\n            packetsReceived = potentialPacketsReceived;\n            fractionPacketsLostInbound = potentialFractionPacketsLostInbound;\n            if (packetsReceived < 0 || fractionPacketsLostInbound < 0) {\n                // TODO: getting negative numbers on this metric after reconnect sometimes\n                // For now, just skip the metric if it looks weird.\n                return;\n            }\n        }\n        else {\n            return;\n        }\n        this.addToMinuteWindow(this.connectionHealthData.packetsReceivedInLastMinute, packetsReceived);\n        this.addToMinuteWindow(this.connectionHealthData.fractionPacketsLostInboundInLastMinute, fractionPacketsLostInbound);\n        if (packetsReceived > 0) {\n            this.hasSeenValidPacketMetricsBefore = true;\n            this.connectionHealthData.setConsecutiveStatsWithNoPackets(0);\n        }\n        else if (this.hasSeenValidPacketMetricsBefore) {\n            this.connectionHealthData.setConsecutiveStatsWithNoPackets(this.connectionHealthData.consecutiveStatsWithNoPackets + 1);\n        }\n        if (packetsReceived === 0 || fractionPacketsLostInbound > 0) {\n            this.connectionHealthData.setLastPacketLossInboundTimestampMs(Date.now());\n        }\n        this.updateConnectionHealth();\n    }\n    addToMinuteWindow(array, value) {\n        array.unshift(value);\n        if (array.length > 60) {\n            array.pop();\n        }\n    }\n    updateAvailableSendBandwidth(sendBandwidthKbps, nackCountPerSecond) {\n        if (sendBandwidthKbps !== this.lastAvailableSendBandwidthKbps) {\n            if (this.lastAvailableSendBandwidthKbps === 0) {\n                this.lastAvailableSendBandwidthKbps = sendBandwidthKbps;\n                return;\n            }\n            const prevSendBandwidthKbps = this.lastAvailableSendBandwidthKbps;\n            this.lastAvailableSendBandwidthKbps = sendBandwidthKbps;\n            this.audioVideoController.forEachObserver((observer) => {\n                Maybe_1.default.of(observer.videoSendBandwidthDidChange).map(f => f.bind(observer)(sendBandwidthKbps, prevSendBandwidthKbps, nackCountPerSecond));\n            });\n        }\n    }\n    updateAvailableReceiveBandwidth(recvBandwidthKbps) {\n        if (recvBandwidthKbps !== this.lastAvailableRecvBandwidthKbps) {\n            if (this.lastAvailableRecvBandwidthKbps === 0) {\n                this.lastAvailableRecvBandwidthKbps = recvBandwidthKbps;\n                return;\n            }\n            const prevRecvBandwidthKbps = this.lastAvailableRecvBandwidthKbps;\n            this.lastAvailableRecvBandwidthKbps = recvBandwidthKbps;\n            this.audioVideoController.forEachObserver((observer) => {\n                Maybe_1.default.of(observer.videoReceiveBandwidthDidChange).map(f => f.bind(observer)(recvBandwidthKbps, prevRecvBandwidthKbps));\n            });\n        }\n    }\n    updateConnectionHealth() {\n        this.audioVideoController.forEachObserver((observer) => {\n            Maybe_1.default.of(observer.connectionHealthDidChange).map(f => f.bind(observer)(this.connectionHealthData.clone()));\n        });\n    }\n    monitorVideoUplinkHealth(videoUpstreamBitrateKbps, videoUpstreamPacketsPerSecond) {\n        if (!this.videoTileController.hasStartedLocalVideoTile()) {\n            return;\n        }\n        this.audioVideoController.forEachObserver((observer) => {\n            Maybe_1.default.of(observer.videoSendHealthDidChange).map(f => f.bind(observer)(videoUpstreamBitrateKbps, videoUpstreamPacketsPerSecond));\n        });\n    }\n}\nexports.default = SignalingAndMetricsConnectionMonitor;\n//# sourceMappingURL=SignalingAndMetricsConnectionMonitor.js.map"]},"metadata":{},"sourceType":"script"}