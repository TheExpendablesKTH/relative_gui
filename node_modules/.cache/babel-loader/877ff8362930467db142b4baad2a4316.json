{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This class simplifies the process of defining a transform device that\n * does not modify its input device constraints, and provides only a single audio node\n * to apply transforms.\n *\n * Subclass `SingleNodeAudioTransformDevice`, implementing `createSingleAudioNode`.\n */\n\nclass SingleNodeAudioTransformDevice {\n  constructor(inner) {\n    this.inner = inner;\n  }\n\n  mute(_muted) {\n    return __awaiter(this, void 0, void 0, function* () {});\n  }\n  /**\n   * `stop` should be called by the application to free any resources associated\n   * with the device (e.g., workers).\n   *\n   * After this is called, the device should be discarded.\n   */\n\n\n  stop() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = this.node) === null || _a === void 0 ? void 0 : _a.disconnect();\n    });\n  }\n  /**\n   * Return the inner {@link Device} that the device controller should select as part\n   * of the application of this `AudioTransformDevice`.\n   */\n\n\n  intrinsicDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.inner;\n    });\n  }\n  /**\n   * Optionally return a pair of `AudioNode`s that should be connected to the applied inner\n   * device. The two nodes can be the same, indicating the smallest possible subgraph.\n   *\n   * @param context The `AudioContext` to use when instantiating the nodes.\n   */\n\n\n  createAudioNode(context) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = this.node) === null || _a === void 0 ? void 0 : _a.disconnect();\n      this.node = yield this.createSingleAudioNode(context);\n      return {\n        start: this.node,\n        end: this.node\n      };\n    });\n  }\n\n}\n\nexports.default = SingleNodeAudioTransformDevice;","map":{"version":3,"sources":["../../src/devicecontroller/SingleNodeAudioTransformDevice.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;AAMG;;AACH,MAA8B,8BAA9B,CAA4D;AAG1D,EAAA,WAAA,CAAsB,KAAtB,EAAmC;AAAb,SAAA,KAAA,GAAA,KAAA;AAAiB;;AAEjC,EAAA,IAAI,CAAC,MAAD,EAAgB;wDAAkB,CAAC,C;AAAA;AAE7C;;;;;AAKG;;;AACG,EAAA,IAAI,GAAA;;;;AACR,OAAA,EAAA,GAAA,KAAK,IAAL,MAAS,IAAT,IAAS,EAAA,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAS,EAAA,CAAE,UAAF,EAAT;;AACD;AAED;;;AAGG;;;AACG,EAAA,eAAe,GAAA;;AACnB,aAAO,KAAK,KAAZ;AACD,K;AAAA;AAED;;;;;AAKG;;;AACG,EAAA,eAAe,CAAC,OAAD,EAAsB;;;;AACzC,OAAA,EAAA,GAAA,KAAK,IAAL,MAAS,IAAT,IAAS,EAAA,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAS,EAAA,CAAE,UAAF,EAAT;AACA,WAAK,IAAL,GAAY,MAAM,KAAK,qBAAL,CAA2B,OAA3B,CAAlB;AACA,aAAO;AACL,QAAA,KAAK,EAAE,KAAK,IADP;AAEL,QAAA,GAAG,EAAE,KAAK;AAFL,OAAP;;AAID;;AAtCyD;;AAA5D,OAAA,CAAA,OAAA,GAAA,8BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This class simplifies the process of defining a transform device that\n * does not modify its input device constraints, and provides only a single audio node\n * to apply transforms.\n *\n * Subclass `SingleNodeAudioTransformDevice`, implementing `createSingleAudioNode`.\n */\nclass SingleNodeAudioTransformDevice {\n    constructor(inner) {\n        this.inner = inner;\n    }\n    mute(_muted) {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    /**\n     * `stop` should be called by the application to free any resources associated\n     * with the device (e.g., workers).\n     *\n     * After this is called, the device should be discarded.\n     */\n    stop() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.node) === null || _a === void 0 ? void 0 : _a.disconnect();\n        });\n    }\n    /**\n     * Return the inner {@link Device} that the device controller should select as part\n     * of the application of this `AudioTransformDevice`.\n     */\n    intrinsicDevice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.inner;\n        });\n    }\n    /**\n     * Optionally return a pair of `AudioNode`s that should be connected to the applied inner\n     * device. The two nodes can be the same, indicating the smallest possible subgraph.\n     *\n     * @param context The `AudioContext` to use when instantiating the nodes.\n     */\n    createAudioNode(context) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.node) === null || _a === void 0 ? void 0 : _a.disconnect();\n            this.node = yield this.createSingleAudioNode(context);\n            return {\n                start: this.node,\n                end: this.node,\n            };\n        });\n    }\n}\nexports.default = SingleNodeAudioTransformDevice;\n//# sourceMappingURL=SingleNodeAudioTransformDevice.js.map"]},"metadata":{},"sourceType":"script"}