{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VoiceFocusDeviceTransformer = void 0;\n\nconst voicefocus_1 = require(\"../../libs/voicefocus/voicefocus\");\n\nconst Versioning_1 = require(\"../versioning/Versioning\");\n\nconst LoggerAdapter_1 = require(\"./LoggerAdapter\");\n\nconst VoiceFocusTransformDevice_1 = require(\"./VoiceFocusTransformDevice\");\n\nconst VoiceFocusTransformDeviceDelegate_1 = require(\"./VoiceFocusTransformDeviceDelegate\");\n/**\n * `VoiceFocusDeviceTransformer` is used to create {@link VoiceFocusTransformDevice|transform devices}\n * that apply Amazon Voice Focus noise suppression to audio input.\n *\n * This transformer captures relevant configuration. You should check for support, initialize,\n * and then create a device as follows:\n *\n * ```\n * const deviceID = null;\n *\n * // This check for support is cheap and quick, and should be used to gate use\n * // of this feature.\n * if (!(await VoiceFocusDeviceTransformer.isSupported()) {\n *   console.log('Amazon Voice Focus not supported in this browser.');\n *   return deviceID;\n * }\n *\n * let transformer: VoiceFocusDeviceTransformer;\n * try {\n *   // This operation can fail in ways that do not indicate no support,\n *   // but do indicate an inability to apply Amazon Voice Focus. Trying again\n *   // might succeed.\n *   transformer = await VoiceFocusDeviceTransformer.create({});\n * } catch (e) {\n *   // Something went wrong.\n *   console.log('Unable to instantiate Amazon Voice Focus.');\n *   return deviceID;\n * }\n *\n * if (!transformer.isSupported()) {\n *   // The transformer will fall through, but your UI might care.\n *   console.log('Amazon Voice Focus not supported in this browser.');\n * }\n *\n * return await transformer.createTransformDevice(deviceID);\n * ```\n */\n\n\nclass VoiceFocusDeviceTransformer {\n  constructor(spec, {\n    preload = true,\n    logger,\n    fetchBehavior = VoiceFocusDeviceTransformer.defaultFetchBehavior()\n  }, config) {\n    this.spec = spec;\n    this.supported = true;\n    this.logger = logger;\n    this.vfLogger = logger ? new LoggerAdapter_1.default(logger) : undefined;\n    this.preload = preload;\n    this.fetchBehavior = fetchBehavior; // If the user didn't specify one, add the default, which is\n    // identified by the major and minor SDK version.\n\n    this.spec = VoiceFocusDeviceTransformer.augmentSpec(this.spec);\n\n    if (config) {\n      this.configuration = Promise.resolve(config);\n    }\n  }\n  /**\n   * Quickly check whether Amazon Voice Focus is supported on this platform.\n   *\n   * This will return `false` if key technologies are absent. A value of `true` does not\n   * necessarily mean that adding Amazon Voice Focus will succeed: it is still possible that the\n   * configuration of the page or the CPU speed of the device are limiting factors.\n   *\n   * `VoiceFocusDeviceTransformer.create` will return an instance whose `isSupported()`\n   * method more accurately reflects whether Amazon Voice Focus is supported in the current environment.\n   *\n   * This method will only reject if you provide invalid inputs.\n   *\n   * @param spec An optional asset group and URL paths to use when fetching. You can pass\n   *             a complete `VoiceFocusSpec` here for convenience, matching the signature of `create`.\n   * @param options Additional named arguments, including `logger`.\n   */\n\n\n  static isSupported(spec, options) {\n    const fetchBehavior = VoiceFocusDeviceTransformer.defaultFetchBehavior();\n    const logger = (options === null || options === void 0 ? void 0 : options.logger) ? new LoggerAdapter_1.default(options.logger) : undefined;\n    const opts = {\n      fetchBehavior,\n      logger\n    };\n    return voicefocus_1.VoiceFocus.isSupported(VoiceFocusDeviceTransformer.augmentSpec(spec), opts);\n  }\n  /**\n   * Create a transformer that can apply Amazon Voice Focus noise suppression to a device.\n   *\n   * This method will reject if the provided spec is invalid, or if the process of\n   * checking for support or estimating fails (e.g., because the network is unreachable).\n   *\n   * If Amazon Voice Focus is not supported on this device, this call will not reject and\n   * `isSupported()` will return `false` on the returned instance. That instance will\n   * pass through devices unmodified.\n   *\n   * @param spec A definition of how you want Amazon Voice Focus to behave. See the declaration of\n   *             {@link VoiceFocusSpec}` for details.\n   * @param options Additional named arguments, including `logger` and `preload`.\n   */\n\n\n  static create(spec = {}, options = {}, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const transformer = new VoiceFocusDeviceTransformer(spec, options, config); // This also preps the first `VoiceFocus` instance.\n\n      yield transformer.init();\n      return transformer;\n    });\n  }\n  /**\n   * Given a spec and options, perform the configuration work that is\n   * ordinarily performed during creation of a transformer.\n   *\n   * The computed configuration is not portable between devices or sessions,\n   * but is useful for 'moving' transformers between windows.\n   *\n   * Pass the returned configuration as the third argument to a call to\n   * {@link VoiceFocusDeviceTransformer.create} with the matching spec.\n   */\n\n\n  static configure(spec = {}, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const transformer = new VoiceFocusDeviceTransformer(spec, options, undefined);\n      return transformer.configure(true);\n    });\n  }\n  /**\n   * Return the computed configuration for this transformer.\n   */\n\n\n  getConfiguration() {\n    return this.configuration;\n  }\n  /**\n   * Return whether this transformer is able to function in this environment.\n   * If not, calls to\n   * {@link VoiceFocusDeviceTransformer.createTransformDevice|createTransformDevice}`\n   * will pass through an unmodified device.\n   */\n\n\n  isSupported() {\n    return this.supported;\n  }\n  /**\n   * Apply Amazon Voice Focus to the selected {@link Device}.\n   *\n   * If this is a stream, it should be one that does not include other noise suppression features,\n   * and you should consider whether to disable automatic gain control (AGC) on the stream, because\n   * it can interact with noise suppression.\n   *\n   * @returns a device promise. This will always resolve to either a\n   *          {@link VoiceFocusTransformDevice} or undefined; it will never reject.\n   */\n\n\n  createTransformDevice(device, nodeOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.supported) {\n        // Fall back.\n        return undefined;\n      }\n\n      try {\n        const preload = true;\n        const [vf, delegate] = yield this.allocateVoiceFocus(preload);\n        return new VoiceFocusTransformDevice_1.default(device, vf, delegate, nodeOptions);\n      } catch (e) {\n        // Fall back.\n\n        /* istanbul ignore next */\n        return undefined;\n      }\n    });\n  }\n\n  static augmentSpec(spec) {\n    if (!spec || !spec.assetGroup && !spec.revisionID) {\n      return Object.assign(Object.assign({}, spec), {\n        assetGroup: VoiceFocusDeviceTransformer.currentSDKAssetGroup()\n      });\n    }\n\n    return spec;\n  }\n\n  configure(preResolve = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const options = {\n        fetchBehavior: this.fetchBehavior,\n        preResolve,\n        logger: this.vfLogger\n      };\n      return voicefocus_1.VoiceFocus.configure(this.spec, options);\n    });\n  }\n\n  init() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.configuration) {\n        this.configuration = this.configure();\n      }\n\n      const config = yield this.configuration;\n\n      if (!config.supported) {\n        // No need to init: it won't work.\n        this.supported = false;\n        return;\n      } // We initialize the first one right now, which makes it easier to detect\n      // possible failures.\n      // This can throw for malformed input. Pass that up the chain.\n\n\n      this.pendingVoiceFocus = this.createVoiceFocus(config, this.preload);\n\n      try {\n        yield this.pendingVoiceFocus;\n      } catch (e) {\n        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`Unable to initialize Amazon Voice Focus: ${e}`);\n        this.supported = false;\n      }\n    });\n  }\n\n  createVoiceFocus(config, preload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const delegate = new VoiceFocusTransformDeviceDelegate_1.default();\n      const vf = yield voicefocus_1.VoiceFocus.init(config, {\n        delegate,\n        preload,\n        logger: this.vfLogger\n      });\n      return [vf, delegate];\n    });\n  }\n\n  allocateVoiceFocus(preload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // A little safety.\n\n      /* istanbul ignore next */\n      if (!this.supported) {\n        throw new Error('Not supported.');\n      }\n\n      if (this.pendingVoiceFocus) {\n        // Use the one we already have, and free the slot for any future execution.\n        const vf = this.pendingVoiceFocus;\n        this.pendingVoiceFocus = undefined;\n        return vf;\n      }\n\n      return this.createVoiceFocus(yield this.configuration, preload);\n    });\n  }\n\n  static majorVersion() {\n    return Versioning_1.default.sdkVersion.match(/^[1-9][0-9]*\\.(?:0|[1-9][0-9]*)/)[0];\n  }\n\n  static majorMinorVersion() {\n    return Versioning_1.default.sdkVersion.match(/^[1-9][0-9]*\\.(?:0|(?:[1-9][0-9]*))\\.(?:0|[1-9][0-9]*)/)[0];\n  }\n\n  static currentSDKAssetGroup() {\n    // Just on the off chance someone does something silly, handle\n    // malformed version strings here.\n    const v = this.majorVersion(); // Just a little safety.\n\n    /* istanbul ignore next */\n\n    if (!v) {\n      return `stable-v1`;\n    }\n\n    return `sdk-${v}`;\n  } // Note that we use query strings here, not headers, in order to make these requests 'simple' and\n  // avoid the need for CORS preflights.\n  // Be very, very careful if you choose to add headers here. You should never need to.\n\n\n  static defaultFetchBehavior() {\n    // Just a little safety.\n\n    /* istanbul ignore next */\n    const version = VoiceFocusDeviceTransformer.majorMinorVersion() || 'unknown';\n    const ua = Versioning_1.default.sdkUserAgentLowResolution;\n    return {\n      escapedQueryString: `sdk=${encodeURIComponent(version)}&ua=${encodeURIComponent(ua)}`\n    };\n  }\n\n}\n\nexports.VoiceFocusDeviceTransformer = VoiceFocusDeviceTransformer;\nexports.default = VoiceFocusDeviceTransformer;","map":{"version":3,"sources":["../../src/voicefocus/VoiceFocusDeviceTransformer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VoiceFocusDeviceTransformer = void 0;\nconst voicefocus_1 = require(\"../../libs/voicefocus/voicefocus\");\nconst Versioning_1 = require(\"../versioning/Versioning\");\nconst LoggerAdapter_1 = require(\"./LoggerAdapter\");\nconst VoiceFocusTransformDevice_1 = require(\"./VoiceFocusTransformDevice\");\nconst VoiceFocusTransformDeviceDelegate_1 = require(\"./VoiceFocusTransformDeviceDelegate\");\n/**\n * `VoiceFocusDeviceTransformer` is used to create {@link VoiceFocusTransformDevice|transform devices}\n * that apply Amazon Voice Focus noise suppression to audio input.\n *\n * This transformer captures relevant configuration. You should check for support, initialize,\n * and then create a device as follows:\n *\n * ```\n * const deviceID = null;\n *\n * // This check for support is cheap and quick, and should be used to gate use\n * // of this feature.\n * if (!(await VoiceFocusDeviceTransformer.isSupported()) {\n *   console.log('Amazon Voice Focus not supported in this browser.');\n *   return deviceID;\n * }\n *\n * let transformer: VoiceFocusDeviceTransformer;\n * try {\n *   // This operation can fail in ways that do not indicate no support,\n *   // but do indicate an inability to apply Amazon Voice Focus. Trying again\n *   // might succeed.\n *   transformer = await VoiceFocusDeviceTransformer.create({});\n * } catch (e) {\n *   // Something went wrong.\n *   console.log('Unable to instantiate Amazon Voice Focus.');\n *   return deviceID;\n * }\n *\n * if (!transformer.isSupported()) {\n *   // The transformer will fall through, but your UI might care.\n *   console.log('Amazon Voice Focus not supported in this browser.');\n * }\n *\n * return await transformer.createTransformDevice(deviceID);\n * ```\n */\nclass VoiceFocusDeviceTransformer {\n    constructor(spec, { preload = true, logger, fetchBehavior = VoiceFocusDeviceTransformer.defaultFetchBehavior(), }, config) {\n        this.spec = spec;\n        this.supported = true;\n        this.logger = logger;\n        this.vfLogger = logger ? new LoggerAdapter_1.default(logger) : undefined;\n        this.preload = preload;\n        this.fetchBehavior = fetchBehavior;\n        // If the user didn't specify one, add the default, which is\n        // identified by the major and minor SDK version.\n        this.spec = VoiceFocusDeviceTransformer.augmentSpec(this.spec);\n        if (config) {\n            this.configuration = Promise.resolve(config);\n        }\n    }\n    /**\n     * Quickly check whether Amazon Voice Focus is supported on this platform.\n     *\n     * This will return `false` if key technologies are absent. A value of `true` does not\n     * necessarily mean that adding Amazon Voice Focus will succeed: it is still possible that the\n     * configuration of the page or the CPU speed of the device are limiting factors.\n     *\n     * `VoiceFocusDeviceTransformer.create` will return an instance whose `isSupported()`\n     * method more accurately reflects whether Amazon Voice Focus is supported in the current environment.\n     *\n     * This method will only reject if you provide invalid inputs.\n     *\n     * @param spec An optional asset group and URL paths to use when fetching. You can pass\n     *             a complete `VoiceFocusSpec` here for convenience, matching the signature of `create`.\n     * @param options Additional named arguments, including `logger`.\n     */\n    static isSupported(spec, options) {\n        const fetchBehavior = VoiceFocusDeviceTransformer.defaultFetchBehavior();\n        const logger = (options === null || options === void 0 ? void 0 : options.logger) ? new LoggerAdapter_1.default(options.logger) : undefined;\n        const opts = {\n            fetchBehavior,\n            logger,\n        };\n        return voicefocus_1.VoiceFocus.isSupported(VoiceFocusDeviceTransformer.augmentSpec(spec), opts);\n    }\n    /**\n     * Create a transformer that can apply Amazon Voice Focus noise suppression to a device.\n     *\n     * This method will reject if the provided spec is invalid, or if the process of\n     * checking for support or estimating fails (e.g., because the network is unreachable).\n     *\n     * If Amazon Voice Focus is not supported on this device, this call will not reject and\n     * `isSupported()` will return `false` on the returned instance. That instance will\n     * pass through devices unmodified.\n     *\n     * @param spec A definition of how you want Amazon Voice Focus to behave. See the declaration of\n     *             {@link VoiceFocusSpec}` for details.\n     * @param options Additional named arguments, including `logger` and `preload`.\n     */\n    static create(spec = {}, options = {}, config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transformer = new VoiceFocusDeviceTransformer(spec, options, config);\n            // This also preps the first `VoiceFocus` instance.\n            yield transformer.init();\n            return transformer;\n        });\n    }\n    /**\n     * Given a spec and options, perform the configuration work that is\n     * ordinarily performed during creation of a transformer.\n     *\n     * The computed configuration is not portable between devices or sessions,\n     * but is useful for 'moving' transformers between windows.\n     *\n     * Pass the returned configuration as the third argument to a call to\n     * {@link VoiceFocusDeviceTransformer.create} with the matching spec.\n     */\n    static configure(spec = {}, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transformer = new VoiceFocusDeviceTransformer(spec, options, undefined);\n            return transformer.configure(true);\n        });\n    }\n    /**\n     * Return the computed configuration for this transformer.\n     */\n    getConfiguration() {\n        return this.configuration;\n    }\n    /**\n     * Return whether this transformer is able to function in this environment.\n     * If not, calls to\n     * {@link VoiceFocusDeviceTransformer.createTransformDevice|createTransformDevice}`\n     * will pass through an unmodified device.\n     */\n    isSupported() {\n        return this.supported;\n    }\n    /**\n     * Apply Amazon Voice Focus to the selected {@link Device}.\n     *\n     * If this is a stream, it should be one that does not include other noise suppression features,\n     * and you should consider whether to disable automatic gain control (AGC) on the stream, because\n     * it can interact with noise suppression.\n     *\n     * @returns a device promise. This will always resolve to either a\n     *          {@link VoiceFocusTransformDevice} or undefined; it will never reject.\n     */\n    createTransformDevice(device, nodeOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.supported) {\n                // Fall back.\n                return undefined;\n            }\n            try {\n                const preload = true;\n                const [vf, delegate] = yield this.allocateVoiceFocus(preload);\n                return new VoiceFocusTransformDevice_1.default(device, vf, delegate, nodeOptions);\n            }\n            catch (e) {\n                // Fall back.\n                /* istanbul ignore next */\n                return undefined;\n            }\n        });\n    }\n    static augmentSpec(spec) {\n        if (!spec || (!spec.assetGroup && !spec.revisionID)) {\n            return Object.assign(Object.assign({}, spec), { assetGroup: VoiceFocusDeviceTransformer.currentSDKAssetGroup() });\n        }\n        return spec;\n    }\n    configure(preResolve = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const options = {\n                fetchBehavior: this.fetchBehavior,\n                preResolve,\n                logger: this.vfLogger,\n            };\n            return voicefocus_1.VoiceFocus.configure(this.spec, options);\n        });\n    }\n    init() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.configuration) {\n                this.configuration = this.configure();\n            }\n            const config = yield this.configuration;\n            if (!config.supported) {\n                // No need to init: it won't work.\n                this.supported = false;\n                return;\n            }\n            // We initialize the first one right now, which makes it easier to detect\n            // possible failures.\n            // This can throw for malformed input. Pass that up the chain.\n            this.pendingVoiceFocus = this.createVoiceFocus(config, this.preload);\n            try {\n                yield this.pendingVoiceFocus;\n            }\n            catch (e) {\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`Unable to initialize Amazon Voice Focus: ${e}`);\n                this.supported = false;\n            }\n        });\n    }\n    createVoiceFocus(config, preload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const delegate = new VoiceFocusTransformDeviceDelegate_1.default();\n            const vf = yield voicefocus_1.VoiceFocus.init(config, { delegate, preload, logger: this.vfLogger });\n            return [vf, delegate];\n        });\n    }\n    allocateVoiceFocus(preload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // A little safety.\n            /* istanbul ignore next */\n            if (!this.supported) {\n                throw new Error('Not supported.');\n            }\n            if (this.pendingVoiceFocus) {\n                // Use the one we already have, and free the slot for any future execution.\n                const vf = this.pendingVoiceFocus;\n                this.pendingVoiceFocus = undefined;\n                return vf;\n            }\n            return this.createVoiceFocus(yield this.configuration, preload);\n        });\n    }\n    static majorVersion() {\n        return Versioning_1.default.sdkVersion.match(/^[1-9][0-9]*\\.(?:0|[1-9][0-9]*)/)[0];\n    }\n    static majorMinorVersion() {\n        return Versioning_1.default.sdkVersion.match(/^[1-9][0-9]*\\.(?:0|(?:[1-9][0-9]*))\\.(?:0|[1-9][0-9]*)/)[0];\n    }\n    static currentSDKAssetGroup() {\n        // Just on the off chance someone does something silly, handle\n        // malformed version strings here.\n        const v = this.majorVersion();\n        // Just a little safety.\n        /* istanbul ignore next */\n        if (!v) {\n            return `stable-v1`;\n        }\n        return `sdk-${v}`;\n    }\n    // Note that we use query strings here, not headers, in order to make these requests 'simple' and\n    // avoid the need for CORS preflights.\n    // Be very, very careful if you choose to add headers here. You should never need to.\n    static defaultFetchBehavior() {\n        // Just a little safety.\n        /* istanbul ignore next */\n        const version = VoiceFocusDeviceTransformer.majorMinorVersion() || 'unknown';\n        const ua = Versioning_1.default.sdkUserAgentLowResolution;\n        return {\n            escapedQueryString: `sdk=${encodeURIComponent(version)}&ua=${encodeURIComponent(ua)}`,\n        };\n    }\n}\nexports.VoiceFocusDeviceTransformer = VoiceFocusDeviceTransformer;\nexports.default = VoiceFocusDeviceTransformer;\n//# sourceMappingURL=VoiceFocusDeviceTransformer.js.map"]},"metadata":{},"sourceType":"script"}