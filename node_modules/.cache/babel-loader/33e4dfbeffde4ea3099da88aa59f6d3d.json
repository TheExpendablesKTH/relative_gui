{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst RealtimeState_1 = require(\"./RealtimeState\");\n\nconst RealtimeVolumeIndicator_1 = require(\"./RealtimeVolumeIndicator\");\n/**\n * [[DefaultRealtimeController]] is written to adhere to the following tenets to\n * make privacy and performance bugs significantly less likely.\n *\n * 1. Any call to the object is guaranteed to succeed from the caller's\n *    perspective to the maximum extent that this can be ensured. However, all\n *    failures of the object are reported as fatal errors. For example, if local\n *    mute fails, then that is a privacy issue and we must tear down the\n *    connection and try starting over.\n *\n * 2. State is owned by the object and is considered authoritative at all times.\n *    For example, if [[realtimeIsLocalAudioMuted]] is true then the user *is*\n *    muted.\n *\n * 3. Callbacks are fired synchronously and do their work synchronously. Any\n *    unnecessary asynchronous implementation only invites latency and\n *    increases the surface error for potential errors.\n *\n * 4. Mutation only occurs when state changes. All state-changing functions are\n *    idempotent.\n *\n * 5. Every conditional branch gets its own if statement and test coverage is\n *    100% for this object.\n *\n * 6. Function parameters and returns use primitives only (no classes or enums).\n *    This minimizes the number of dependencies that consumers have to take on\n *    and allows the object to be more easily wrapped. Values are normalized\n *    where possible.\n *\n * 7. The object takes no other non-realtime dependencies.\n *\n * 8. Interface functions begin with `realtime` to make boundaries between the\n *    RealtimeController interface and the UI or business logic explicit and\n *    auditable.\n *\n * 9. Local state overrides remote state but not vice-versa. For example, if\n *    locally muted with an active audio input and a remote state indicates the\n *    same user is unmuted because the muted state has not yet propagated, then\n *    the volume indicator update for the user would show the remote mute state\n *    as muted. However, if locally muted without an active audio input and a\n *    remote state indicates the user is unmuted (since they are dialed in), the\n *    remote state persists but does not override the local state so\n *    [[realtimeIsLocalAudioMuted]] still returns true.\n */\n\n\nclass DefaultRealtimeController {\n  constructor() {\n    this.state = new RealtimeState_1.default();\n  }\n\n  realtimeSetLocalAttendeeId(attendeeId, externalUserId) {\n    this.state.localAttendeeId = attendeeId;\n    this.state.localExternalUserId = externalUserId;\n  }\n\n  realtimeSetAttendeeIdPresence(attendeeId, present, externalUserId, dropped, posInFrame) {\n    try {\n      if (present) {\n        this.state.attendeeIdToExternalUserId[attendeeId] = externalUserId;\n      }\n\n      for (const fn of this.state.attendeeIdChangesCallbacks) {\n        fn(attendeeId, present, externalUserId, dropped, posInFrame);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeSubscribeToAttendeeIdPresence(callback) {\n    try {\n      this.state.attendeeIdChangesCallbacks.push(callback);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeToAttendeeIdPresence(callback) {\n    try {\n      const index = this.state.attendeeIdChangesCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        this.state.attendeeIdChangesCallbacks.splice(index, 1);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  } // Audio Input\n\n\n  realtimeSetLocalAudioInput(audioInput) {\n    try {\n      if (this.state.audioInput === audioInput) {\n        return;\n      }\n\n      this.setAudioInputEnabled(false);\n      this.state.audioInput = audioInput;\n      this.setAudioInputEnabled(!this.state.muted);\n    } catch (e) {\n      this.onError(e);\n    }\n  } // Muting\n\n\n  realtimeSetCanUnmuteLocalAudio(canUnmute) {\n    try {\n      if (this.state.canUnmute === canUnmute) {\n        return;\n      }\n\n      this.state.canUnmute = canUnmute;\n\n      for (const fn of this.state.setCanUnmuteLocalAudioCallbacks) {\n        fn(canUnmute);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeSubscribeToSetCanUnmuteLocalAudio(callback) {\n    try {\n      this.state.setCanUnmuteLocalAudioCallbacks.push(callback);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeToSetCanUnmuteLocalAudio(callback) {\n    try {\n      const index = this.state.setCanUnmuteLocalAudioCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        this.state.setCanUnmuteLocalAudioCallbacks.splice(index, 1);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeCanUnmuteLocalAudio() {\n    return this.state.canUnmute;\n  }\n\n  realtimeMuteLocalAudio() {\n    if (this.state.muted) {\n      return;\n    }\n\n    try {\n      this.setAudioInputEnabled(false);\n      this.state.muted = true;\n      this.realtimeUpdateVolumeIndicator(this.state.localAttendeeId, null, null, null, this.state.localExternalUserId);\n\n      for (const fn of this.state.muteAndUnmuteLocalAudioCallbacks) {\n        fn(true);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnmuteLocalAudio() {\n    if (!this.state.muted) {\n      return true;\n    }\n\n    if (!this.state.canUnmute) {\n      return false;\n    }\n\n    try {\n      this.setAudioInputEnabled(true);\n      this.state.muted = false;\n      this.realtimeUpdateVolumeIndicator(this.state.localAttendeeId, null, null, null, this.state.localExternalUserId);\n\n      for (const fn of this.state.muteAndUnmuteLocalAudioCallbacks) {\n        fn(false);\n      }\n\n      return true;\n    } catch (e) {\n      this.onError(e);\n      return false;\n    }\n  }\n\n  realtimeSubscribeToMuteAndUnmuteLocalAudio(callback) {\n    try {\n      this.state.muteAndUnmuteLocalAudioCallbacks.push(callback);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeToMuteAndUnmuteLocalAudio(callback) {\n    try {\n      const index = this.state.muteAndUnmuteLocalAudioCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        this.state.muteAndUnmuteLocalAudioCallbacks.splice(index, 1);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeIsLocalAudioMuted() {\n    return this.state.muted;\n  } // Volume Indicators\n\n\n  realtimeSubscribeToVolumeIndicator(attendeeId, callback) {\n    try {\n      if (!this.state.volumeIndicatorCallbacks.hasOwnProperty(attendeeId)) {\n        this.state.volumeIndicatorCallbacks[attendeeId] = [];\n      }\n\n      this.state.volumeIndicatorCallbacks[attendeeId].push(callback);\n      this.sendVolumeIndicatorChange(attendeeId, true, true, true, this.state.attendeeIdToExternalUserId[attendeeId]);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeFromVolumeIndicator(attendeeId, callback) {\n    try {\n      if (callback) {\n        const index = this.state.volumeIndicatorCallbacks[attendeeId].indexOf(callback);\n\n        if (index !== -1) {\n          this.state.volumeIndicatorCallbacks[attendeeId].splice(index, 1);\n        }\n      } else {\n        delete this.state.volumeIndicatorCallbacks[attendeeId];\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUpdateVolumeIndicator(attendeeId, volume, muted, signalStrength, externalUserId) {\n    try {\n      muted = this.applyLocalMuteOverride(attendeeId, muted);\n      const state = this.getVolumeIndicatorState(attendeeId);\n      let volumeUpdated = false;\n      let mutedUpdated = false;\n      let signalStrengthUpdated = false;\n\n      if (muted !== null) {\n        if (state.muted !== muted) {\n          state.muted = muted;\n          mutedUpdated = true;\n\n          if (state.muted && state.volume !== 0.0) {\n            state.volume = 0.0;\n            volumeUpdated = true;\n          }\n        }\n      }\n\n      if (!state.muted && volume !== null) {\n        if (state.volume !== volume) {\n          state.volume = volume;\n          volumeUpdated = true;\n        }\n\n        if (state.muted === null) {\n          state.muted = false;\n          mutedUpdated = true;\n        }\n      }\n\n      if (signalStrength !== null) {\n        if (state.signalStrength !== signalStrength) {\n          state.signalStrength = signalStrength;\n          signalStrengthUpdated = true;\n        }\n      }\n\n      this.sendVolumeIndicatorChange(attendeeId, volumeUpdated, mutedUpdated, signalStrengthUpdated, externalUserId);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeSubscribeToLocalSignalStrengthChange(callback) {\n    try {\n      this.state.localSignalStrengthChangeCallbacks.push(callback);\n\n      if (this.state.localAttendeeId === null) {\n        return;\n      }\n\n      this.sendLocalSignalStrengthChange(this.state.localAttendeeId, true);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeToLocalSignalStrengthChange(callback) {\n    try {\n      const index = this.state.localSignalStrengthChangeCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        this.state.localSignalStrengthChangeCallbacks.splice(index, 1);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeSubscribeToSendDataMessage( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      this.state.sendDataMessageCallbacks.push(callback);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeFromSendDataMessage( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const index = this.state.sendDataMessageCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        this.state.sendDataMessageCallbacks.splice(index, 1);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeSendDataMessage(topic, data, // eslint-disable-line @typescript-eslint/no-explicit-any\n  lifetimeMs) {\n    try {\n      for (const fn of this.state.sendDataMessageCallbacks) {\n        fn(topic, data, lifetimeMs);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeSubscribeToReceiveDataMessage(topic, callback) {\n    try {\n      if (this.state.receiveDataMessageCallbacks.has(topic)) {\n        this.state.receiveDataMessageCallbacks.get(topic).push(callback);\n      } else {\n        this.state.receiveDataMessageCallbacks.set(topic, [callback]);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeFromReceiveDataMessage(topic) {\n    try {\n      this.state.receiveDataMessageCallbacks.delete(topic);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeReceiveDataMessage(dataMessage) {\n    try {\n      if (this.state.receiveDataMessageCallbacks.has(dataMessage.topic)) {\n        for (const fn of this.state.receiveDataMessageCallbacks.get(dataMessage.topic)) {\n          fn(dataMessage);\n        }\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  } // Error Handling\n\n\n  realtimeSubscribeToFatalError(callback) {\n    try {\n      this.state.fatalErrorCallbacks.push(callback);\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n\n  realtimeUnsubscribeToFatalError(callback) {\n    try {\n      const index = this.state.fatalErrorCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        this.state.fatalErrorCallbacks.splice(index, 1);\n      }\n    } catch (e) {\n      this.onError(e);\n    }\n  } // Internals\n\n\n  setAudioInputEnabled(enabled) {\n    if (!this.state.audioInput) {\n      return;\n    }\n\n    for (const track of this.state.audioInput.getTracks()) {\n      if (track.enabled === enabled) {\n        continue;\n      }\n\n      track.enabled = enabled;\n    }\n  }\n\n  applyLocalMuteOverride(attendeeIdRemote, mutedRemote) {\n    const attendeeIdLocal = this.state.localAttendeeId;\n    const mutedLocal = this.state.muted;\n\n    if (attendeeIdRemote !== attendeeIdLocal) {\n      return mutedRemote;\n    }\n\n    if (this.state.audioInput === null) {\n      return mutedRemote;\n    }\n\n    return mutedLocal;\n  }\n\n  sendVolumeIndicatorChange(attendeeId, volumeUpdated, mutedUpdated, signalStrengthUpdated, externalUserId) {\n    this.sendLocalSignalStrengthChange(attendeeId, signalStrengthUpdated);\n\n    if (!this.state.volumeIndicatorCallbacks.hasOwnProperty(attendeeId)) {\n      return;\n    }\n\n    const state = this.getVolumeIndicatorState(attendeeId);\n    const updateState = new RealtimeVolumeIndicator_1.default();\n\n    if (volumeUpdated) {\n      updateState.volume = state.volume;\n    }\n\n    if (mutedUpdated) {\n      updateState.muted = state.muted;\n    }\n\n    if (signalStrengthUpdated) {\n      updateState.signalStrength = state.signalStrength;\n    }\n\n    if (this.stateIsEmpty(updateState)) {\n      return;\n    }\n\n    for (const fn of this.state.volumeIndicatorCallbacks[attendeeId]) {\n      fn(attendeeId, updateState.volume, updateState.muted, updateState.signalStrength, externalUserId);\n    }\n  }\n\n  sendLocalSignalStrengthChange(attendeeId, signalStrengthUpdated) {\n    if (!signalStrengthUpdated) {\n      return;\n    }\n\n    if (attendeeId !== this.state.localAttendeeId) {\n      return;\n    }\n\n    const state = this.getVolumeIndicatorState(attendeeId);\n    const signalStrength = state.signalStrength;\n\n    if (signalStrength === null) {\n      return;\n    }\n\n    for (const fn of this.state.localSignalStrengthChangeCallbacks) {\n      fn(signalStrength);\n    }\n  }\n\n  getVolumeIndicatorState(id) {\n    if (!this.state.volumeIndicatorState.hasOwnProperty(id)) {\n      this.state.volumeIndicatorState[id] = new RealtimeVolumeIndicator_1.default();\n    }\n\n    return this.state.volumeIndicatorState[id];\n  }\n\n  stateIsEmpty(state) {\n    return state.volume === null && state.muted === null && state.signalStrength === null;\n  }\n\n  onError(error) {\n    try {\n      // 1) try the fatal error callbacks so that the issue is reported in\n      //    logs and to give the handler a chance to clean up and reset.\n      for (const callback of this.state.fatalErrorCallbacks) {\n        callback(error);\n      }\n    } catch (eventError) {\n      try {\n        // 2) if the error event fails, fall back to console.error so that\n        //    it at least prints out to the console before moving on.\n        console.error(error);\n        console.error(eventError);\n      } catch (consoleError) {// 3) if all else fails, swallow the error and give up to guarantee\n        //    that the API call returns cleanly.\n      }\n    }\n  }\n\n}\n\nexports.default = DefaultRealtimeController;","map":{"version":3,"sources":["../../src/realtimecontroller/DefaultRealtimeController.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst RealtimeState_1 = require(\"./RealtimeState\");\nconst RealtimeVolumeIndicator_1 = require(\"./RealtimeVolumeIndicator\");\n/**\n * [[DefaultRealtimeController]] is written to adhere to the following tenets to\n * make privacy and performance bugs significantly less likely.\n *\n * 1. Any call to the object is guaranteed to succeed from the caller's\n *    perspective to the maximum extent that this can be ensured. However, all\n *    failures of the object are reported as fatal errors. For example, if local\n *    mute fails, then that is a privacy issue and we must tear down the\n *    connection and try starting over.\n *\n * 2. State is owned by the object and is considered authoritative at all times.\n *    For example, if [[realtimeIsLocalAudioMuted]] is true then the user *is*\n *    muted.\n *\n * 3. Callbacks are fired synchronously and do their work synchronously. Any\n *    unnecessary asynchronous implementation only invites latency and\n *    increases the surface error for potential errors.\n *\n * 4. Mutation only occurs when state changes. All state-changing functions are\n *    idempotent.\n *\n * 5. Every conditional branch gets its own if statement and test coverage is\n *    100% for this object.\n *\n * 6. Function parameters and returns use primitives only (no classes or enums).\n *    This minimizes the number of dependencies that consumers have to take on\n *    and allows the object to be more easily wrapped. Values are normalized\n *    where possible.\n *\n * 7. The object takes no other non-realtime dependencies.\n *\n * 8. Interface functions begin with `realtime` to make boundaries between the\n *    RealtimeController interface and the UI or business logic explicit and\n *    auditable.\n *\n * 9. Local state overrides remote state but not vice-versa. For example, if\n *    locally muted with an active audio input and a remote state indicates the\n *    same user is unmuted because the muted state has not yet propagated, then\n *    the volume indicator update for the user would show the remote mute state\n *    as muted. However, if locally muted without an active audio input and a\n *    remote state indicates the user is unmuted (since they are dialed in), the\n *    remote state persists but does not override the local state so\n *    [[realtimeIsLocalAudioMuted]] still returns true.\n */\nclass DefaultRealtimeController {\n    constructor() {\n        this.state = new RealtimeState_1.default();\n    }\n    realtimeSetLocalAttendeeId(attendeeId, externalUserId) {\n        this.state.localAttendeeId = attendeeId;\n        this.state.localExternalUserId = externalUserId;\n    }\n    realtimeSetAttendeeIdPresence(attendeeId, present, externalUserId, dropped, posInFrame) {\n        try {\n            if (present) {\n                this.state.attendeeIdToExternalUserId[attendeeId] = externalUserId;\n            }\n            for (const fn of this.state.attendeeIdChangesCallbacks) {\n                fn(attendeeId, present, externalUserId, dropped, posInFrame);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeSubscribeToAttendeeIdPresence(callback) {\n        try {\n            this.state.attendeeIdChangesCallbacks.push(callback);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeToAttendeeIdPresence(callback) {\n        try {\n            const index = this.state.attendeeIdChangesCallbacks.indexOf(callback);\n            if (index !== -1) {\n                this.state.attendeeIdChangesCallbacks.splice(index, 1);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    // Audio Input\n    realtimeSetLocalAudioInput(audioInput) {\n        try {\n            if (this.state.audioInput === audioInput) {\n                return;\n            }\n            this.setAudioInputEnabled(false);\n            this.state.audioInput = audioInput;\n            this.setAudioInputEnabled(!this.state.muted);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    // Muting\n    realtimeSetCanUnmuteLocalAudio(canUnmute) {\n        try {\n            if (this.state.canUnmute === canUnmute) {\n                return;\n            }\n            this.state.canUnmute = canUnmute;\n            for (const fn of this.state.setCanUnmuteLocalAudioCallbacks) {\n                fn(canUnmute);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeSubscribeToSetCanUnmuteLocalAudio(callback) {\n        try {\n            this.state.setCanUnmuteLocalAudioCallbacks.push(callback);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeToSetCanUnmuteLocalAudio(callback) {\n        try {\n            const index = this.state.setCanUnmuteLocalAudioCallbacks.indexOf(callback);\n            if (index !== -1) {\n                this.state.setCanUnmuteLocalAudioCallbacks.splice(index, 1);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeCanUnmuteLocalAudio() {\n        return this.state.canUnmute;\n    }\n    realtimeMuteLocalAudio() {\n        if (this.state.muted) {\n            return;\n        }\n        try {\n            this.setAudioInputEnabled(false);\n            this.state.muted = true;\n            this.realtimeUpdateVolumeIndicator(this.state.localAttendeeId, null, null, null, this.state.localExternalUserId);\n            for (const fn of this.state.muteAndUnmuteLocalAudioCallbacks) {\n                fn(true);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnmuteLocalAudio() {\n        if (!this.state.muted) {\n            return true;\n        }\n        if (!this.state.canUnmute) {\n            return false;\n        }\n        try {\n            this.setAudioInputEnabled(true);\n            this.state.muted = false;\n            this.realtimeUpdateVolumeIndicator(this.state.localAttendeeId, null, null, null, this.state.localExternalUserId);\n            for (const fn of this.state.muteAndUnmuteLocalAudioCallbacks) {\n                fn(false);\n            }\n            return true;\n        }\n        catch (e) {\n            this.onError(e);\n            return false;\n        }\n    }\n    realtimeSubscribeToMuteAndUnmuteLocalAudio(callback) {\n        try {\n            this.state.muteAndUnmuteLocalAudioCallbacks.push(callback);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeToMuteAndUnmuteLocalAudio(callback) {\n        try {\n            const index = this.state.muteAndUnmuteLocalAudioCallbacks.indexOf(callback);\n            if (index !== -1) {\n                this.state.muteAndUnmuteLocalAudioCallbacks.splice(index, 1);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeIsLocalAudioMuted() {\n        return this.state.muted;\n    }\n    // Volume Indicators\n    realtimeSubscribeToVolumeIndicator(attendeeId, callback) {\n        try {\n            if (!this.state.volumeIndicatorCallbacks.hasOwnProperty(attendeeId)) {\n                this.state.volumeIndicatorCallbacks[attendeeId] = [];\n            }\n            this.state.volumeIndicatorCallbacks[attendeeId].push(callback);\n            this.sendVolumeIndicatorChange(attendeeId, true, true, true, this.state.attendeeIdToExternalUserId[attendeeId]);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeFromVolumeIndicator(attendeeId, callback) {\n        try {\n            if (callback) {\n                const index = this.state.volumeIndicatorCallbacks[attendeeId].indexOf(callback);\n                if (index !== -1) {\n                    this.state.volumeIndicatorCallbacks[attendeeId].splice(index, 1);\n                }\n            }\n            else {\n                delete this.state.volumeIndicatorCallbacks[attendeeId];\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUpdateVolumeIndicator(attendeeId, volume, muted, signalStrength, externalUserId) {\n        try {\n            muted = this.applyLocalMuteOverride(attendeeId, muted);\n            const state = this.getVolumeIndicatorState(attendeeId);\n            let volumeUpdated = false;\n            let mutedUpdated = false;\n            let signalStrengthUpdated = false;\n            if (muted !== null) {\n                if (state.muted !== muted) {\n                    state.muted = muted;\n                    mutedUpdated = true;\n                    if (state.muted && state.volume !== 0.0) {\n                        state.volume = 0.0;\n                        volumeUpdated = true;\n                    }\n                }\n            }\n            if (!state.muted && volume !== null) {\n                if (state.volume !== volume) {\n                    state.volume = volume;\n                    volumeUpdated = true;\n                }\n                if (state.muted === null) {\n                    state.muted = false;\n                    mutedUpdated = true;\n                }\n            }\n            if (signalStrength !== null) {\n                if (state.signalStrength !== signalStrength) {\n                    state.signalStrength = signalStrength;\n                    signalStrengthUpdated = true;\n                }\n            }\n            this.sendVolumeIndicatorChange(attendeeId, volumeUpdated, mutedUpdated, signalStrengthUpdated, externalUserId);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeSubscribeToLocalSignalStrengthChange(callback) {\n        try {\n            this.state.localSignalStrengthChangeCallbacks.push(callback);\n            if (this.state.localAttendeeId === null) {\n                return;\n            }\n            this.sendLocalSignalStrengthChange(this.state.localAttendeeId, true);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeToLocalSignalStrengthChange(callback) {\n        try {\n            const index = this.state.localSignalStrengthChangeCallbacks.indexOf(callback);\n            if (index !== -1) {\n                this.state.localSignalStrengthChangeCallbacks.splice(index, 1);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeSubscribeToSendDataMessage(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            this.state.sendDataMessageCallbacks.push(callback);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeFromSendDataMessage(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const index = this.state.sendDataMessageCallbacks.indexOf(callback);\n            if (index !== -1) {\n                this.state.sendDataMessageCallbacks.splice(index, 1);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeSendDataMessage(topic, data, // eslint-disable-line @typescript-eslint/no-explicit-any\n    lifetimeMs) {\n        try {\n            for (const fn of this.state.sendDataMessageCallbacks) {\n                fn(topic, data, lifetimeMs);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeSubscribeToReceiveDataMessage(topic, callback) {\n        try {\n            if (this.state.receiveDataMessageCallbacks.has(topic)) {\n                this.state.receiveDataMessageCallbacks.get(topic).push(callback);\n            }\n            else {\n                this.state.receiveDataMessageCallbacks.set(topic, [callback]);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeFromReceiveDataMessage(topic) {\n        try {\n            this.state.receiveDataMessageCallbacks.delete(topic);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeReceiveDataMessage(dataMessage) {\n        try {\n            if (this.state.receiveDataMessageCallbacks.has(dataMessage.topic)) {\n                for (const fn of this.state.receiveDataMessageCallbacks.get(dataMessage.topic)) {\n                    fn(dataMessage);\n                }\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    // Error Handling\n    realtimeSubscribeToFatalError(callback) {\n        try {\n            this.state.fatalErrorCallbacks.push(callback);\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    realtimeUnsubscribeToFatalError(callback) {\n        try {\n            const index = this.state.fatalErrorCallbacks.indexOf(callback);\n            if (index !== -1) {\n                this.state.fatalErrorCallbacks.splice(index, 1);\n            }\n        }\n        catch (e) {\n            this.onError(e);\n        }\n    }\n    // Internals\n    setAudioInputEnabled(enabled) {\n        if (!this.state.audioInput) {\n            return;\n        }\n        for (const track of this.state.audioInput.getTracks()) {\n            if (track.enabled === enabled) {\n                continue;\n            }\n            track.enabled = enabled;\n        }\n    }\n    applyLocalMuteOverride(attendeeIdRemote, mutedRemote) {\n        const attendeeIdLocal = this.state.localAttendeeId;\n        const mutedLocal = this.state.muted;\n        if (attendeeIdRemote !== attendeeIdLocal) {\n            return mutedRemote;\n        }\n        if (this.state.audioInput === null) {\n            return mutedRemote;\n        }\n        return mutedLocal;\n    }\n    sendVolumeIndicatorChange(attendeeId, volumeUpdated, mutedUpdated, signalStrengthUpdated, externalUserId) {\n        this.sendLocalSignalStrengthChange(attendeeId, signalStrengthUpdated);\n        if (!this.state.volumeIndicatorCallbacks.hasOwnProperty(attendeeId)) {\n            return;\n        }\n        const state = this.getVolumeIndicatorState(attendeeId);\n        const updateState = new RealtimeVolumeIndicator_1.default();\n        if (volumeUpdated) {\n            updateState.volume = state.volume;\n        }\n        if (mutedUpdated) {\n            updateState.muted = state.muted;\n        }\n        if (signalStrengthUpdated) {\n            updateState.signalStrength = state.signalStrength;\n        }\n        if (this.stateIsEmpty(updateState)) {\n            return;\n        }\n        for (const fn of this.state.volumeIndicatorCallbacks[attendeeId]) {\n            fn(attendeeId, updateState.volume, updateState.muted, updateState.signalStrength, externalUserId);\n        }\n    }\n    sendLocalSignalStrengthChange(attendeeId, signalStrengthUpdated) {\n        if (!signalStrengthUpdated) {\n            return;\n        }\n        if (attendeeId !== this.state.localAttendeeId) {\n            return;\n        }\n        const state = this.getVolumeIndicatorState(attendeeId);\n        const signalStrength = state.signalStrength;\n        if (signalStrength === null) {\n            return;\n        }\n        for (const fn of this.state.localSignalStrengthChangeCallbacks) {\n            fn(signalStrength);\n        }\n    }\n    getVolumeIndicatorState(id) {\n        if (!this.state.volumeIndicatorState.hasOwnProperty(id)) {\n            this.state.volumeIndicatorState[id] = new RealtimeVolumeIndicator_1.default();\n        }\n        return this.state.volumeIndicatorState[id];\n    }\n    stateIsEmpty(state) {\n        return state.volume === null && state.muted === null && state.signalStrength === null;\n    }\n    onError(error) {\n        try {\n            // 1) try the fatal error callbacks so that the issue is reported in\n            //    logs and to give the handler a chance to clean up and reset.\n            for (const callback of this.state.fatalErrorCallbacks) {\n                callback(error);\n            }\n        }\n        catch (eventError) {\n            try {\n                // 2) if the error event fails, fall back to console.error so that\n                //    it at least prints out to the console before moving on.\n                console.error(error);\n                console.error(eventError);\n            }\n            catch (consoleError) {\n                // 3) if all else fails, swallow the error and give up to guarantee\n                //    that the API call returns cleanly.\n            }\n        }\n    }\n}\nexports.default = DefaultRealtimeController;\n//# sourceMappingURL=DefaultRealtimeController.js.map"]},"metadata":{},"sourceType":"script"}