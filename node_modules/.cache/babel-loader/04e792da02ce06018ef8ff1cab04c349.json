{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst SignalingClientSubscribe_1 = require(\"../signalingclient/SignalingClientSubscribe\");\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/**\n * [[SubscribeAndReceiveSubscribeAckTask]] sends a subscribe frame with the given settings\n * and receives SdkSubscribeAckFrame.\n */\n\n\nclass SubscribeAndReceiveSubscribeAckTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'SubscribeAndReceiveSubscribeAckTask';\n    this.taskCanceler = null;\n  }\n\n  cancel() {\n    if (this.taskCanceler) {\n      this.taskCanceler.cancel();\n      this.taskCanceler = null;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let localSdp = '';\n\n      if (this.context.peer && this.context.peer.localDescription) {\n        if (this.context.browserBehavior.requiresUnifiedPlanMunging()) {\n          localSdp = new DefaultSDP_1.default(this.context.peer.localDescription.sdp).withUnifiedPlanFormat().sdp;\n        } else {\n          localSdp = this.context.peer.localDescription.sdp;\n        }\n      }\n\n      if (!this.context.enableSimulcast) {\n        // backward compatibility\n        let frameRate = 0;\n        let maxEncodeBitrateKbps = 0;\n\n        if (this.context.videoCaptureAndEncodeParameter) {\n          frameRate = this.context.videoCaptureAndEncodeParameter.captureFrameRate();\n          maxEncodeBitrateKbps = this.context.videoCaptureAndEncodeParameter.encodeBitrates()[0];\n        }\n\n        const param = {\n          rid: 'hi',\n          maxBitrate: maxEncodeBitrateKbps * 1000,\n          maxFramerate: frameRate,\n          active: true\n        };\n        this.context.videoStreamIndex.integrateUplinkPolicyDecision([param]);\n      }\n\n      this.context.videoStreamIndex.subscribeFrameSent();\n      const isSendingStreams = this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.TX || this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.DUPLEX;\n      this.context.previousSdpOffer = new DefaultSDP_1.default(localSdp);\n      const subscribe = new SignalingClientSubscribe_1.default(this.context.meetingSessionConfiguration.credentials.attendeeId, localSdp, this.context.meetingSessionConfiguration.urls.audioHostURL, this.context.realtimeController.realtimeIsLocalAudioMuted(), false, this.context.videoSubscriptions, isSendingStreams, this.context.videoStreamIndex.localStreamDescriptions(), // TODO: handle check-in mode, or remove this param\n      true);\n      this.context.logger.info(`sending subscribe: ${JSON.stringify(subscribe)}`);\n      this.context.signalingClient.subscribe(subscribe);\n      const subscribeAckFrame = yield this.receiveSubscribeAck();\n      this.context.logger.info(`got subscribe ack: ${JSON.stringify(subscribeAckFrame)}`);\n      this.context.sdpAnswer = subscribeAckFrame.sdpAnswer;\n      this.context.videoStreamIndex.integrateSubscribeAckFrame(subscribeAckFrame);\n    });\n  }\n\n  receiveSubscribeAck() {\n    return new Promise((resolve, reject) => {\n      class Interceptor {\n        constructor(signalingClient) {\n          this.signalingClient = signalingClient;\n        }\n\n        cancel() {\n          this.signalingClient.removeObserver(this);\n          reject(new Error(`SubscribeAndReceiveSubscribeAckTask got canceled while waiting for SdkSubscribeAckFrame`));\n        }\n\n        handleSignalingClientEvent(event) {\n          if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame || event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.SUBSCRIBE_ACK) {\n            return;\n          }\n\n          this.signalingClient.removeObserver(this); // @ts-ignore: force cast to SdkSubscribeAckFrame\n\n          const subackFrame = event.message.suback;\n          resolve(subackFrame);\n        }\n\n      }\n\n      const interceptor = new Interceptor(this.context.signalingClient);\n      this.context.signalingClient.registerObserver(interceptor);\n      this.taskCanceler = interceptor;\n    });\n  }\n\n}\n\nexports.default = SubscribeAndReceiveSubscribeAckTask;","map":{"version":3,"sources":["../../src/task/SubscribeAndReceiveSubscribeAckTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\nconst SignalingClientSubscribe_1 = require(\"../signalingclient/SignalingClientSubscribe\");\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\nconst BaseTask_1 = require(\"./BaseTask\");\n/**\n * [[SubscribeAndReceiveSubscribeAckTask]] sends a subscribe frame with the given settings\n * and receives SdkSubscribeAckFrame.\n */\nclass SubscribeAndReceiveSubscribeAckTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'SubscribeAndReceiveSubscribeAckTask';\n        this.taskCanceler = null;\n    }\n    cancel() {\n        if (this.taskCanceler) {\n            this.taskCanceler.cancel();\n            this.taskCanceler = null;\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let localSdp = '';\n            if (this.context.peer && this.context.peer.localDescription) {\n                if (this.context.browserBehavior.requiresUnifiedPlanMunging()) {\n                    localSdp = new DefaultSDP_1.default(this.context.peer.localDescription.sdp).withUnifiedPlanFormat()\n                        .sdp;\n                }\n                else {\n                    localSdp = this.context.peer.localDescription.sdp;\n                }\n            }\n            if (!this.context.enableSimulcast) {\n                // backward compatibility\n                let frameRate = 0;\n                let maxEncodeBitrateKbps = 0;\n                if (this.context.videoCaptureAndEncodeParameter) {\n                    frameRate = this.context.videoCaptureAndEncodeParameter.captureFrameRate();\n                    maxEncodeBitrateKbps = this.context.videoCaptureAndEncodeParameter.encodeBitrates()[0];\n                }\n                const param = {\n                    rid: 'hi',\n                    maxBitrate: maxEncodeBitrateKbps * 1000,\n                    maxFramerate: frameRate,\n                    active: true,\n                };\n                this.context.videoStreamIndex.integrateUplinkPolicyDecision([param]);\n            }\n            this.context.videoStreamIndex.subscribeFrameSent();\n            const isSendingStreams = this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.TX ||\n                this.context.videoDuplexMode === SignalingProtocol_js_1.SdkStreamServiceType.DUPLEX;\n            this.context.previousSdpOffer = new DefaultSDP_1.default(localSdp);\n            const subscribe = new SignalingClientSubscribe_1.default(this.context.meetingSessionConfiguration.credentials.attendeeId, localSdp, this.context.meetingSessionConfiguration.urls.audioHostURL, this.context.realtimeController.realtimeIsLocalAudioMuted(), false, this.context.videoSubscriptions, isSendingStreams, this.context.videoStreamIndex.localStreamDescriptions(), \n            // TODO: handle check-in mode, or remove this param\n            true);\n            this.context.logger.info(`sending subscribe: ${JSON.stringify(subscribe)}`);\n            this.context.signalingClient.subscribe(subscribe);\n            const subscribeAckFrame = yield this.receiveSubscribeAck();\n            this.context.logger.info(`got subscribe ack: ${JSON.stringify(subscribeAckFrame)}`);\n            this.context.sdpAnswer = subscribeAckFrame.sdpAnswer;\n            this.context.videoStreamIndex.integrateSubscribeAckFrame(subscribeAckFrame);\n        });\n    }\n    receiveSubscribeAck() {\n        return new Promise((resolve, reject) => {\n            class Interceptor {\n                constructor(signalingClient) {\n                    this.signalingClient = signalingClient;\n                }\n                cancel() {\n                    this.signalingClient.removeObserver(this);\n                    reject(new Error(`SubscribeAndReceiveSubscribeAckTask got canceled while waiting for SdkSubscribeAckFrame`));\n                }\n                handleSignalingClientEvent(event) {\n                    if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame ||\n                        event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.SUBSCRIBE_ACK) {\n                        return;\n                    }\n                    this.signalingClient.removeObserver(this);\n                    // @ts-ignore: force cast to SdkSubscribeAckFrame\n                    const subackFrame = event.message.suback;\n                    resolve(subackFrame);\n                }\n            }\n            const interceptor = new Interceptor(this.context.signalingClient);\n            this.context.signalingClient.registerObserver(interceptor);\n            this.taskCanceler = interceptor;\n        });\n    }\n}\nexports.default = SubscribeAndReceiveSubscribeAckTask;\n//# sourceMappingURL=SubscribeAndReceiveSubscribeAckTask.js.map"]},"metadata":{},"sourceType":"script"}