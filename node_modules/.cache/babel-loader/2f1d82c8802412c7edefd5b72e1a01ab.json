{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/**\n * [[ParallelGroupTask]] runs a set of tasks in parallel. When canceled, it\n * stops any currently running tasks.\n */\n\n\nclass ParallelGroupTask extends BaseTask_1.default {\n  constructor(logger, taskName, tasksToRunParallel) {\n    super(logger);\n    this.taskName = taskName;\n    this.tasksToRunParallel = tasksToRunParallel;\n\n    for (const task of tasksToRunParallel) {\n      task.setParent(this);\n    }\n  }\n\n  cancel() {\n    for (const task of this.tasksToRunParallel) {\n      this.logger.info(`canceling parallel group task ${this.name()} subtask ${task.name()}`);\n      task.cancel();\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskResults = [];\n\n      for (const task of this.tasksToRunParallel) {\n        this.logger.info(`parallel group task ${this.name()} running subtask ${task.name()}`);\n        taskResults.push(task.run());\n      }\n\n      const failures = [];\n\n      for (let i = 0; i < taskResults.length; i++) {\n        try {\n          yield taskResults[i];\n        } catch (err) {\n          failures.push(`task ${this.tasksToRunParallel[i].name()} failed: ${err.message}`);\n        }\n\n        this.logger.info(`parallel group task ${this.name()} completed subtask ${this.tasksToRunParallel[i].name()}`);\n      }\n\n      if (failures.length > 0) {\n        const failureMessage = failures.join(', ');\n        this.logAndThrow(`parallel group task ${this.name()} failed for tasks: ${failureMessage}`);\n      }\n\n      this.logger.info(`parallel group task ${this.name()} completed`);\n    });\n  }\n\n}\n\nexports.default = ParallelGroupTask;","map":{"version":3,"sources":["../../src/task/ParallelGroupTask.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAGA;;;AAGG;;;AACH,MAAqB,iBAArB,SAA+C,UAAA,CAAA,OAA/C,CAAuD;AACrD,EAAA,WAAA,CAAY,MAAZ,EAAsC,QAAtC,EAAgE,kBAAhE,EAA0F;AACxF,UAAM,MAAN;AADoC,SAAA,QAAA,GAAA,QAAA;AAA0B,SAAA,kBAAA,GAAA,kBAAA;;AAE9D,SAAK,MAAM,IAAX,IAAmB,kBAAnB,EAAuC;AACrC,MAAA,IAAI,CAAC,SAAL,CAAe,IAAf;AACD;AACF;;AAED,EAAA,MAAM,GAAA;AACJ,SAAK,MAAM,IAAX,IAAmB,KAAK,kBAAxB,EAA4C;AAC1C,WAAK,MAAL,CAAY,IAAZ,CAAiB,iCAAiC,KAAK,IAAL,EAAW,YAAY,IAAI,CAAC,IAAL,EAAW,EAApF;AACA,MAAA,IAAI,CAAC,MAAL;AACD;AACF;;AAEK,EAAA,GAAG,GAAA;;AACP,YAAM,WAAW,GAAoB,EAArC;;AACA,WAAK,MAAM,IAAX,IAAmB,KAAK,kBAAxB,EAA4C;AAC1C,aAAK,MAAL,CAAY,IAAZ,CAAiB,uBAAuB,KAAK,IAAL,EAAW,oBAAoB,IAAI,CAAC,IAAL,EAAW,EAAlF;AACA,QAAA,WAAW,CAAC,IAAZ,CAAiB,IAAI,CAAC,GAAL,EAAjB;AACD;;AACD,YAAM,QAAQ,GAAa,EAA3B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,YAAI;AACF,gBAAM,WAAW,CAAC,CAAD,CAAjB;AACD,SAFD,CAEE,OAAO,GAAP,EAAY;AACZ,UAAA,QAAQ,CAAC,IAAT,CAAc,QAAQ,KAAK,kBAAL,CAAwB,CAAxB,EAA2B,IAA3B,EAAiC,YAAY,GAAG,CAAC,OAAO,EAA9E;AACD;;AACD,aAAK,MAAL,CAAY,IAAZ,CACE,uBAAuB,KAAK,IAAL,EAAW,sBAAsB,KAAK,kBAAL,CAAwB,CAAxB,EAA2B,IAA3B,EAAiC,EAD3F;AAGD;;AACD,UAAI,QAAQ,CAAC,MAAT,GAAkB,CAAtB,EAAyB;AACvB,cAAM,cAAc,GAAG,QAAQ,CAAC,IAAT,CAAc,IAAd,CAAvB;AACA,aAAK,WAAL,CAAiB,uBAAuB,KAAK,IAAL,EAAW,sBAAsB,cAAc,EAAvF;AACD;;AACD,WAAK,MAAL,CAAY,IAAZ,CAAiB,uBAAuB,KAAK,IAAL,EAAW,YAAnD;AACD,K;AAAA;;AArCoD;;AAAvD,OAAA,CAAA,OAAA,GAAA,iBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BaseTask_1 = require(\"./BaseTask\");\n/**\n * [[ParallelGroupTask]] runs a set of tasks in parallel. When canceled, it\n * stops any currently running tasks.\n */\nclass ParallelGroupTask extends BaseTask_1.default {\n    constructor(logger, taskName, tasksToRunParallel) {\n        super(logger);\n        this.taskName = taskName;\n        this.tasksToRunParallel = tasksToRunParallel;\n        for (const task of tasksToRunParallel) {\n            task.setParent(this);\n        }\n    }\n    cancel() {\n        for (const task of this.tasksToRunParallel) {\n            this.logger.info(`canceling parallel group task ${this.name()} subtask ${task.name()}`);\n            task.cancel();\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const taskResults = [];\n            for (const task of this.tasksToRunParallel) {\n                this.logger.info(`parallel group task ${this.name()} running subtask ${task.name()}`);\n                taskResults.push(task.run());\n            }\n            const failures = [];\n            for (let i = 0; i < taskResults.length; i++) {\n                try {\n                    yield taskResults[i];\n                }\n                catch (err) {\n                    failures.push(`task ${this.tasksToRunParallel[i].name()} failed: ${err.message}`);\n                }\n                this.logger.info(`parallel group task ${this.name()} completed subtask ${this.tasksToRunParallel[i].name()}`);\n            }\n            if (failures.length > 0) {\n                const failureMessage = failures.join(', ');\n                this.logAndThrow(`parallel group task ${this.name()} failed for tasks: ${failureMessage}`);\n            }\n            this.logger.info(`parallel group task ${this.name()} completed`);\n        });\n    }\n}\nexports.default = ParallelGroupTask;\n//# sourceMappingURL=ParallelGroupTask.js.map"]},"metadata":{},"sourceType":"script"}