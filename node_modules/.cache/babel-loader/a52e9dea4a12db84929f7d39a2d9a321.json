{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/**\n * [[LeaveAndReceiveLeaveAckTask]] sends a Leave frame and waits for a LeaveAck.\n */\n\n\nclass LeaveAndReceiveLeaveAckTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'LeaveAndReceiveLeaveAckTask';\n    this.taskCanceler = null;\n  }\n\n  cancel() {\n    if (this.taskCanceler) {\n      this.taskCanceler.cancel();\n      this.taskCanceler = null;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.context.signalingClient.ready()) {\n        this.context.signalingClient.leave();\n        this.context.logger.info('sent leave');\n        yield this.receiveLeaveAck();\n      }\n    });\n  }\n\n  receiveLeaveAck() {\n    return new Promise((resolve, reject) => {\n      class Interceptor {\n        constructor(signalingClient, logger) {\n          this.signalingClient = signalingClient;\n          this.logger = logger;\n        }\n\n        cancel() {\n          this.signalingClient.removeObserver(this);\n          reject(new Error(`LeaveAndReceiveLeaveAckTask got canceled while waiting for IndexFrame`));\n        }\n\n        handleSignalingClientEvent(event) {\n          if (event.isConnectionTerminated()) {\n            this.signalingClient.removeObserver(this);\n            this.logger.info('LeaveAndReceiveLeaveAckTask connection terminated'); // don't treat this as an error\n\n            resolve();\n            return;\n          }\n\n          if (event.type === SignalingClientEventType_1.default.ReceivedSignalFrame && event.message.type === SignalingProtocol_js_1.SdkSignalFrame.Type.LEAVE_ACK) {\n            this.signalingClient.removeObserver(this);\n            this.logger.info('got leave ack');\n            resolve();\n          }\n        }\n\n      }\n\n      const interceptor = new Interceptor(this.context.signalingClient, this.context.logger);\n      this.taskCanceler = interceptor;\n      this.context.signalingClient.registerObserver(interceptor);\n    });\n  }\n\n}\n\nexports.default = LeaveAndReceiveLeaveAckTask;","map":{"version":3,"sources":["../../src/task/LeaveAndReceiveLeaveAckTask.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,MAAA,0BAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AAEA,MAAA,sBAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAEA;;AAEG;;;AACH,MAAqB,2BAArB,SAAyD,UAAA,CAAA,OAAzD,CAAiE;AAI/D,EAAA,WAAA,CAAoB,OAApB,EAAsD;AACpD,UAAM,OAAO,CAAC,MAAd;AADkB,SAAA,OAAA,GAAA,OAAA;AAHV,SAAA,QAAA,GAAW,6BAAX;AACF,SAAA,YAAA,GAAoC,IAApC;AAIP;;AAED,EAAA,MAAM,GAAA;AACJ,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,MAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACD;AACF;;AAEK,EAAA,GAAG,GAAA;;AACP,UAAI,KAAK,OAAL,CAAa,eAAb,CAA6B,KAA7B,EAAJ,EAA0C;AACxC,aAAK,OAAL,CAAa,eAAb,CAA6B,KAA7B;AACA,aAAK,OAAL,CAAa,MAAb,CAAoB,IAApB,CAAyB,YAAzB;AACA,cAAM,KAAK,eAAL,EAAN;AACD;AACF,K;AAAA;;AAEO,EAAA,eAAe,GAAA;AACrB,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrC,YAAM,WAAN,CAAiB;AACf,QAAA,WAAA,CAAoB,eAApB,EAA8D,MAA9D,EAA4E;AAAxD,eAAA,eAAA,GAAA,eAAA;AAA0C,eAAA,MAAA,GAAA,MAAA;AAAkB;;AAEhF,QAAA,MAAM,GAAA;AACJ,eAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC;AACA,UAAA,MAAM,CACJ,IAAI,KAAJ,CAAU,uEAAV,CADI,CAAN;AAGD;;AAED,QAAA,0BAA0B,CAAC,KAAD,EAA4B;AACpD,cAAI,KAAK,CAAC,sBAAN,EAAJ,EAAoC;AAClC,iBAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC;AACA,iBAAK,MAAL,CAAY,IAAZ,CAAiB,mDAAjB,EAFkC,CAGlC;;AACA,YAAA,OAAO;AACP;AACD;;AAED,cACE,KAAK,CAAC,IAAN,KAAe,0BAAA,CAAA,OAAA,CAAyB,mBAAxC,IACA,KAAK,CAAC,OAAN,CAAc,IAAd,KAAuB,sBAAA,CAAA,cAAA,CAAe,IAAf,CAAoB,SAF7C,EAGE;AACA,iBAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC;AACA,iBAAK,MAAL,CAAY,IAAZ,CAAiB,eAAjB;AACA,YAAA,OAAO;AACR;AACF;;AA3Bc;;AA8BjB,YAAM,WAAW,GAAG,IAAI,WAAJ,CAAgB,KAAK,OAAL,CAAa,eAA7B,EAA8C,KAAK,OAAL,CAAa,MAA3D,CAApB;AACA,WAAK,YAAL,GAAoB,WAApB;AACA,WAAK,OAAL,CAAa,eAAb,CAA6B,gBAA7B,CAA8C,WAA9C;AACD,KAlCM,CAAP;AAmCD;;AA3D8D;;AAAjE,OAAA,CAAA,OAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\nconst BaseTask_1 = require(\"./BaseTask\");\n/**\n * [[LeaveAndReceiveLeaveAckTask]] sends a Leave frame and waits for a LeaveAck.\n */\nclass LeaveAndReceiveLeaveAckTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'LeaveAndReceiveLeaveAckTask';\n        this.taskCanceler = null;\n    }\n    cancel() {\n        if (this.taskCanceler) {\n            this.taskCanceler.cancel();\n            this.taskCanceler = null;\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.context.signalingClient.ready()) {\n                this.context.signalingClient.leave();\n                this.context.logger.info('sent leave');\n                yield this.receiveLeaveAck();\n            }\n        });\n    }\n    receiveLeaveAck() {\n        return new Promise((resolve, reject) => {\n            class Interceptor {\n                constructor(signalingClient, logger) {\n                    this.signalingClient = signalingClient;\n                    this.logger = logger;\n                }\n                cancel() {\n                    this.signalingClient.removeObserver(this);\n                    reject(new Error(`LeaveAndReceiveLeaveAckTask got canceled while waiting for IndexFrame`));\n                }\n                handleSignalingClientEvent(event) {\n                    if (event.isConnectionTerminated()) {\n                        this.signalingClient.removeObserver(this);\n                        this.logger.info('LeaveAndReceiveLeaveAckTask connection terminated');\n                        // don't treat this as an error\n                        resolve();\n                        return;\n                    }\n                    if (event.type === SignalingClientEventType_1.default.ReceivedSignalFrame &&\n                        event.message.type === SignalingProtocol_js_1.SdkSignalFrame.Type.LEAVE_ACK) {\n                        this.signalingClient.removeObserver(this);\n                        this.logger.info('got leave ack');\n                        resolve();\n                    }\n                }\n            }\n            const interceptor = new Interceptor(this.context.signalingClient, this.context.logger);\n            this.taskCanceler = interceptor;\n            this.context.signalingClient.registerObserver(interceptor);\n        });\n    }\n}\nexports.default = LeaveAndReceiveLeaveAckTask;\n//# sourceMappingURL=LeaveAndReceiveLeaveAckTask.js.map"]},"metadata":{},"sourceType":"script"}