{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst DefaultVideoStreamIdSet_1 = require(\"../videostreamidset/DefaultVideoStreamIdSet\");\n\nconst VideoStreamDescription_1 = require(\"./VideoStreamDescription\");\n/**\n * [[DefaultVideoStreamIndex]] implements [[VideoStreamIndex]] to facilitate video stream subscription\n * and includes query functions for stream id and attendee id.\n */\n\n\nclass DefaultVideoStreamIndex {\n  constructor(logger) {\n    this.logger = logger;\n    this.currentIndex = null;\n    this.indexForSubscribe = null;\n    this.currentSubscribeAck = null; // These are based on the index at the time of the last Subscribe Ack\n\n    this.subscribeTrackToStreamMap = null;\n    this.subscribeStreamToAttendeeMap = null;\n    this.subscribeStreamToExternalUserIdMap = null;\n    this.subscribeSsrcToStreamMap = null; // These are based on the most up to date index\n\n    this.streamToAttendeeMap = null;\n    this.streamToExternalUserIdMap = null;\n    this.videoStreamDescription = new VideoStreamDescription_1.default();\n    this.videoStreamDescription.trackLabel = 'AmazonChimeExpressVideo';\n    this.videoStreamDescription.streamId = 2;\n    this.videoStreamDescription.groupId = 2;\n  }\n\n  localStreamDescriptions() {\n    // localStreamDescriptions are used to construct IndexFrame\n    // old behavior for single video is to have streamId and groupId trackLabel fixed as the follows\n    return [this.videoStreamDescription.clone()];\n  }\n\n  remoteStreamDescriptions() {\n    if (!this.currentIndex || !this.currentIndex.sources) {\n      return [];\n    }\n\n    const streamInfos = [];\n    this.currentIndex.sources.forEach(source => {\n      const description = new VideoStreamDescription_1.default();\n      description.attendeeId = source.attendeeId;\n      description.groupId = source.groupId;\n      description.streamId = source.streamId;\n      description.maxBitrateKbps = source.maxBitrateKbps;\n      description.avgBitrateKbps = Math.floor(source.avgBitrateBps / 1000);\n      streamInfos.push(description);\n    });\n    return streamInfos;\n  }\n\n  integrateUplinkPolicyDecision(param) {\n    if (!!param && param.length) {\n      const encodingParam = param[0];\n      this.videoStreamDescription.maxBitrateKbps = encodingParam.maxBitrate / 1000;\n      this.videoStreamDescription.maxFrameRate = encodingParam.maxFramerate;\n    }\n  }\n\n  integrateIndexFrame(indexFrame) {\n    this.currentIndex = indexFrame; // In the Amazon Chime SDKs, we assume a one to one mapping of group ID to profile ID when creating\n    // video tiles (multiple video sources are supported through applying a `Modality` to a given profile/session token)\n    //\n    // We enforce this here to mitigate any possible duplicate group IDs left from a reconnection where the previous\n    // signal channel hasn't been timed out yet.  To guarantee we receive the latest stream we use the highest group ID\n    // since they are monotonically increasing.\n\n    const attendeeIdToMainGroupIdMap = new Map(); // Improve performance by not filtering sources unless\n    // we know the list will actually change\n\n    let attendeeWithMultipleGroupIdsExists = false;\n\n    for (const source of indexFrame.sources) {\n      if (!attendeeIdToMainGroupIdMap.has(source.attendeeId)) {\n        // We haven't see this attendee ID so just keep track of it\n        attendeeIdToMainGroupIdMap.set(source.attendeeId, source.groupId);\n        continue;\n      } // Otherwise see if we should use the group ID corresponding to this source (we prefer the highest for each attendee)\n\n\n      const currentGroupId = attendeeIdToMainGroupIdMap.get(source.attendeeId);\n\n      if (currentGroupId < source.groupId) {\n        this.logger.warn(`Old group ID ${currentGroupId} found for attendee ID ${source.attendeeId}, replacing with newer group ID ${source.groupId}`);\n        attendeeIdToMainGroupIdMap.set(source.attendeeId, source.groupId);\n      }\n\n      attendeeWithMultipleGroupIdsExists = true;\n    }\n\n    if (attendeeWithMultipleGroupIdsExists) {\n      // Only use the sources corresponding to the main group IDs for the given attendee ID\n      this.currentIndex.sources = this.currentIndex.sources.filter(source => attendeeIdToMainGroupIdMap.get(source.attendeeId) === source.groupId);\n    }\n\n    this.streamToAttendeeMap = null;\n    this.streamToExternalUserIdMap = null;\n  }\n\n  subscribeFrameSent() {\n    // This is called just as a Subscribe is being sent.  Save corresponding Index\n    this.indexForSubscribe = this.currentIndex;\n  }\n\n  integrateSubscribeAckFrame(subscribeAck) {\n    this.currentSubscribeAck = subscribeAck; // These are valid until the next Subscribe Ack even if the index is updated\n\n    this.subscribeTrackToStreamMap = this.buildTrackToStreamMap(this.currentSubscribeAck);\n    this.subscribeSsrcToStreamMap = this.buildSSRCToStreamMap(this.currentSubscribeAck);\n    this.subscribeStreamToAttendeeMap = this.buildStreamToAttendeeMap(this.indexForSubscribe);\n    this.subscribeStreamToExternalUserIdMap = this.buildStreamExternalUserIdMap(this.indexForSubscribe);\n  }\n\n  integrateBitratesFrame(bitrates) {\n    if (this.currentIndex) {\n      for (const bitrate of bitrates.bitrates) {\n        const source = this.currentIndex.sources.find(source => source.streamId === bitrate.sourceStreamId);\n\n        if (source !== undefined) {\n          source.avgBitrateBps = bitrate.avgBitrateBps;\n        }\n      }\n    }\n  }\n\n  allStreams() {\n    const set = new DefaultVideoStreamIdSet_1.default();\n\n    if (this.currentIndex) {\n      for (const source of this.currentIndex.sources) {\n        set.add(source.streamId);\n      }\n    }\n\n    return set;\n  }\n\n  allVideoSendingSourcesExcludingSelf(selfAttendeeId) {\n    const videoSources = [];\n    const attendeeSet = new Set();\n\n    if (this.currentIndex) {\n      if (this.currentIndex.sources && this.currentIndex.sources.length) {\n        for (const stream of this.currentIndex.sources) {\n          const {\n            attendeeId,\n            externalUserId,\n            mediaType\n          } = stream;\n\n          if (attendeeId !== selfAttendeeId && mediaType === SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n            if (!attendeeSet.has(attendeeId)) {\n              videoSources.push({\n                attendee: {\n                  attendeeId,\n                  externalUserId\n                }\n              });\n              attendeeSet.add(attendeeId);\n            }\n          }\n        }\n      }\n    }\n\n    return videoSources;\n  }\n\n  streamSelectionUnderBandwidthConstraint(selfAttendeeId, largeTileAttendeeIds, smallTileAttendeeIds, bandwidthKbps) {\n    const newAttendees = new Set();\n\n    if (this.currentIndex) {\n      for (const stream of this.currentIndex.sources) {\n        if (stream.attendeeId === selfAttendeeId || stream.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n          continue;\n        }\n\n        if (!largeTileAttendeeIds.has(stream.attendeeId) && !smallTileAttendeeIds.has(stream.attendeeId)) {\n          newAttendees.add(stream.attendeeId);\n        }\n      }\n    }\n\n    const attendeeToStreamDescriptorMap = this.buildAttendeeToSortedStreamDescriptorMapExcludingSelf(selfAttendeeId);\n    const selectionMap = new Map();\n    let usage = 0;\n    attendeeToStreamDescriptorMap.forEach((streams, attendeeId) => {\n      selectionMap.set(attendeeId, streams[0]);\n      usage += streams[0].maxBitrateKbps;\n    });\n    usage = this.trySelectHighBitrateForAttendees(attendeeToStreamDescriptorMap, largeTileAttendeeIds, usage, bandwidthKbps, selectionMap);\n    this.trySelectHighBitrateForAttendees(attendeeToStreamDescriptorMap, newAttendees, usage, bandwidthKbps, selectionMap);\n    const streamSelectionSet = new DefaultVideoStreamIdSet_1.default();\n\n    for (const source of selectionMap.values()) {\n      streamSelectionSet.add(source.streamId);\n    }\n\n    return streamSelectionSet;\n  }\n\n  highestQualityStreamFromEachGroupExcludingSelf(selfAttendeeId) {\n    const set = new DefaultVideoStreamIdSet_1.default();\n\n    if (this.currentIndex) {\n      const maxes = new Map();\n\n      for (const source of this.currentIndex.sources) {\n        if (source.attendeeId === selfAttendeeId || source.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n          continue;\n        }\n\n        if (!maxes.has(source.groupId) || source.maxBitrateKbps > maxes.get(source.groupId).maxBitrateKbps) {\n          maxes.set(source.groupId, source);\n        }\n      }\n\n      for (const source of maxes.values()) {\n        set.add(source.streamId);\n      }\n    }\n\n    return set;\n  }\n\n  numberOfVideoPublishingParticipantsExcludingSelf(selfAttendeeId) {\n    return this.highestQualityStreamFromEachGroupExcludingSelf(selfAttendeeId).array().length;\n  }\n\n  numberOfParticipants() {\n    if (!!this.currentIndex.numParticipants) {\n      return this.currentIndex.numParticipants;\n    }\n\n    return -1;\n  }\n\n  attendeeIdForTrack(trackId) {\n    const streamId = this.streamIdForTrack(trackId);\n\n    if (streamId === undefined || !this.subscribeStreamToAttendeeMap) {\n      this.logger.warn(`no attendee found for track ${trackId}`);\n      return '';\n    }\n\n    const attendeeId = this.subscribeStreamToAttendeeMap.get(streamId);\n\n    if (!attendeeId) {\n      this.logger.info(`track ${trackId} (stream ${streamId}) does not correspond to a known attendee`);\n      return '';\n    }\n\n    return attendeeId;\n  }\n\n  externalUserIdForTrack(trackId) {\n    const streamId = this.streamIdForTrack(trackId);\n\n    if (streamId === undefined || !this.subscribeStreamToExternalUserIdMap) {\n      this.logger.warn(`no external user id found for track ${trackId}`);\n      return '';\n    }\n\n    const externalUserId = this.subscribeStreamToExternalUserIdMap.get(streamId);\n\n    if (!externalUserId) {\n      this.logger.info(`track ${trackId} (stream ${streamId}) does not correspond to a known externalUserId`);\n      return '';\n    }\n\n    return externalUserId;\n  }\n\n  attendeeIdForStreamId(streamId) {\n    if (!this.streamToAttendeeMap) {\n      if (this.currentIndex) {\n        this.streamToAttendeeMap = this.buildStreamToAttendeeMap(this.currentIndex);\n      } else {\n        return '';\n      }\n    }\n\n    const attendeeId = this.streamToAttendeeMap.get(streamId);\n\n    if (!attendeeId) {\n      this.logger.info(`stream ${streamId}) does not correspond to a known attendee`);\n      return '';\n    }\n\n    return attendeeId;\n  }\n\n  groupIdForStreamId(streamId) {\n    for (const source of this.currentIndex.sources) {\n      if (source.streamId === streamId) {\n        return source.groupId;\n      }\n    } // If wasn't found in current index, then it could be in index used in last subscribe\n\n\n    if (!!this.indexForSubscribe) {\n      for (const source of this.indexForSubscribe.sources) {\n        if (source.streamId === streamId) {\n          return source.groupId;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  StreamIdsInSameGroup(streamId1, streamId2) {\n    if (this.groupIdForStreamId(streamId1) === this.groupIdForStreamId(streamId2)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  streamIdForTrack(trackId) {\n    if (!this.subscribeTrackToStreamMap) {\n      return undefined;\n    }\n\n    return this.subscribeTrackToStreamMap.get(trackId);\n  }\n\n  streamIdForSSRC(ssrcId) {\n    if (!this.subscribeSsrcToStreamMap) {\n      return undefined;\n    }\n\n    return this.subscribeSsrcToStreamMap.get(ssrcId);\n  }\n\n  streamsPausedAtSource() {\n    const paused = new DefaultVideoStreamIdSet_1.default();\n\n    if (this.currentIndex) {\n      for (const streamId of this.currentIndex.pausedAtSourceIds) {\n        paused.add(streamId);\n      }\n    }\n\n    return paused;\n  }\n\n  buildTrackToStreamMap(subscribeAck) {\n    const map = new Map();\n    this.logger.debug(() => `trackMap ${JSON.stringify(subscribeAck.tracks)}`);\n\n    for (const trackMapping of subscribeAck.tracks) {\n      if (trackMapping.trackLabel.length > 0 && trackMapping.streamId > 0) {\n        map.set(trackMapping.trackLabel, trackMapping.streamId);\n      }\n    }\n\n    return map;\n  }\n\n  buildSSRCToStreamMap(subscribeAck) {\n    const map = new Map();\n    this.logger.debug(() => `ssrcMap ${JSON.stringify(subscribeAck.tracks)}`);\n\n    for (const trackMapping of subscribeAck.tracks) {\n      if (trackMapping.trackLabel.length > 0 && trackMapping.streamId > 0) {\n        map.set(trackMapping.ssrc, trackMapping.streamId);\n      }\n    }\n\n    return map;\n  }\n\n  buildStreamToAttendeeMap(indexFrame) {\n    const map = new Map();\n\n    if (indexFrame) {\n      for (const source of indexFrame.sources) {\n        map.set(source.streamId, source.attendeeId);\n      }\n    }\n\n    return map;\n  }\n\n  buildStreamExternalUserIdMap(indexFrame) {\n    const map = new Map();\n\n    if (indexFrame) {\n      for (const source of indexFrame.sources) {\n        if (!!source.externalUserId) {\n          map.set(source.streamId, source.externalUserId);\n        }\n      }\n    }\n\n    return map;\n  }\n\n  trySelectHighBitrateForAttendees(attendeeToStreamDescriptorMap, highAttendees, currentUsage, bandwidthKbps, currentSelectionRef) {\n    for (const attendeeId of highAttendees) {\n      if (currentUsage >= bandwidthKbps) {\n        break;\n      }\n\n      if (attendeeToStreamDescriptorMap.has(attendeeId)) {\n        const streams = attendeeToStreamDescriptorMap.get(attendeeId);\n\n        for (const l of streams.reverse()) {\n          if (currentUsage - currentSelectionRef.get(attendeeId).maxBitrateKbps + l.maxBitrateKbps < bandwidthKbps) {\n            currentUsage = currentUsage - currentSelectionRef.get(attendeeId).maxBitrateKbps + l.maxBitrateKbps;\n            currentSelectionRef.set(attendeeId, l);\n            break;\n          }\n        }\n      }\n    }\n\n    return currentUsage;\n  }\n\n  buildAttendeeToSortedStreamDescriptorMapExcludingSelf(selfAttendeeId) {\n    const attendeeToStreamDescriptorMap = new Map();\n\n    if (this.currentIndex) {\n      for (const source of this.currentIndex.sources) {\n        if (source.attendeeId === selfAttendeeId || source.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n          continue;\n        }\n\n        if (attendeeToStreamDescriptorMap.has(source.attendeeId)) {\n          attendeeToStreamDescriptorMap.get(source.attendeeId).push(source);\n        } else {\n          attendeeToStreamDescriptorMap.set(source.attendeeId, [source]);\n        }\n      }\n    }\n\n    attendeeToStreamDescriptorMap.forEach((streams, _attendeeId) => {\n      streams.sort((stream1, stream2) => {\n        if (stream1.maxBitrateKbps > stream2.maxBitrateKbps) {\n          return 1;\n        } else if (stream1.maxBitrateKbps < stream2.maxBitrateKbps) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n    });\n    return attendeeToStreamDescriptorMap;\n  }\n\n}\n\nexports.default = DefaultVideoStreamIndex;","map":{"version":3,"sources":["../../src/videostreamindex/DefaultVideoStreamIndex.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\nconst DefaultVideoStreamIdSet_1 = require(\"../videostreamidset/DefaultVideoStreamIdSet\");\nconst VideoStreamDescription_1 = require(\"./VideoStreamDescription\");\n/**\n * [[DefaultVideoStreamIndex]] implements [[VideoStreamIndex]] to facilitate video stream subscription\n * and includes query functions for stream id and attendee id.\n */\nclass DefaultVideoStreamIndex {\n    constructor(logger) {\n        this.logger = logger;\n        this.currentIndex = null;\n        this.indexForSubscribe = null;\n        this.currentSubscribeAck = null;\n        // These are based on the index at the time of the last Subscribe Ack\n        this.subscribeTrackToStreamMap = null;\n        this.subscribeStreamToAttendeeMap = null;\n        this.subscribeStreamToExternalUserIdMap = null;\n        this.subscribeSsrcToStreamMap = null;\n        // These are based on the most up to date index\n        this.streamToAttendeeMap = null;\n        this.streamToExternalUserIdMap = null;\n        this.videoStreamDescription = new VideoStreamDescription_1.default();\n        this.videoStreamDescription.trackLabel = 'AmazonChimeExpressVideo';\n        this.videoStreamDescription.streamId = 2;\n        this.videoStreamDescription.groupId = 2;\n    }\n    localStreamDescriptions() {\n        // localStreamDescriptions are used to construct IndexFrame\n        // old behavior for single video is to have streamId and groupId trackLabel fixed as the follows\n        return [this.videoStreamDescription.clone()];\n    }\n    remoteStreamDescriptions() {\n        if (!this.currentIndex || !this.currentIndex.sources) {\n            return [];\n        }\n        const streamInfos = [];\n        this.currentIndex.sources.forEach(source => {\n            const description = new VideoStreamDescription_1.default();\n            description.attendeeId = source.attendeeId;\n            description.groupId = source.groupId;\n            description.streamId = source.streamId;\n            description.maxBitrateKbps = source.maxBitrateKbps;\n            description.avgBitrateKbps = Math.floor(source.avgBitrateBps / 1000);\n            streamInfos.push(description);\n        });\n        return streamInfos;\n    }\n    integrateUplinkPolicyDecision(param) {\n        if (!!param && param.length) {\n            const encodingParam = param[0];\n            this.videoStreamDescription.maxBitrateKbps = encodingParam.maxBitrate / 1000;\n            this.videoStreamDescription.maxFrameRate = encodingParam.maxFramerate;\n        }\n    }\n    integrateIndexFrame(indexFrame) {\n        this.currentIndex = indexFrame;\n        // In the Amazon Chime SDKs, we assume a one to one mapping of group ID to profile ID when creating\n        // video tiles (multiple video sources are supported through applying a `Modality` to a given profile/session token)\n        //\n        // We enforce this here to mitigate any possible duplicate group IDs left from a reconnection where the previous\n        // signal channel hasn't been timed out yet.  To guarantee we receive the latest stream we use the highest group ID\n        // since they are monotonically increasing.\n        const attendeeIdToMainGroupIdMap = new Map();\n        // Improve performance by not filtering sources unless\n        // we know the list will actually change\n        let attendeeWithMultipleGroupIdsExists = false;\n        for (const source of indexFrame.sources) {\n            if (!attendeeIdToMainGroupIdMap.has(source.attendeeId)) {\n                // We haven't see this attendee ID so just keep track of it\n                attendeeIdToMainGroupIdMap.set(source.attendeeId, source.groupId);\n                continue;\n            }\n            // Otherwise see if we should use the group ID corresponding to this source (we prefer the highest for each attendee)\n            const currentGroupId = attendeeIdToMainGroupIdMap.get(source.attendeeId);\n            if (currentGroupId < source.groupId) {\n                this.logger.warn(`Old group ID ${currentGroupId} found for attendee ID ${source.attendeeId}, replacing with newer group ID ${source.groupId}`);\n                attendeeIdToMainGroupIdMap.set(source.attendeeId, source.groupId);\n            }\n            attendeeWithMultipleGroupIdsExists = true;\n        }\n        if (attendeeWithMultipleGroupIdsExists) {\n            // Only use the sources corresponding to the main group IDs for the given attendee ID\n            this.currentIndex.sources = this.currentIndex.sources.filter(source => attendeeIdToMainGroupIdMap.get(source.attendeeId) === source.groupId);\n        }\n        this.streamToAttendeeMap = null;\n        this.streamToExternalUserIdMap = null;\n    }\n    subscribeFrameSent() {\n        // This is called just as a Subscribe is being sent.  Save corresponding Index\n        this.indexForSubscribe = this.currentIndex;\n    }\n    integrateSubscribeAckFrame(subscribeAck) {\n        this.currentSubscribeAck = subscribeAck;\n        // These are valid until the next Subscribe Ack even if the index is updated\n        this.subscribeTrackToStreamMap = this.buildTrackToStreamMap(this.currentSubscribeAck);\n        this.subscribeSsrcToStreamMap = this.buildSSRCToStreamMap(this.currentSubscribeAck);\n        this.subscribeStreamToAttendeeMap = this.buildStreamToAttendeeMap(this.indexForSubscribe);\n        this.subscribeStreamToExternalUserIdMap = this.buildStreamExternalUserIdMap(this.indexForSubscribe);\n    }\n    integrateBitratesFrame(bitrates) {\n        if (this.currentIndex) {\n            for (const bitrate of bitrates.bitrates) {\n                const source = this.currentIndex.sources.find(source => source.streamId === bitrate.sourceStreamId);\n                if (source !== undefined) {\n                    source.avgBitrateBps = bitrate.avgBitrateBps;\n                }\n            }\n        }\n    }\n    allStreams() {\n        const set = new DefaultVideoStreamIdSet_1.default();\n        if (this.currentIndex) {\n            for (const source of this.currentIndex.sources) {\n                set.add(source.streamId);\n            }\n        }\n        return set;\n    }\n    allVideoSendingSourcesExcludingSelf(selfAttendeeId) {\n        const videoSources = [];\n        const attendeeSet = new Set();\n        if (this.currentIndex) {\n            if (this.currentIndex.sources && this.currentIndex.sources.length) {\n                for (const stream of this.currentIndex.sources) {\n                    const { attendeeId, externalUserId, mediaType } = stream;\n                    if (attendeeId !== selfAttendeeId && mediaType === SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n                        if (!attendeeSet.has(attendeeId)) {\n                            videoSources.push({ attendee: { attendeeId, externalUserId } });\n                            attendeeSet.add(attendeeId);\n                        }\n                    }\n                }\n            }\n        }\n        return videoSources;\n    }\n    streamSelectionUnderBandwidthConstraint(selfAttendeeId, largeTileAttendeeIds, smallTileAttendeeIds, bandwidthKbps) {\n        const newAttendees = new Set();\n        if (this.currentIndex) {\n            for (const stream of this.currentIndex.sources) {\n                if (stream.attendeeId === selfAttendeeId || stream.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n                    continue;\n                }\n                if (!largeTileAttendeeIds.has(stream.attendeeId) &&\n                    !smallTileAttendeeIds.has(stream.attendeeId)) {\n                    newAttendees.add(stream.attendeeId);\n                }\n            }\n        }\n        const attendeeToStreamDescriptorMap = this.buildAttendeeToSortedStreamDescriptorMapExcludingSelf(selfAttendeeId);\n        const selectionMap = new Map();\n        let usage = 0;\n        attendeeToStreamDescriptorMap.forEach((streams, attendeeId) => {\n            selectionMap.set(attendeeId, streams[0]);\n            usage += streams[0].maxBitrateKbps;\n        });\n        usage = this.trySelectHighBitrateForAttendees(attendeeToStreamDescriptorMap, largeTileAttendeeIds, usage, bandwidthKbps, selectionMap);\n        this.trySelectHighBitrateForAttendees(attendeeToStreamDescriptorMap, newAttendees, usage, bandwidthKbps, selectionMap);\n        const streamSelectionSet = new DefaultVideoStreamIdSet_1.default();\n        for (const source of selectionMap.values()) {\n            streamSelectionSet.add(source.streamId);\n        }\n        return streamSelectionSet;\n    }\n    highestQualityStreamFromEachGroupExcludingSelf(selfAttendeeId) {\n        const set = new DefaultVideoStreamIdSet_1.default();\n        if (this.currentIndex) {\n            const maxes = new Map();\n            for (const source of this.currentIndex.sources) {\n                if (source.attendeeId === selfAttendeeId || source.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n                    continue;\n                }\n                if (!maxes.has(source.groupId) ||\n                    source.maxBitrateKbps > maxes.get(source.groupId).maxBitrateKbps) {\n                    maxes.set(source.groupId, source);\n                }\n            }\n            for (const source of maxes.values()) {\n                set.add(source.streamId);\n            }\n        }\n        return set;\n    }\n    numberOfVideoPublishingParticipantsExcludingSelf(selfAttendeeId) {\n        return this.highestQualityStreamFromEachGroupExcludingSelf(selfAttendeeId).array().length;\n    }\n    numberOfParticipants() {\n        if (!!this.currentIndex.numParticipants) {\n            return this.currentIndex.numParticipants;\n        }\n        return -1;\n    }\n    attendeeIdForTrack(trackId) {\n        const streamId = this.streamIdForTrack(trackId);\n        if (streamId === undefined || !this.subscribeStreamToAttendeeMap) {\n            this.logger.warn(`no attendee found for track ${trackId}`);\n            return '';\n        }\n        const attendeeId = this.subscribeStreamToAttendeeMap.get(streamId);\n        if (!attendeeId) {\n            this.logger.info(`track ${trackId} (stream ${streamId}) does not correspond to a known attendee`);\n            return '';\n        }\n        return attendeeId;\n    }\n    externalUserIdForTrack(trackId) {\n        const streamId = this.streamIdForTrack(trackId);\n        if (streamId === undefined || !this.subscribeStreamToExternalUserIdMap) {\n            this.logger.warn(`no external user id found for track ${trackId}`);\n            return '';\n        }\n        const externalUserId = this.subscribeStreamToExternalUserIdMap.get(streamId);\n        if (!externalUserId) {\n            this.logger.info(`track ${trackId} (stream ${streamId}) does not correspond to a known externalUserId`);\n            return '';\n        }\n        return externalUserId;\n    }\n    attendeeIdForStreamId(streamId) {\n        if (!this.streamToAttendeeMap) {\n            if (this.currentIndex) {\n                this.streamToAttendeeMap = this.buildStreamToAttendeeMap(this.currentIndex);\n            }\n            else {\n                return '';\n            }\n        }\n        const attendeeId = this.streamToAttendeeMap.get(streamId);\n        if (!attendeeId) {\n            this.logger.info(`stream ${streamId}) does not correspond to a known attendee`);\n            return '';\n        }\n        return attendeeId;\n    }\n    groupIdForStreamId(streamId) {\n        for (const source of this.currentIndex.sources) {\n            if (source.streamId === streamId) {\n                return source.groupId;\n            }\n        }\n        // If wasn't found in current index, then it could be in index used in last subscribe\n        if (!!this.indexForSubscribe) {\n            for (const source of this.indexForSubscribe.sources) {\n                if (source.streamId === streamId) {\n                    return source.groupId;\n                }\n            }\n        }\n        return undefined;\n    }\n    StreamIdsInSameGroup(streamId1, streamId2) {\n        if (this.groupIdForStreamId(streamId1) === this.groupIdForStreamId(streamId2)) {\n            return true;\n        }\n        return false;\n    }\n    streamIdForTrack(trackId) {\n        if (!this.subscribeTrackToStreamMap) {\n            return undefined;\n        }\n        return this.subscribeTrackToStreamMap.get(trackId);\n    }\n    streamIdForSSRC(ssrcId) {\n        if (!this.subscribeSsrcToStreamMap) {\n            return undefined;\n        }\n        return this.subscribeSsrcToStreamMap.get(ssrcId);\n    }\n    streamsPausedAtSource() {\n        const paused = new DefaultVideoStreamIdSet_1.default();\n        if (this.currentIndex) {\n            for (const streamId of this.currentIndex.pausedAtSourceIds) {\n                paused.add(streamId);\n            }\n        }\n        return paused;\n    }\n    buildTrackToStreamMap(subscribeAck) {\n        const map = new Map();\n        this.logger.debug(() => `trackMap ${JSON.stringify(subscribeAck.tracks)}`);\n        for (const trackMapping of subscribeAck.tracks) {\n            if (trackMapping.trackLabel.length > 0 && trackMapping.streamId > 0) {\n                map.set(trackMapping.trackLabel, trackMapping.streamId);\n            }\n        }\n        return map;\n    }\n    buildSSRCToStreamMap(subscribeAck) {\n        const map = new Map();\n        this.logger.debug(() => `ssrcMap ${JSON.stringify(subscribeAck.tracks)}`);\n        for (const trackMapping of subscribeAck.tracks) {\n            if (trackMapping.trackLabel.length > 0 && trackMapping.streamId > 0) {\n                map.set(trackMapping.ssrc, trackMapping.streamId);\n            }\n        }\n        return map;\n    }\n    buildStreamToAttendeeMap(indexFrame) {\n        const map = new Map();\n        if (indexFrame) {\n            for (const source of indexFrame.sources) {\n                map.set(source.streamId, source.attendeeId);\n            }\n        }\n        return map;\n    }\n    buildStreamExternalUserIdMap(indexFrame) {\n        const map = new Map();\n        if (indexFrame) {\n            for (const source of indexFrame.sources) {\n                if (!!source.externalUserId) {\n                    map.set(source.streamId, source.externalUserId);\n                }\n            }\n        }\n        return map;\n    }\n    trySelectHighBitrateForAttendees(attendeeToStreamDescriptorMap, highAttendees, currentUsage, bandwidthKbps, currentSelectionRef) {\n        for (const attendeeId of highAttendees) {\n            if (currentUsage >= bandwidthKbps) {\n                break;\n            }\n            if (attendeeToStreamDescriptorMap.has(attendeeId)) {\n                const streams = attendeeToStreamDescriptorMap.get(attendeeId);\n                for (const l of streams.reverse()) {\n                    if (currentUsage - currentSelectionRef.get(attendeeId).maxBitrateKbps + l.maxBitrateKbps <\n                        bandwidthKbps) {\n                        currentUsage =\n                            currentUsage - currentSelectionRef.get(attendeeId).maxBitrateKbps + l.maxBitrateKbps;\n                        currentSelectionRef.set(attendeeId, l);\n                        break;\n                    }\n                }\n            }\n        }\n        return currentUsage;\n    }\n    buildAttendeeToSortedStreamDescriptorMapExcludingSelf(selfAttendeeId) {\n        const attendeeToStreamDescriptorMap = new Map();\n        if (this.currentIndex) {\n            for (const source of this.currentIndex.sources) {\n                if (source.attendeeId === selfAttendeeId || source.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n                    continue;\n                }\n                if (attendeeToStreamDescriptorMap.has(source.attendeeId)) {\n                    attendeeToStreamDescriptorMap.get(source.attendeeId).push(source);\n                }\n                else {\n                    attendeeToStreamDescriptorMap.set(source.attendeeId, [source]);\n                }\n            }\n        }\n        attendeeToStreamDescriptorMap.forEach((streams, _attendeeId) => {\n            streams.sort((stream1, stream2) => {\n                if (stream1.maxBitrateKbps > stream2.maxBitrateKbps) {\n                    return 1;\n                }\n                else if (stream1.maxBitrateKbps < stream2.maxBitrateKbps) {\n                    return -1;\n                }\n                else {\n                    return 0;\n                }\n            });\n        });\n        return attendeeToStreamDescriptorMap;\n    }\n}\nexports.default = DefaultVideoStreamIndex;\n//# sourceMappingURL=DefaultVideoStreamIndex.js.map"]},"metadata":{},"sourceType":"script"}