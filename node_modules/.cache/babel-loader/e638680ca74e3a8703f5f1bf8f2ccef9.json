{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[SetRemoteDescriptionTask]] asynchronously calls [[setRemoteDescription]] on the\n * peer connection and then waits for the tracks to be added and for the ICE connection\n * to complete.\n */\n\n\nclass SetRemoteDescriptionTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'SetRemoteDescriptionTask';\n  }\n\n  cancel() {\n    if (this.cancelICEPromise) {\n      this.cancelICEPromise();\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const peer = this.context.peer;\n\n      if (!peer) {\n        this.logAndThrow('session does not have peer connection; bypass set remote description');\n      }\n\n      let sdp = this.context.sdpAnswer;\n      sdp = new DefaultSDP_1.default(sdp).withoutServerReflexiveCandidates().sdp;\n\n      if (this.context.audioProfile) {\n        sdp = new DefaultSDP_1.default(sdp).withAudioMaxAverageBitrate(this.context.audioProfile.audioBitrateBps).sdp;\n      }\n\n      if (!this.context.browserBehavior.requiresUnifiedPlan()) {\n        // Under Plan B if our offer has video, but we're not going to subscribe to\n        // any videos, ensure that the answer has video (marked inactive). If\n        // it doesn't, WebRTC will reject the SDP answer. This happens on Chrome\n        // when going from receiving one video to zero videos. The server does not\n        // provide a video m-line when there are no videos available under Plan B,\n        // thus we need to synthesize a video m-line by copying the one from the offer.\n        this.logger.info('checking for no videos (plan-b)');\n\n        if (this.context.videosToReceive.empty() && this.context.peer.remoteDescription) {\n          this.logger.info('have no videos and have remote description (plan-b)');\n          const sdpInactiveVideoOffer = this.context.peer.localDescription.sdp;\n          const sdpInactiveVideoAnswer = sdp;\n          let updatedAnswer = sdpInactiveVideoAnswer;\n          const offer = new DefaultSDP_1.default(sdpInactiveVideoOffer);\n\n          if (offer.hasVideo()) {\n            this.logger.info(`offer has video (plan-b): >>>${offer.sdp}<<<`);\n            const answer = new DefaultSDP_1.default(sdpInactiveVideoAnswer);\n            this.logger.info(`existing answer (plan-b): >>>${answer.sdp}<<<`);\n\n            if (!answer.hasVideo()) {\n              this.logger.info(`copying inactive video from offer into answer (plan-b); sdp answer before is >>>${sdpInactiveVideoAnswer}<<<`);\n              updatedAnswer = answer.copyVideo(sdpInactiveVideoOffer).sdp;\n            }\n          }\n\n          sdp = updatedAnswer;\n        }\n      }\n\n      if (new DefaultBrowserBehavior_1.default().requiresSortCodecPreferencesForSdpAnswer()) {\n        sdp = new DefaultSDP_1.default(sdp).preferH264IfExists().sdp;\n      }\n\n      this.logger.info(`processed remote description is >>>${sdp}<<<`);\n      const remoteDescription = {\n        type: 'answer',\n        sdp: sdp,\n        toJSON: null\n      };\n\n      try {\n        yield this.createICEConnectionCompletedPromise(remoteDescription);\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n\n  createICEConnectionCompletedPromise(remoteDescription) {\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      const checkConnectionCompleted = () => {\n        if (this.context.peer.iceConnectionState === 'connected' || this.context.peer.iceConnectionState === 'completed') {\n          this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);\n          resolve();\n        }\n      };\n\n      this.cancelICEPromise = () => {\n        if (this.context.peer) {\n          this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);\n        }\n\n        reject(new Error(`${this.name()} got canceled while waiting for the ICE connection state`));\n      };\n\n      this.context.peer.addEventListener('iceconnectionstatechange', checkConnectionCompleted);\n\n      try {\n        yield this.context.peer.setRemoteDescription(remoteDescription);\n        this.logger.info('set remote description, waiting for ICE connection');\n        checkConnectionCompleted();\n      } catch (err) {\n        reject(err);\n      }\n    }));\n  }\n\n}\n\nexports.default = SetRemoteDescriptionTask;","map":{"version":3,"sources":["../../src/task/SetRemoteDescriptionTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[SetRemoteDescriptionTask]] asynchronously calls [[setRemoteDescription]] on the\n * peer connection and then waits for the tracks to be added and for the ICE connection\n * to complete.\n */\nclass SetRemoteDescriptionTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'SetRemoteDescriptionTask';\n    }\n    cancel() {\n        if (this.cancelICEPromise) {\n            this.cancelICEPromise();\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const peer = this.context.peer;\n            if (!peer) {\n                this.logAndThrow('session does not have peer connection; bypass set remote description');\n            }\n            let sdp = this.context.sdpAnswer;\n            sdp = new DefaultSDP_1.default(sdp).withoutServerReflexiveCandidates().sdp;\n            if (this.context.audioProfile) {\n                sdp = new DefaultSDP_1.default(sdp).withAudioMaxAverageBitrate(this.context.audioProfile.audioBitrateBps).sdp;\n            }\n            if (!this.context.browserBehavior.requiresUnifiedPlan()) {\n                // Under Plan B if our offer has video, but we're not going to subscribe to\n                // any videos, ensure that the answer has video (marked inactive). If\n                // it doesn't, WebRTC will reject the SDP answer. This happens on Chrome\n                // when going from receiving one video to zero videos. The server does not\n                // provide a video m-line when there are no videos available under Plan B,\n                // thus we need to synthesize a video m-line by copying the one from the offer.\n                this.logger.info('checking for no videos (plan-b)');\n                if (this.context.videosToReceive.empty() && this.context.peer.remoteDescription) {\n                    this.logger.info('have no videos and have remote description (plan-b)');\n                    const sdpInactiveVideoOffer = this.context.peer.localDescription.sdp;\n                    const sdpInactiveVideoAnswer = sdp;\n                    let updatedAnswer = sdpInactiveVideoAnswer;\n                    const offer = new DefaultSDP_1.default(sdpInactiveVideoOffer);\n                    if (offer.hasVideo()) {\n                        this.logger.info(`offer has video (plan-b): >>>${offer.sdp}<<<`);\n                        const answer = new DefaultSDP_1.default(sdpInactiveVideoAnswer);\n                        this.logger.info(`existing answer (plan-b): >>>${answer.sdp}<<<`);\n                        if (!answer.hasVideo()) {\n                            this.logger.info(`copying inactive video from offer into answer (plan-b); sdp answer before is >>>${sdpInactiveVideoAnswer}<<<`);\n                            updatedAnswer = answer.copyVideo(sdpInactiveVideoOffer).sdp;\n                        }\n                    }\n                    sdp = updatedAnswer;\n                }\n            }\n            if (new DefaultBrowserBehavior_1.default().requiresSortCodecPreferencesForSdpAnswer()) {\n                sdp = new DefaultSDP_1.default(sdp).preferH264IfExists().sdp;\n            }\n            this.logger.info(`processed remote description is >>>${sdp}<<<`);\n            const remoteDescription = {\n                type: 'answer',\n                sdp: sdp,\n                toJSON: null,\n            };\n            try {\n                yield this.createICEConnectionCompletedPromise(remoteDescription);\n            }\n            catch (err) {\n                throw err;\n            }\n        });\n    }\n    createICEConnectionCompletedPromise(remoteDescription) {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            const checkConnectionCompleted = () => {\n                if (this.context.peer.iceConnectionState === 'connected' ||\n                    this.context.peer.iceConnectionState === 'completed') {\n                    this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);\n                    resolve();\n                }\n            };\n            this.cancelICEPromise = () => {\n                if (this.context.peer) {\n                    this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);\n                }\n                reject(new Error(`${this.name()} got canceled while waiting for the ICE connection state`));\n            };\n            this.context.peer.addEventListener('iceconnectionstatechange', checkConnectionCompleted);\n            try {\n                yield this.context.peer.setRemoteDescription(remoteDescription);\n                this.logger.info('set remote description, waiting for ICE connection');\n                checkConnectionCompleted();\n            }\n            catch (err) {\n                reject(err);\n            }\n        }));\n    }\n}\nexports.default = SetRemoteDescriptionTask;\n//# sourceMappingURL=SetRemoteDescriptionTask.js.map"]},"metadata":{},"sourceType":"script"}