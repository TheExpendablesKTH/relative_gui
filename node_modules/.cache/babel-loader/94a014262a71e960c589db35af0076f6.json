{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nconst DefaultVideoStreamIndex_1 = require(\"./DefaultVideoStreamIndex\");\n\nconst VideoStreamDescription_1 = require(\"./VideoStreamDescription\");\n/**\n * [[SimulcastTransceiverController]] implements [[VideoStreamIndex]] to facilitate video stream\n * subscription and includes query functions for stream id and attendee id.\n */\n\n\nclass SimulcastVideoStreamIndex extends DefaultVideoStreamIndex_1.default {\n  constructor(logger) {\n    super(logger);\n    this.streamIdToBitrateKbpsMap = new Map();\n    this._localStreamInfos = [];\n    this._lastBitRateMsgTime = Date.now();\n  }\n\n  localStreamDescriptions() {\n    const clonedDescriptions = [];\n\n    this._localStreamInfos.forEach(desc => {\n      clonedDescriptions.push(desc.clone());\n    });\n\n    return clonedDescriptions;\n  }\n\n  integrateUplinkPolicyDecision(encodingParams) {\n    // Reuse local streams (that might already have stream IDs allocated) until\n    // there are no more and then add as many new local streams as needed\n    let hasStreamsToReuse = true;\n    let localStreamIndex = 0;\n\n    for (let i = 0; i < encodingParams.length; i++) {\n      const targetMaxBitrateKbps = encodingParams[i].maxBitrate / 1000;\n      const targetMaxFrameRate = encodingParams[i].maxFramerate;\n\n      if (!hasStreamsToReuse || i === this._localStreamInfos.length) {\n        hasStreamsToReuse = false;\n        const newInfo = new VideoStreamDescription_1.default();\n        newInfo.maxBitrateKbps = targetMaxBitrateKbps;\n        newInfo.maxFrameRate = targetMaxFrameRate;\n        newInfo.disabledByUplinkPolicy = targetMaxBitrateKbps === 0 ? true : false;\n\n        if (targetMaxBitrateKbps !== 0) {\n          newInfo.timeEnabled = Date.now();\n        }\n\n        this._localStreamInfos.push(newInfo);\n\n        localStreamIndex++;\n        continue;\n      }\n\n      if (this._localStreamInfos[localStreamIndex].maxBitrateKbps === 0 && targetMaxBitrateKbps > 0) {\n        this._localStreamInfos[localStreamIndex].timeEnabled = Date.now();\n      }\n\n      this._localStreamInfos[localStreamIndex].maxBitrateKbps = targetMaxBitrateKbps;\n      this._localStreamInfos[localStreamIndex].maxFrameRate = targetMaxFrameRate;\n      this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy = targetMaxBitrateKbps === 0 ? true : false;\n\n      if (this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy === true) {\n        this._localStreamInfos[localStreamIndex].disabledByWebRTC = false;\n      }\n\n      localStreamIndex++;\n    }\n\n    if (hasStreamsToReuse) {\n      // splice is zero-based, remove stream starting from localStreamIndex\n      this._localStreamInfos.splice(localStreamIndex);\n    }\n  }\n\n  integrateBitratesFrame(bitrateFrame) {\n    super.integrateBitratesFrame(bitrateFrame);\n    const stillSending = new Set();\n    const existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n\n    for (const bitrateMsg of bitrateFrame.bitrates) {\n      stillSending.add(bitrateMsg.sourceStreamId);\n      this.streamIdToBitrateKbpsMap.set(bitrateMsg.sourceStreamId, Math.trunc(bitrateMsg.avgBitrateBps / 1000));\n    }\n\n    for (const id of existingSet) {\n      if (!stillSending.has(id)) {\n        const avgBitrateBps = this.streamIdToBitrateKbpsMap.get(id);\n\n        if (avgBitrateBps === SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE) {\n          this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE);\n        } else {\n          this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE);\n        }\n      }\n    }\n\n    for (let i = 0; i < this._localStreamInfos.length; i++) {\n      this._localStreamInfos[i].disabledByWebRTC = false;\n      const streamId = this._localStreamInfos[i].streamId;\n\n      if (this._localStreamInfos[i].disabledByUplinkPolicy) {\n        continue;\n      }\n\n      if (this.streamIdToBitrateKbpsMap.has(streamId)) {\n        const avgBitrateKbps = this.streamIdToBitrateKbpsMap.get(streamId);\n\n        if (avgBitrateKbps === SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE && this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled > SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n          this._localStreamInfos[i].disabledByWebRTC = true;\n        }\n      } else {\n        // Do not flag as disabled if it was recently enabled\n        if (this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled > SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n          this._localStreamInfos[i].disabledByWebRTC = true;\n        }\n      }\n    }\n\n    this._lastBitRateMsgTime = Date.now();\n    this.logLocalStreamDescriptions();\n  }\n\n  logLocalStreamDescriptions() {\n    let msg = '';\n\n    for (const desc of this._localStreamInfos) {\n      msg += `streamId=${desc.streamId} maxBitrate=${desc.maxBitrateKbps} disabledByWebRTC=${desc.disabledByWebRTC} disabledByUplink=${desc.disabledByUplinkPolicy}\\n`;\n    }\n\n    this.logger.debug(() => {\n      return msg;\n    });\n  }\n\n  integrateIndexFrame(indexFrame) {\n    super.integrateIndexFrame(indexFrame);\n    const newIndexStreamIdSet = new Set();\n    const existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n\n    for (const stream of this.currentIndex.sources) {\n      if (stream.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n        continue;\n      }\n\n      newIndexStreamIdSet.add(stream.streamId);\n\n      if (!this.streamIdToBitrateKbpsMap.has(stream.streamId)) {\n        this.streamIdToBitrateKbpsMap.set(stream.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n      }\n    }\n\n    for (const id of existingSet) {\n      if (!newIndexStreamIdSet.has(id)) {\n        this.streamIdToBitrateKbpsMap.delete(id);\n      }\n    }\n  }\n\n  integrateSubscribeAckFrame(subscribeAck) {\n    super.integrateSubscribeAckFrame(subscribeAck);\n\n    if (!subscribeAck.allocations || subscribeAck.allocations === undefined) {\n      return;\n    }\n\n    let localStreamStartIndex = 0;\n\n    for (const allocation of subscribeAck.allocations) {\n      // track label is what we offered to the server\n      if (this._localStreamInfos.length < localStreamStartIndex + 1) {\n        this.logger.info('simulcast: allocation has more than number of local streams');\n        break;\n      }\n\n      this._localStreamInfos[localStreamStartIndex].groupId = allocation.groupId;\n      this._localStreamInfos[localStreamStartIndex].streamId = allocation.streamId;\n\n      if (!this.streamIdToBitrateKbpsMap.has(allocation.streamId)) {\n        this.streamIdToBitrateKbpsMap.set(allocation.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n      }\n\n      localStreamStartIndex++;\n    }\n  }\n\n}\n\nexports.default = SimulcastVideoStreamIndex; // First time when the bitrate of a stream id is missing from bitrate message, mark it as UNSEEN\n\nSimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE = -2; // Second time when the bitrate is missing, mark it as recently inactive\n\nSimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE = -1; // Third time when bitrate is missing, mark it as not sending\n\nSimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE = 0;\nSimulcastVideoStreamIndex.BitratesMsgFrequencyMs = 4000;","map":{"version":3,"sources":["../../src/videostreamindex/SimulcastVideoStreamIndex.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\nconst DefaultVideoStreamIndex_1 = require(\"./DefaultVideoStreamIndex\");\nconst VideoStreamDescription_1 = require(\"./VideoStreamDescription\");\n/**\n * [[SimulcastTransceiverController]] implements [[VideoStreamIndex]] to facilitate video stream\n * subscription and includes query functions for stream id and attendee id.\n */\nclass SimulcastVideoStreamIndex extends DefaultVideoStreamIndex_1.default {\n    constructor(logger) {\n        super(logger);\n        this.streamIdToBitrateKbpsMap = new Map();\n        this._localStreamInfos = [];\n        this._lastBitRateMsgTime = Date.now();\n    }\n    localStreamDescriptions() {\n        const clonedDescriptions = [];\n        this._localStreamInfos.forEach(desc => {\n            clonedDescriptions.push(desc.clone());\n        });\n        return clonedDescriptions;\n    }\n    integrateUplinkPolicyDecision(encodingParams) {\n        // Reuse local streams (that might already have stream IDs allocated) until\n        // there are no more and then add as many new local streams as needed\n        let hasStreamsToReuse = true;\n        let localStreamIndex = 0;\n        for (let i = 0; i < encodingParams.length; i++) {\n            const targetMaxBitrateKbps = encodingParams[i].maxBitrate / 1000;\n            const targetMaxFrameRate = encodingParams[i].maxFramerate;\n            if (!hasStreamsToReuse || i === this._localStreamInfos.length) {\n                hasStreamsToReuse = false;\n                const newInfo = new VideoStreamDescription_1.default();\n                newInfo.maxBitrateKbps = targetMaxBitrateKbps;\n                newInfo.maxFrameRate = targetMaxFrameRate;\n                newInfo.disabledByUplinkPolicy = targetMaxBitrateKbps === 0 ? true : false;\n                if (targetMaxBitrateKbps !== 0) {\n                    newInfo.timeEnabled = Date.now();\n                }\n                this._localStreamInfos.push(newInfo);\n                localStreamIndex++;\n                continue;\n            }\n            if (this._localStreamInfos[localStreamIndex].maxBitrateKbps === 0 &&\n                targetMaxBitrateKbps > 0) {\n                this._localStreamInfos[localStreamIndex].timeEnabled = Date.now();\n            }\n            this._localStreamInfos[localStreamIndex].maxBitrateKbps = targetMaxBitrateKbps;\n            this._localStreamInfos[localStreamIndex].maxFrameRate = targetMaxFrameRate;\n            this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy =\n                targetMaxBitrateKbps === 0 ? true : false;\n            if (this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy === true) {\n                this._localStreamInfos[localStreamIndex].disabledByWebRTC = false;\n            }\n            localStreamIndex++;\n        }\n        if (hasStreamsToReuse) {\n            // splice is zero-based, remove stream starting from localStreamIndex\n            this._localStreamInfos.splice(localStreamIndex);\n        }\n    }\n    integrateBitratesFrame(bitrateFrame) {\n        super.integrateBitratesFrame(bitrateFrame);\n        const stillSending = new Set();\n        const existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n        for (const bitrateMsg of bitrateFrame.bitrates) {\n            stillSending.add(bitrateMsg.sourceStreamId);\n            this.streamIdToBitrateKbpsMap.set(bitrateMsg.sourceStreamId, Math.trunc(bitrateMsg.avgBitrateBps / 1000));\n        }\n        for (const id of existingSet) {\n            if (!stillSending.has(id)) {\n                const avgBitrateBps = this.streamIdToBitrateKbpsMap.get(id);\n                if (avgBitrateBps === SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE) {\n                    this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE);\n                }\n                else {\n                    this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE);\n                }\n            }\n        }\n        for (let i = 0; i < this._localStreamInfos.length; i++) {\n            this._localStreamInfos[i].disabledByWebRTC = false;\n            const streamId = this._localStreamInfos[i].streamId;\n            if (this._localStreamInfos[i].disabledByUplinkPolicy) {\n                continue;\n            }\n            if (this.streamIdToBitrateKbpsMap.has(streamId)) {\n                const avgBitrateKbps = this.streamIdToBitrateKbpsMap.get(streamId);\n                if (avgBitrateKbps === SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE &&\n                    this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled >\n                        SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n                    this._localStreamInfos[i].disabledByWebRTC = true;\n                }\n            }\n            else {\n                // Do not flag as disabled if it was recently enabled\n                if (this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled >\n                    SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n                    this._localStreamInfos[i].disabledByWebRTC = true;\n                }\n            }\n        }\n        this._lastBitRateMsgTime = Date.now();\n        this.logLocalStreamDescriptions();\n    }\n    logLocalStreamDescriptions() {\n        let msg = '';\n        for (const desc of this._localStreamInfos) {\n            msg += `streamId=${desc.streamId} maxBitrate=${desc.maxBitrateKbps} disabledByWebRTC=${desc.disabledByWebRTC} disabledByUplink=${desc.disabledByUplinkPolicy}\\n`;\n        }\n        this.logger.debug(() => {\n            return msg;\n        });\n    }\n    integrateIndexFrame(indexFrame) {\n        super.integrateIndexFrame(indexFrame);\n        const newIndexStreamIdSet = new Set();\n        const existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n        for (const stream of this.currentIndex.sources) {\n            if (stream.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n                continue;\n            }\n            newIndexStreamIdSet.add(stream.streamId);\n            if (!this.streamIdToBitrateKbpsMap.has(stream.streamId)) {\n                this.streamIdToBitrateKbpsMap.set(stream.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n            }\n        }\n        for (const id of existingSet) {\n            if (!newIndexStreamIdSet.has(id)) {\n                this.streamIdToBitrateKbpsMap.delete(id);\n            }\n        }\n    }\n    integrateSubscribeAckFrame(subscribeAck) {\n        super.integrateSubscribeAckFrame(subscribeAck);\n        if (!subscribeAck.allocations || subscribeAck.allocations === undefined) {\n            return;\n        }\n        let localStreamStartIndex = 0;\n        for (const allocation of subscribeAck.allocations) {\n            // track label is what we offered to the server\n            if (this._localStreamInfos.length < localStreamStartIndex + 1) {\n                this.logger.info('simulcast: allocation has more than number of local streams');\n                break;\n            }\n            this._localStreamInfos[localStreamStartIndex].groupId = allocation.groupId;\n            this._localStreamInfos[localStreamStartIndex].streamId = allocation.streamId;\n            if (!this.streamIdToBitrateKbpsMap.has(allocation.streamId)) {\n                this.streamIdToBitrateKbpsMap.set(allocation.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n            }\n            localStreamStartIndex++;\n        }\n    }\n}\nexports.default = SimulcastVideoStreamIndex;\n// First time when the bitrate of a stream id is missing from bitrate message, mark it as UNSEEN\nSimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE = -2;\n// Second time when the bitrate is missing, mark it as recently inactive\nSimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE = -1;\n// Third time when bitrate is missing, mark it as not sending\nSimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE = 0;\nSimulcastVideoStreamIndex.BitratesMsgFrequencyMs = 4000;\n//# sourceMappingURL=SimulcastVideoStreamIndex.js.map"]},"metadata":{},"sourceType":"script"}