{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nconst DefaultVideoFrameProcessorPipeline_1 = require(\"./DefaultVideoFrameProcessorPipeline\");\n/**\n * [[DefaultVideoTransformDevice]] is an augmented [[VideoInputDevice]].\n * It transform the input {@link Device} with an array of {@link VideoFrameProcessor} to produce a `MediaStream`.\n */\n\n\nclass DefaultVideoTransformDevice {\n  constructor(logger, device, processors, browserBehavior = new DefaultBrowserBehavior_1.default()) {\n    this.logger = logger;\n    this.device = device;\n    this.processors = processors;\n    this.browserBehavior = browserBehavior;\n    this.observers = new Set();\n    this.pipe = new DefaultVideoFrameProcessorPipeline_1.default(this.logger, this.processors);\n    this.pipe.addObserver(this);\n  }\n  /**\n   * getter for `outputMediaStream`.\n   * `outputMediaStream` is returned by internal {@link VideoFrameProcessorPipeline}.\n   * It is possible, but unlikely, that this accessor will throw.\n   */\n\n\n  get outputMediaStream() {\n    return this.pipe.outputMediaStream;\n  }\n  /**\n   * `chooseNewInnerDevice` preserves the inner pipeline and processing state and switches\n   * the inner device. Since the pipeline and processors are shared with the new transform device\n   * only one transform device can be used.\n   */\n\n\n  chooseNewInnerDevice(newDevice) {\n    const newTransformDevice = new DefaultVideoTransformDevice(this.logger, newDevice, this.processors, this.browserBehavior);\n    newTransformDevice.pipe = this.pipe;\n    return newTransformDevice;\n  }\n  /**\n   * Return the inner device as provided during construction.\n   */\n\n\n  getInnerDevice() {\n    return this.device;\n  }\n\n  intrinsicDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const trackConstraints = {}; // Empty string and null.\n\n      if (!this.device) {\n        return trackConstraints;\n      } // Device ID.\n\n\n      if (typeof this.device === 'string') {\n        if (this.browserBehavior.requiresNoExactMediaStreamConstraints()) {\n          trackConstraints.deviceId = this.device;\n        } else {\n          trackConstraints.deviceId = {\n            exact: this.device\n          };\n        }\n\n        return trackConstraints;\n      }\n\n      if (this.device.id) {\n        // Nothing we can do.\n        return this.device;\n      } // It's constraints.\n\n\n      return Object.assign(Object.assign({}, this.device), trackConstraints);\n    });\n  }\n  /**\n   * Create {@link VideoFrameProcessorPipeline} if there is not a existing one and start video processors.\n   * Returns output `MediaStream` produced by {@link VideoFrameProcessorPipeline}.\n   */\n\n\n  transformStream(mediaStream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.pipe.setInputMediaStream(mediaStream);\n      this.inputMediaStream = mediaStream;\n      return this.pipe.getActiveOutputMediaStream();\n    });\n  }\n  /**\n   * onOutputStreamDisconnect is called when device controller wants to detach\n   * the transform device. The default behavior is to stop the output\n   * media stream and release the input the media stream. If the input media stream\n   * is the provided device, it will not be released.\n   */\n\n\n  onOutputStreamDisconnect() {\n    this.logger.info('DefaultVideoTransformDevice: detach stopping input media stream');\n    const deviceIsMediaStream = this.device && this.device.id; // Stop processing but keep the pipe and processors\n\n    this.pipe.stop(); // Turn off the camera, unless device is a MediaStream\n\n    if (!deviceIsMediaStream) {\n      if (this.inputMediaStream) {\n        for (const track of this.inputMediaStream.getVideoTracks()) {\n          track.stop();\n        }\n      }\n    }\n  }\n  /**\n   * Dispose of the inner workings of the transform device, including pipeline and processors.\n   * `stop` can only be called when the transform device is not used by device controller anymore.\n   * After `stop` is called, all transform devices which share the pipeline must be discarded.\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.inputMediaStream) {\n        for (const track of this.inputMediaStream.getVideoTracks()) {\n          track.stop();\n        }\n      }\n\n      this.pipe.destroy();\n      this.inputMediaStream = null;\n    });\n  }\n  /**\n   * Add an observer to receive notifications about lifecycle events.\n   * See {@link DefaultVideoTransformDeviceObserver} for details.\n   * If the observer has already been added, this method call has no effect.\n   */\n\n\n  addObserver(observer) {\n    this.observers.add(observer);\n  }\n  /**\n   * Remove an existing observer. If the observer has not been previously. this method call has no effect.\n   */\n\n\n  removeObserver(observer) {\n    this.observers.add(observer);\n  }\n\n  processingDidStart() {\n    this.logger.info('video transform device processing started');\n    this.forEachObserver(observer => {\n      if (observer.processingDidStart) {\n        observer.processingDidStart();\n      }\n    });\n  }\n\n  processingLatencyTooHigh(latencyMs) {\n    this.forEachObserver(observer => {\n      if (observer.processingLatencyTooHigh) {\n        observer.processingLatencyTooHigh(latencyMs);\n      }\n    });\n  }\n\n  processingDidFailToStart() {\n    this.logger.info('video transform device processing failed to start');\n    this.forEachObserver(observer => {\n      if (observer.processingDidFailToStart) {\n        observer.processingDidFailToStart();\n      }\n    });\n  }\n\n  processingDidStop() {\n    this.logger.info('video transform device processing stopped');\n    this.forEachObserver(observer => {\n      if (observer.processingDidStop) {\n        observer.processingDidStop();\n      }\n    });\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observers) {\n      setTimeout(() => {\n        observerFunc(observer);\n      }, 0);\n    }\n  }\n\n}\n\nexports.default = DefaultVideoTransformDevice;","map":{"version":3,"sources":["../../src/videoframeprocessor/DefaultVideoTransformDevice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\nconst DefaultVideoFrameProcessorPipeline_1 = require(\"./DefaultVideoFrameProcessorPipeline\");\n/**\n * [[DefaultVideoTransformDevice]] is an augmented [[VideoInputDevice]].\n * It transform the input {@link Device} with an array of {@link VideoFrameProcessor} to produce a `MediaStream`.\n */\nclass DefaultVideoTransformDevice {\n    constructor(logger, device, processors, browserBehavior = new DefaultBrowserBehavior_1.default()) {\n        this.logger = logger;\n        this.device = device;\n        this.processors = processors;\n        this.browserBehavior = browserBehavior;\n        this.observers = new Set();\n        this.pipe = new DefaultVideoFrameProcessorPipeline_1.default(this.logger, this.processors);\n        this.pipe.addObserver(this);\n    }\n    /**\n     * getter for `outputMediaStream`.\n     * `outputMediaStream` is returned by internal {@link VideoFrameProcessorPipeline}.\n     * It is possible, but unlikely, that this accessor will throw.\n     */\n    get outputMediaStream() {\n        return this.pipe.outputMediaStream;\n    }\n    /**\n     * `chooseNewInnerDevice` preserves the inner pipeline and processing state and switches\n     * the inner device. Since the pipeline and processors are shared with the new transform device\n     * only one transform device can be used.\n     */\n    chooseNewInnerDevice(newDevice) {\n        const newTransformDevice = new DefaultVideoTransformDevice(this.logger, newDevice, this.processors, this.browserBehavior);\n        newTransformDevice.pipe = this.pipe;\n        return newTransformDevice;\n    }\n    /**\n     * Return the inner device as provided during construction.\n     */\n    getInnerDevice() {\n        return this.device;\n    }\n    intrinsicDevice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const trackConstraints = {};\n            // Empty string and null.\n            if (!this.device) {\n                return trackConstraints;\n            }\n            // Device ID.\n            if (typeof this.device === 'string') {\n                if (this.browserBehavior.requiresNoExactMediaStreamConstraints()) {\n                    trackConstraints.deviceId = this.device;\n                }\n                else {\n                    trackConstraints.deviceId = { exact: this.device };\n                }\n                return trackConstraints;\n            }\n            if (this.device.id) {\n                // Nothing we can do.\n                return this.device;\n            }\n            // It's constraints.\n            return Object.assign(Object.assign({}, this.device), trackConstraints);\n        });\n    }\n    /**\n     * Create {@link VideoFrameProcessorPipeline} if there is not a existing one and start video processors.\n     * Returns output `MediaStream` produced by {@link VideoFrameProcessorPipeline}.\n     */\n    transformStream(mediaStream) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.pipe.setInputMediaStream(mediaStream);\n            this.inputMediaStream = mediaStream;\n            return this.pipe.getActiveOutputMediaStream();\n        });\n    }\n    /**\n     * onOutputStreamDisconnect is called when device controller wants to detach\n     * the transform device. The default behavior is to stop the output\n     * media stream and release the input the media stream. If the input media stream\n     * is the provided device, it will not be released.\n     */\n    onOutputStreamDisconnect() {\n        this.logger.info('DefaultVideoTransformDevice: detach stopping input media stream');\n        const deviceIsMediaStream = this.device && this.device.id;\n        // Stop processing but keep the pipe and processors\n        this.pipe.stop();\n        // Turn off the camera, unless device is a MediaStream\n        if (!deviceIsMediaStream) {\n            if (this.inputMediaStream) {\n                for (const track of this.inputMediaStream.getVideoTracks()) {\n                    track.stop();\n                }\n            }\n        }\n    }\n    /**\n     * Dispose of the inner workings of the transform device, including pipeline and processors.\n     * `stop` can only be called when the transform device is not used by device controller anymore.\n     * After `stop` is called, all transform devices which share the pipeline must be discarded.\n     */\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.inputMediaStream) {\n                for (const track of this.inputMediaStream.getVideoTracks()) {\n                    track.stop();\n                }\n            }\n            this.pipe.destroy();\n            this.inputMediaStream = null;\n        });\n    }\n    /**\n     * Add an observer to receive notifications about lifecycle events.\n     * See {@link DefaultVideoTransformDeviceObserver} for details.\n     * If the observer has already been added, this method call has no effect.\n     */\n    addObserver(observer) {\n        this.observers.add(observer);\n    }\n    /**\n     * Remove an existing observer. If the observer has not been previously. this method call has no effect.\n     */\n    removeObserver(observer) {\n        this.observers.add(observer);\n    }\n    processingDidStart() {\n        this.logger.info('video transform device processing started');\n        this.forEachObserver(observer => {\n            if (observer.processingDidStart) {\n                observer.processingDidStart();\n            }\n        });\n    }\n    processingLatencyTooHigh(latencyMs) {\n        this.forEachObserver(observer => {\n            if (observer.processingLatencyTooHigh) {\n                observer.processingLatencyTooHigh(latencyMs);\n            }\n        });\n    }\n    processingDidFailToStart() {\n        this.logger.info('video transform device processing failed to start');\n        this.forEachObserver(observer => {\n            if (observer.processingDidFailToStart) {\n                observer.processingDidFailToStart();\n            }\n        });\n    }\n    processingDidStop() {\n        this.logger.info('video transform device processing stopped');\n        this.forEachObserver(observer => {\n            if (observer.processingDidStop) {\n                observer.processingDidStop();\n            }\n        });\n    }\n    forEachObserver(observerFunc) {\n        for (const observer of this.observers) {\n            setTimeout(() => {\n                observerFunc(observer);\n            }, 0);\n        }\n    }\n}\nexports.default = DefaultVideoTransformDevice;\n//# sourceMappingURL=DefaultVideoTransformDevice.js.map"]},"metadata":{},"sourceType":"script"}