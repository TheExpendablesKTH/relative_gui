{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst SDPCandidateType_1 = require(\"./SDPCandidateType\");\n/**\n * Implements [[SDP]]. [[SDP]] also includes a few helper functions for parsing string.\n */\n\n\nclass DefaultSDP {\n  constructor(sdp) {\n    this.sdp = sdp;\n  }\n\n  clone() {\n    return new DefaultSDP(this.sdp);\n  }\n\n  static isRTPCandidate(candidate) {\n    const match = /candidate[:](\\S+) (\\d+)/g.exec(candidate);\n\n    if (match === null || match[2] !== '1') {\n      return false;\n    }\n\n    return true;\n  }\n\n  static linesToSDP(lines) {\n    return new DefaultSDP(lines.join(DefaultSDP.CRLF));\n  }\n\n  static candidateTypeFromString(candidateType) {\n    switch (candidateType) {\n      case SDPCandidateType_1.default.Host:\n        return SDPCandidateType_1.default.Host;\n\n      case SDPCandidateType_1.default.ServerReflexive:\n        return SDPCandidateType_1.default.ServerReflexive;\n\n      case SDPCandidateType_1.default.PeerReflexive:\n        return SDPCandidateType_1.default.PeerReflexive;\n\n      case SDPCandidateType_1.default.Relay:\n        return SDPCandidateType_1.default.Relay;\n    }\n\n    return null;\n  }\n\n  static candidateType(sdpLine) {\n    const match = /a[=]candidate[:].* typ ([a-z]+) /g.exec(sdpLine);\n\n    if (match === null) {\n      return null;\n    }\n\n    return DefaultSDP.candidateTypeFromString(match[1]);\n  }\n\n  static splitLines(blob) {\n    return blob.trim().split('\\n').map(line => {\n      return line.trim();\n    });\n  }\n\n  static splitSections(sdp) {\n    // each section starts with \"m=\"\n    const sections = sdp.split('\\nm=');\n    return sections.map((section, index) => {\n      return (index > 0 ? 'm=' + section : section).trim() + DefaultSDP.CRLF;\n    });\n  }\n\n  static findActiveCameraSection(sections) {\n    let cameraLineIndex = 0;\n    let hasCamera = false;\n\n    for (const sec of sections) {\n      if (/^m=video/.test(sec)) {\n        if (sec.indexOf('sendrecv') > -1) {\n          hasCamera = true;\n          break;\n        }\n      }\n\n      cameraLineIndex++;\n    }\n\n    if (hasCamera === false) {\n      cameraLineIndex = -1;\n    }\n\n    return cameraLineIndex;\n  }\n\n  static parseSSRCMedia(ssrcMediaAttributeLine) {\n    const separator = ssrcMediaAttributeLine.indexOf(' ');\n    let ssrc = 0;\n    let attribute = '';\n    let value = '';\n    ssrc = DefaultSDP.extractSSRCFromAttributeLine(ssrcMediaAttributeLine);\n    const secondColon = ssrcMediaAttributeLine.indexOf(':', separator);\n\n    if (secondColon > -1) {\n      attribute = ssrcMediaAttributeLine.substr(separator + 1, secondColon - separator - 1);\n      value = ssrcMediaAttributeLine.substr(secondColon + 1);\n    } else {\n      attribute = ssrcMediaAttributeLine.substr(separator + 1);\n    }\n\n    return [ssrc, attribute, value];\n  } // a=ssrc-group:<semantics> <ssrc-id> ...\n\n\n  static extractSSRCsFromFIDGroupLine(figGroupLine) {\n    const ssrcStringMatch = /^a=ssrc-group:FID\\s(.+)/.exec(figGroupLine);\n    return ssrcStringMatch[1];\n  } // a=ssrc:<ssrc-id> <attribute> or a=ssrc:<ssrc-id> <attribute>:<value>, ssrc-id is a 32bit integer\n\n\n  static extractSSRCFromAttributeLine(ssrcMediaAttributeLine) {\n    const ssrcStringMatch = /^a=ssrc:([0-9]+)\\s/.exec(ssrcMediaAttributeLine);\n\n    if (ssrcStringMatch === null) {\n      return 0;\n    }\n\n    return parseInt(ssrcStringMatch[1], 10);\n  }\n\n  static matchPrefix(blob, prefix) {\n    return DefaultSDP.splitLines(blob).filter(line => {\n      return line.indexOf(prefix) === 0;\n    });\n  }\n\n  lines() {\n    return this.sdp.split(DefaultSDP.CRLF);\n  }\n\n  hasVideo() {\n    return /^m=video/gm.exec(this.sdp) !== null;\n  }\n\n  hasCandidates() {\n    const match = /a[=]candidate[:]/g.exec(this.sdp);\n\n    if (match === null) {\n      return false;\n    }\n\n    return true;\n  }\n\n  hasCandidatesForAllMLines() {\n    const isAnyCLineUsingLocalHost = this.sdp.indexOf('c=IN IP4 0.0.0.0') > -1;\n    const mLinesHaveCandidates = !isAnyCLineUsingLocalHost;\n    return mLinesHaveCandidates;\n  }\n\n  withBundleAudioVideo() {\n    const srcLines = this.lines();\n    const dstLines = [];\n\n    for (const line of srcLines) {\n      const mod = line.replace(/^a=group:BUNDLE audio$/, 'a=group:BUNDLE audio video');\n\n      if (mod !== line) {\n        dstLines.push(mod);\n        continue;\n      }\n\n      dstLines.push(line);\n    }\n\n    return DefaultSDP.linesToSDP(dstLines);\n  }\n\n  copyVideo(otherSDP) {\n    const otherLines = otherSDP.split(DefaultSDP.CRLF);\n    const dstLines = DefaultSDP.splitLines(this.sdp);\n    let inVideoMedia = false;\n\n    for (const line of otherLines) {\n      if (/^m=video/.test(line)) {\n        inVideoMedia = true;\n      } else if (/^m=/.test(line)) {\n        inVideoMedia = false;\n      }\n\n      if (inVideoMedia) {\n        dstLines.push(line);\n      }\n    }\n\n    return DefaultSDP.linesToSDP(dstLines);\n  }\n\n  withoutCandidateType(candidateTypeToExclude) {\n    return DefaultSDP.linesToSDP(this.lines().filter(line => DefaultSDP.candidateType(line) !== candidateTypeToExclude));\n  }\n\n  withoutServerReflexiveCandidates() {\n    return this.withoutCandidateType(SDPCandidateType_1.default.ServerReflexive);\n  }\n\n  withBandwidthRestriction(maxBitrateKbps, isUnifiedPlan) {\n    const srcLines = this.lines();\n    const dstLines = [];\n\n    for (const line of srcLines) {\n      dstLines.push(line);\n\n      if (/^m=video/.test(line)) {\n        if (isUnifiedPlan) {\n          dstLines.push(`b=TIAS:${maxBitrateKbps * 1000}`);\n        } else {\n          dstLines.push(`b=AS:${maxBitrateKbps}`);\n        }\n      }\n    }\n\n    return DefaultSDP.linesToSDP(dstLines);\n  }\n\n  withAudioMaxAverageBitrate(maxAverageBitrate) {\n    if (!maxAverageBitrate) {\n      return this.clone();\n    }\n\n    maxAverageBitrate = Math.trunc(Math.min(Math.max(maxAverageBitrate, DefaultSDP.rfc7587LowestBitrate), DefaultSDP.rfc7587HighestBitrate));\n    const srcLines = this.lines();\n    const dstLines = [];\n    const opusRtpMapRegex = /^a=rtpmap:\\s*(\\d+)\\s+opus\\/48000/;\n    let lookingForOpusRtpMap = false;\n    let fmtpAttribute = null;\n\n    for (const line of srcLines) {\n      if (line.startsWith('m=audio')) {\n        lookingForOpusRtpMap = true;\n        fmtpAttribute = null;\n      }\n\n      if (line.startsWith('m=video')) {\n        lookingForOpusRtpMap = false;\n        fmtpAttribute = null;\n      }\n\n      if (lookingForOpusRtpMap) {\n        const match = opusRtpMapRegex.exec(line);\n\n        if (match !== null) {\n          fmtpAttribute = `a=fmtp:${match[1]} `;\n          lookingForOpusRtpMap = false;\n        }\n      }\n\n      if (fmtpAttribute && line.startsWith(fmtpAttribute)) {\n        const oldParameters = line.slice(fmtpAttribute.length).split(';');\n        const newParameters = [];\n\n        for (const parameter of oldParameters) {\n          if (!parameter.startsWith('maxaveragebitrate=')) {\n            newParameters.push(parameter);\n          }\n        }\n\n        newParameters.push(`maxaveragebitrate=${maxAverageBitrate}`);\n        dstLines.push(fmtpAttribute + newParameters.join(';'));\n      } else {\n        dstLines.push(line);\n      }\n    }\n\n    return DefaultSDP.linesToSDP(dstLines);\n  } // TODO: will remove this soon.\n\n\n  withUnifiedPlanFormat() {\n    let originalSdp = this.sdp;\n\n    if (originalSdp.includes('mozilla')) {\n      return this.clone();\n    } else {\n      originalSdp = originalSdp.replace('o=-', 'o=mozilla-chrome');\n    }\n\n    return new DefaultSDP(originalSdp);\n  }\n\n  preferH264IfExists() {\n    const srcSDP = this.sdp;\n    const sections = DefaultSDP.splitSections(srcSDP);\n\n    if (sections.length < 2) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    const newSections = [];\n\n    for (let i = 0; i < sections.length; i++) {\n      if (/^m=video/.test(sections[i])) {\n        const lines = DefaultSDP.splitLines(sections[i]);\n        let payloadTypeForVP8 = 0;\n        let payloadTypeForH264 = 0;\n        lines.forEach(attribute => {\n          if (/^a=rtpmap:/.test(attribute)) {\n            const payloadMatch = /^a=rtpmap:([0-9]+)\\s/.exec(attribute);\n\n            if (attribute.toLowerCase().includes('vp8')) {\n              payloadTypeForVP8 = parseInt(payloadMatch[1], 10);\n            } else if (attribute.toLowerCase().includes('h264')) {\n              payloadTypeForH264 = parseInt(payloadMatch[1], 10);\n            }\n          }\n        }); // m=video 9 UDP/+++ <payload>\n\n        if (payloadTypeForVP8 !== 0 && payloadTypeForH264 !== 0) {\n          const mline = lines[0].split(' ');\n          let indexForVP8 = -1;\n          let indexForH264 = -1;\n\n          for (let i = 3; i < mline.length; i++) {\n            const payload = parseInt(mline[i], 10);\n\n            if (payload === payloadTypeForVP8) {\n              indexForVP8 = i;\n            } else if (payload === payloadTypeForH264) {\n              indexForH264 = i;\n            }\n          }\n\n          if (indexForVP8 < indexForH264) {\n            mline[indexForVP8] = payloadTypeForH264.toString();\n            mline[indexForH264] = payloadTypeForVP8.toString();\n          }\n\n          lines[0] = mline.join(' ');\n        }\n\n        sections[i] = lines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF; // since there is only H264 or VP8, we don't switch payload places\n      }\n\n      newSections.push(sections[i]);\n    }\n\n    const newSdp = newSections.join('');\n    return new DefaultSDP(newSdp);\n  }\n\n  withOldFashionedMungingSimulcast(videoSimulcastLayerCount) {\n    if (videoSimulcastLayerCount < 2) {\n      return this.clone();\n    }\n\n    const srcSDP = this.sdp;\n    const sections = DefaultSDP.splitSections(srcSDP);\n\n    if (sections.length < 2) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    const cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n\n    if (cameraLineIndex === -1) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    let cname = '';\n    let msid = '';\n    DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc:').forEach(line => {\n      const ssrcAttrTuple = DefaultSDP.parseSSRCMedia(line);\n\n      if (ssrcAttrTuple[1] === 'cname') {\n        cname = ssrcAttrTuple[2];\n      } else if (ssrcAttrTuple[1] === 'msid') {\n        msid = ssrcAttrTuple[2];\n      }\n    });\n    const fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n\n    if (cname === '' || msid === '' || fidGroupMatch.length < 1) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    const fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n    const cameraSectionLines = sections[cameraLineIndex].trim().split(DefaultSDP.CRLF).filter(line => {\n      return line.indexOf('a=ssrc:') !== 0 && line.indexOf('a=ssrc-group:') !== 0;\n    });\n    const simulcastSSRCs = [];\n    const [videoSSRC1, rtxSSRC1] = fidGroup.split(' ').map(ssrc => parseInt(ssrc, 10));\n    let videoSSRC = videoSSRC1;\n    let rtxSSRC = rtxSSRC1;\n\n    for (let i = 0; i < videoSimulcastLayerCount; i++) {\n      cameraSectionLines.push('a=ssrc:' + videoSSRC + ' cname:' + cname);\n      cameraSectionLines.push('a=ssrc:' + videoSSRC + ' msid:' + msid);\n      cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' cname:' + cname);\n      cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' msid:' + msid);\n      cameraSectionLines.push('a=ssrc-group:FID ' + videoSSRC + ' ' + rtxSSRC);\n      simulcastSSRCs.push(videoSSRC);\n      videoSSRC = videoSSRC + 1;\n      rtxSSRC = videoSSRC + 1;\n    }\n\n    cameraSectionLines.push('a=ssrc-group:SIM ' + simulcastSSRCs.join(' '));\n    sections[cameraLineIndex] = cameraSectionLines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF;\n    const newSDP = sections.join('');\n    return new DefaultSDP(newSDP);\n  }\n\n  ssrcForVideoSendingSection() {\n    const srcSDP = this.sdp;\n    const sections = DefaultSDP.splitSections(srcSDP);\n\n    if (sections.length < 2) {\n      return '';\n    }\n\n    const cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n\n    if (cameraLineIndex === -1) {\n      return '';\n    } // TODO: match for Firefox. Currently all failures are not Firefox induced.\n\n\n    const fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n\n    if (fidGroupMatch.length < 1) {\n      return '';\n    }\n\n    const fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n    const [videoSSRC1] = fidGroup.split(' ').map(ssrc => parseInt(ssrc, 10));\n    return videoSSRC1.toString();\n  }\n\n  videoSendSectionHasDifferentSSRC(prevSdp) {\n    const ssrc1 = this.ssrcForVideoSendingSection();\n    const ssrc2 = prevSdp.ssrcForVideoSendingSection();\n\n    if (ssrc1 === '' || ssrc2 === '') {\n      return false;\n    }\n\n    const ssrc1InNumber = parseInt(ssrc1, 10);\n    const ssrc2InNumber = parseInt(ssrc2, 10);\n\n    if (ssrc1InNumber === ssrc2InNumber) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nexports.default = DefaultSDP;\nDefaultSDP.CRLF = '\\r\\n';\nDefaultSDP.rfc7587LowestBitrate = 6000;\nDefaultSDP.rfc7587HighestBitrate = 510000;","map":{"version":3,"sources":["../../src/sdp/DefaultSDP.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;AAGA,MAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAEA;;AAEG;;;AACH,MAAqB,UAArB,CAA+B;AAM7B,EAAA,WAAA,CAAmB,GAAnB,EAA8B;AAAX,SAAA,GAAA,GAAA,GAAA;AAAe;;AAElC,EAAA,KAAK,GAAA;AACH,WAAO,IAAI,UAAJ,CAAe,KAAK,GAApB,CAAP;AACD;;AAEoB,SAAd,cAAc,CAAC,SAAD,EAAkB;AACrC,UAAM,KAAK,GAAG,2BAA2B,IAA3B,CAAgC,SAAhC,CAAd;;AACA,QAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,CAAC,CAAD,CAAL,KAAa,GAAnC,EAAwC;AACtC,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD;;AAEgB,SAAV,UAAU,CAAC,KAAD,EAAgB;AAC/B,WAAO,IAAI,UAAJ,CAAe,KAAK,CAAC,IAAN,CAAW,UAAU,CAAC,IAAtB,CAAf,CAAP;AACD;;AAE6B,SAAvB,uBAAuB,CAAC,aAAD,EAAsB;AAClD,YAAQ,aAAR;AACE,WAAK,kBAAA,CAAA,OAAA,CAAiB,IAAtB;AACE,eAAO,kBAAA,CAAA,OAAA,CAAiB,IAAxB;;AACF,WAAK,kBAAA,CAAA,OAAA,CAAiB,eAAtB;AACE,eAAO,kBAAA,CAAA,OAAA,CAAiB,eAAxB;;AACF,WAAK,kBAAA,CAAA,OAAA,CAAiB,aAAtB;AACE,eAAO,kBAAA,CAAA,OAAA,CAAiB,aAAxB;;AACF,WAAK,kBAAA,CAAA,OAAA,CAAiB,KAAtB;AACE,eAAO,kBAAA,CAAA,OAAA,CAAiB,KAAxB;AARJ;;AAUA,WAAO,IAAP;AACD;;AAEmB,SAAb,aAAa,CAAC,OAAD,EAAgB;AAClC,UAAM,KAAK,GAAG,oCAAoC,IAApC,CAAyC,OAAzC,CAAd;;AACA,QAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAO,IAAP;AACD;;AACD,WAAO,UAAU,CAAC,uBAAX,CAAmC,KAAK,CAAC,CAAD,CAAxC,CAAP;AACD;;AAEgB,SAAV,UAAU,CAAC,IAAD,EAAa;AAC5B,WAAO,IAAI,CACR,IADI,GAEJ,KAFI,CAEE,IAFF,EAGJ,GAHI,CAGC,IAAD,IAAiB;AACpB,aAAO,IAAI,CAAC,IAAL,EAAP;AACD,KALI,CAAP;AAMD;;AAEmB,SAAb,aAAa,CAAC,GAAD,EAAY;AAC9B;AACA,UAAM,QAAQ,GAAG,GAAG,CAAC,KAAJ,CAAU,MAAV,CAAjB;AACA,WAAO,QAAQ,CAAC,GAAT,CAAa,CAAC,OAAD,EAAkB,KAAlB,KAAmC;AACrD,aAAO,CAAC,KAAK,GAAG,CAAR,GAAY,OAAO,OAAnB,GAA6B,OAA9B,EAAuC,IAAvC,KAAgD,UAAU,CAAC,IAAlE;AACD,KAFM,CAAP;AAGD;;AAE6B,SAAvB,uBAAuB,CAAC,QAAD,EAAmB;AAC/C,QAAI,eAAe,GAAG,CAAtB;AACA,QAAI,SAAS,GAAG,KAAhB;;AACA,SAAK,MAAM,GAAX,IAAkB,QAAlB,EAA4B;AAC1B,UAAI,WAAW,IAAX,CAAgB,GAAhB,CAAJ,EAA0B;AACxB,YAAI,GAAG,CAAC,OAAJ,CAAY,UAAZ,IAA0B,CAAC,CAA/B,EAAkC;AAChC,UAAA,SAAS,GAAG,IAAZ;AACA;AACD;AACF;;AACD,MAAA,eAAe;AAChB;;AAED,QAAI,SAAS,KAAK,KAAlB,EAAyB;AACvB,MAAA,eAAe,GAAG,CAAC,CAAnB;AACD;;AACD,WAAO,eAAP;AACD;;AAEoB,SAAd,cAAc,CAAC,sBAAD,EAA+B;AAClD,UAAM,SAAS,GAAG,sBAAsB,CAAC,OAAvB,CAA+B,GAA/B,CAAlB;AACA,QAAI,IAAI,GAAG,CAAX;AACA,QAAI,SAAS,GAAG,EAAhB;AACA,QAAI,KAAK,GAAG,EAAZ;AAEA,IAAA,IAAI,GAAG,UAAU,CAAC,4BAAX,CAAwC,sBAAxC,CAAP;AACA,UAAM,WAAW,GAAG,sBAAsB,CAAC,OAAvB,CAA+B,GAA/B,EAAoC,SAApC,CAApB;;AACA,QAAI,WAAW,GAAG,CAAC,CAAnB,EAAsB;AACpB,MAAA,SAAS,GAAG,sBAAsB,CAAC,MAAvB,CAA8B,SAAS,GAAG,CAA1C,EAA6C,WAAW,GAAG,SAAd,GAA0B,CAAvE,CAAZ;AACA,MAAA,KAAK,GAAG,sBAAsB,CAAC,MAAvB,CAA8B,WAAW,GAAG,CAA5C,CAAR;AACD,KAHD,MAGO;AACL,MAAA,SAAS,GAAG,sBAAsB,CAAC,MAAvB,CAA8B,SAAS,GAAG,CAA1C,CAAZ;AACD;;AACD,WAAO,CAAC,IAAD,EAAO,SAAP,EAAkB,KAAlB,CAAP;AACD,GAjG4B,CAmG7B;;;AACmC,SAA5B,4BAA4B,CAAC,YAAD,EAAqB;AACtD,UAAM,eAAe,GAAG,0BAA0B,IAA1B,CAA+B,YAA/B,CAAxB;AACA,WAAO,eAAe,CAAC,CAAD,CAAtB;AACD,GAvG4B,CAyG7B;;;AACmC,SAA5B,4BAA4B,CAAC,sBAAD,EAA+B;AAChE,UAAM,eAAe,GAAG,qBAAqB,IAArB,CAA0B,sBAA1B,CAAxB;;AACA,QAAI,eAAe,KAAK,IAAxB,EAA8B;AAC5B,aAAO,CAAP;AACD;;AACD,WAAO,QAAQ,CAAC,eAAe,CAAC,CAAD,CAAhB,EAAqB,EAArB,CAAf;AACD;;AAEiB,SAAX,WAAW,CAAC,IAAD,EAAe,MAAf,EAA6B;AAC7C,WAAO,UAAU,CAAC,UAAX,CAAsB,IAAtB,EAA4B,MAA5B,CAAoC,IAAD,IAAiB;AACzD,aAAO,IAAI,CAAC,OAAL,CAAa,MAAb,MAAyB,CAAhC;AACD,KAFM,CAAP;AAGD;;AAED,EAAA,KAAK,GAAA;AACH,WAAO,KAAK,GAAL,CAAS,KAAT,CAAe,UAAU,CAAC,IAA1B,CAAP;AACD;;AAED,EAAA,QAAQ,GAAA;AACN,WAAO,aAAa,IAAb,CAAkB,KAAK,GAAvB,MAAgC,IAAvC;AACD;;AAED,EAAA,aAAa,GAAA;AACX,UAAM,KAAK,GAAG,oBAAoB,IAApB,CAAyB,KAAK,GAA9B,CAAd;;AACA,QAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD;;AAED,EAAA,yBAAyB,GAAA;AACvB,UAAM,wBAAwB,GAAG,KAAK,GAAL,CAAS,OAAT,CAAiB,kBAAjB,IAAuC,CAAC,CAAzE;AACA,UAAM,oBAAoB,GAAG,CAAC,wBAA9B;AACA,WAAO,oBAAP;AACD;;AAED,EAAA,oBAAoB,GAAA;AAClB,UAAM,QAAQ,GAAG,KAAK,KAAL,EAAjB;AACA,UAAM,QAAQ,GAAa,EAA3B;;AACA,SAAK,MAAM,IAAX,IAAmB,QAAnB,EAA6B;AAC3B,YAAM,GAAG,GAAG,IAAI,CAAC,OAAL,CAAa,wBAAb,EAAuC,4BAAvC,CAAZ;;AACA,UAAI,GAAG,KAAK,IAAZ,EAAkB;AAChB,QAAA,QAAQ,CAAC,IAAT,CAAc,GAAd;AACA;AACD;;AACD,MAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;AACD;;AACD,WAAO,UAAU,CAAC,UAAX,CAAsB,QAAtB,CAAP;AACD;;AAED,EAAA,SAAS,CAAC,QAAD,EAAiB;AACxB,UAAM,UAAU,GAAa,QAAQ,CAAC,KAAT,CAAe,UAAU,CAAC,IAA1B,CAA7B;AACA,UAAM,QAAQ,GAAa,UAAU,CAAC,UAAX,CAAsB,KAAK,GAA3B,CAA3B;AACA,QAAI,YAAY,GAAG,KAAnB;;AACA,SAAK,MAAM,IAAX,IAAmB,UAAnB,EAA+B;AAC7B,UAAI,WAAW,IAAX,CAAgB,IAAhB,CAAJ,EAA2B;AACzB,QAAA,YAAY,GAAG,IAAf;AACD,OAFD,MAEO,IAAI,MAAM,IAAN,CAAW,IAAX,CAAJ,EAAsB;AAC3B,QAAA,YAAY,GAAG,KAAf;AACD;;AACD,UAAI,YAAJ,EAAkB;AAChB,QAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;AACD;AACF;;AACD,WAAO,UAAU,CAAC,UAAX,CAAsB,QAAtB,CAAP;AACD;;AAED,EAAA,oBAAoB,CAAC,sBAAD,EAAyC;AAC3D,WAAO,UAAU,CAAC,UAAX,CACL,KAAK,KAAL,GAAa,MAAb,CAAoB,IAAI,IAAI,UAAU,CAAC,aAAX,CAAyB,IAAzB,MAAmC,sBAA/D,CADK,CAAP;AAGD;;AAED,EAAA,gCAAgC,GAAA;AAC9B,WAAO,KAAK,oBAAL,CAA0B,kBAAA,CAAA,OAAA,CAAiB,eAA3C,CAAP;AACD;;AAED,EAAA,wBAAwB,CAAC,cAAD,EAAyB,aAAzB,EAA+C;AACrE,UAAM,QAAQ,GAAa,KAAK,KAAL,EAA3B;AACA,UAAM,QAAQ,GAAa,EAA3B;;AACA,SAAK,MAAM,IAAX,IAAmB,QAAnB,EAA6B;AAC3B,MAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;;AACA,UAAI,WAAW,IAAX,CAAgB,IAAhB,CAAJ,EAA2B;AACzB,YAAI,aAAJ,EAAmB;AACjB,UAAA,QAAQ,CAAC,IAAT,CAAc,UAAU,cAAc,GAAG,IAAI,EAA7C;AACD,SAFD,MAEO;AACL,UAAA,QAAQ,CAAC,IAAT,CAAc,QAAQ,cAAc,EAApC;AACD;AACF;AACF;;AACD,WAAO,UAAU,CAAC,UAAX,CAAsB,QAAtB,CAAP;AACD;;AAED,EAAA,0BAA0B,CAAC,iBAAD,EAAiC;AACzD,QAAI,CAAC,iBAAL,EAAwB;AACtB,aAAO,KAAK,KAAL,EAAP;AACD;;AACD,IAAA,iBAAiB,GAAG,IAAI,CAAC,KAAL,CAClB,IAAI,CAAC,GAAL,CACE,IAAI,CAAC,GAAL,CAAS,iBAAT,EAA4B,UAAU,CAAC,oBAAvC,CADF,EAEE,UAAU,CAAC,qBAFb,CADkB,CAApB;AAMA,UAAM,QAAQ,GAAa,KAAK,KAAL,EAA3B;AACA,UAAM,QAAQ,GAAa,EAA3B;AACA,UAAM,eAAe,GAAG,kCAAxB;AACA,QAAI,oBAAoB,GAAG,KAA3B;AACA,QAAI,aAAa,GAAkB,IAAnC;;AACA,SAAK,MAAM,IAAX,IAAmB,QAAnB,EAA6B;AAC3B,UAAI,IAAI,CAAC,UAAL,CAAgB,SAAhB,CAAJ,EAAgC;AAC9B,QAAA,oBAAoB,GAAG,IAAvB;AACA,QAAA,aAAa,GAAG,IAAhB;AACD;;AACD,UAAI,IAAI,CAAC,UAAL,CAAgB,SAAhB,CAAJ,EAAgC;AAC9B,QAAA,oBAAoB,GAAG,KAAvB;AACA,QAAA,aAAa,GAAG,IAAhB;AACD;;AACD,UAAI,oBAAJ,EAA0B;AACxB,cAAM,KAAK,GAAG,eAAe,CAAC,IAAhB,CAAqB,IAArB,CAAd;;AACA,YAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,UAAA,aAAa,GAAG,UAAU,KAAK,CAAC,CAAD,CAAG,GAAlC;AACA,UAAA,oBAAoB,GAAG,KAAvB;AACD;AACF;;AACD,UAAI,aAAa,IAAI,IAAI,CAAC,UAAL,CAAgB,aAAhB,CAArB,EAAqD;AACnD,cAAM,aAAa,GAAa,IAAI,CAAC,KAAL,CAAW,aAAa,CAAC,MAAzB,EAAiC,KAAjC,CAAuC,GAAvC,CAAhC;AACA,cAAM,aAAa,GAAa,EAAhC;;AACA,aAAK,MAAM,SAAX,IAAwB,aAAxB,EAAuC;AACrC,cAAI,CAAC,SAAS,CAAC,UAAV,CAAqB,oBAArB,CAAL,EAAiD;AAC/C,YAAA,aAAa,CAAC,IAAd,CAAmB,SAAnB;AACD;AACF;;AACD,QAAA,aAAa,CAAC,IAAd,CAAmB,qBAAqB,iBAAiB,EAAzD;AACA,QAAA,QAAQ,CAAC,IAAT,CAAc,aAAa,GAAG,aAAa,CAAC,IAAd,CAAmB,GAAnB,CAA9B;AACD,OAVD,MAUO;AACL,QAAA,QAAQ,CAAC,IAAT,CAAc,IAAd;AACD;AACF;;AACD,WAAO,UAAU,CAAC,UAAX,CAAsB,QAAtB,CAAP;AACD,GArP4B,CAuP7B;;;AACA,EAAA,qBAAqB,GAAA;AACnB,QAAI,WAAW,GAAG,KAAK,GAAvB;;AACA,QAAI,WAAW,CAAC,QAAZ,CAAqB,SAArB,CAAJ,EAAqC;AACnC,aAAO,KAAK,KAAL,EAAP;AACD,KAFD,MAEO;AACL,MAAA,WAAW,GAAG,WAAW,CAAC,OAAZ,CAAoB,KAApB,EAA2B,kBAA3B,CAAd;AACD;;AAED,WAAO,IAAI,UAAJ,CAAe,WAAf,CAAP;AACD;;AAED,EAAA,kBAAkB,GAAA;AAChB,UAAM,MAAM,GAAW,KAAK,GAA5B;AACA,UAAM,QAAQ,GAAG,UAAU,CAAC,aAAX,CAAyB,MAAzB,CAAjB;;AACA,QAAI,QAAQ,CAAC,MAAT,GAAkB,CAAtB,EAAyB;AACvB,aAAO,IAAI,UAAJ,CAAe,KAAK,GAApB,CAAP;AACD;;AACD,UAAM,WAAW,GAAG,EAApB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACxC,UAAI,WAAW,IAAX,CAAgB,QAAQ,CAAC,CAAD,CAAxB,CAAJ,EAAkC;AAChC,cAAM,KAAK,GAAG,UAAU,CAAC,UAAX,CAAsB,QAAQ,CAAC,CAAD,CAA9B,CAAd;AACA,YAAI,iBAAiB,GAAG,CAAxB;AACA,YAAI,kBAAkB,GAAG,CAAzB;AACA,QAAA,KAAK,CAAC,OAAN,CAAc,SAAS,IAAG;AACxB,cAAI,aAAa,IAAb,CAAkB,SAAlB,CAAJ,EAAkC;AAChC,kBAAM,YAAY,GAAG,uBAAuB,IAAvB,CAA4B,SAA5B,CAArB;;AACA,gBAAI,SAAS,CAAC,WAAV,GAAwB,QAAxB,CAAiC,KAAjC,CAAJ,EAA6C;AAC3C,cAAA,iBAAiB,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAD,CAAb,EAAkB,EAAlB,CAA5B;AACD,aAFD,MAEO,IAAI,SAAS,CAAC,WAAV,GAAwB,QAAxB,CAAiC,MAAjC,CAAJ,EAA8C;AACnD,cAAA,kBAAkB,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAD,CAAb,EAAkB,EAAlB,CAA7B;AACD;AACF;AACF,SATD,EAJgC,CAehC;;AACA,YAAI,iBAAiB,KAAK,CAAtB,IAA2B,kBAAkB,KAAK,CAAtD,EAAyD;AACvD,gBAAM,KAAK,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,KAAT,CAAe,GAAf,CAAd;AACA,cAAI,WAAW,GAAG,CAAC,CAAnB;AACA,cAAI,YAAY,GAAG,CAAC,CAApB;;AACA,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACrC,kBAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAxB;;AACA,gBAAI,OAAO,KAAK,iBAAhB,EAAmC;AACjC,cAAA,WAAW,GAAG,CAAd;AACD,aAFD,MAEO,IAAI,OAAO,KAAK,kBAAhB,EAAoC;AACzC,cAAA,YAAY,GAAG,CAAf;AACD;AACF;;AAED,cAAI,WAAW,GAAG,YAAlB,EAAgC;AAC9B,YAAA,KAAK,CAAC,WAAD,CAAL,GAAqB,kBAAkB,CAAC,QAAnB,EAArB;AACA,YAAA,KAAK,CAAC,YAAD,CAAL,GAAsB,iBAAiB,CAAC,QAAlB,EAAtB;AACD;;AACD,UAAA,KAAK,CAAC,CAAD,CAAL,GAAW,KAAK,CAAC,IAAN,CAAW,GAAX,CAAX;AACD;;AACD,QAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,KAAK,CAAC,IAAN,CAAW,UAAU,CAAC,IAAtB,IAA8B,UAAU,CAAC,IAAvD,CAnCgC,CAoChC;AACD;;AACD,MAAA,WAAW,CAAC,IAAZ,CAAiB,QAAQ,CAAC,CAAD,CAAzB;AACD;;AAED,UAAM,MAAM,GAAG,WAAW,CAAC,IAAZ,CAAiB,EAAjB,CAAf;AACA,WAAO,IAAI,UAAJ,CAAe,MAAf,CAAP;AACD;;AAED,EAAA,gCAAgC,CAAC,wBAAD,EAAiC;AAC/D,QAAI,wBAAwB,GAAG,CAA/B,EAAkC;AAChC,aAAO,KAAK,KAAL,EAAP;AACD;;AAED,UAAM,MAAM,GAAW,KAAK,GAA5B;AACA,UAAM,QAAQ,GAAG,UAAU,CAAC,aAAX,CAAyB,MAAzB,CAAjB;;AACA,QAAI,QAAQ,CAAC,MAAT,GAAkB,CAAtB,EAAyB;AACvB,aAAO,IAAI,UAAJ,CAAe,KAAK,GAApB,CAAP;AACD;;AAED,UAAM,eAAe,GAAW,UAAU,CAAC,uBAAX,CAAmC,QAAnC,CAAhC;;AACA,QAAI,eAAe,KAAK,CAAC,CAAzB,EAA4B;AAC1B,aAAO,IAAI,UAAJ,CAAe,KAAK,GAApB,CAAP;AACD;;AAED,QAAI,KAAK,GAAG,EAAZ;AACA,QAAI,IAAI,GAAG,EAAX;AACA,IAAA,UAAU,CAAC,WAAX,CAAuB,QAAQ,CAAC,eAAD,CAA/B,EAAkD,SAAlD,EAA6D,OAA7D,CAAsE,IAAD,IAAiB;AACpF,YAAM,aAAa,GAAG,UAAU,CAAC,cAAX,CAA0B,IAA1B,CAAtB;;AACA,UAAI,aAAa,CAAC,CAAD,CAAb,KAAqB,OAAzB,EAAkC;AAChC,QAAA,KAAK,GAAG,aAAa,CAAC,CAAD,CAArB;AACD,OAFD,MAEO,IAAI,aAAa,CAAC,CAAD,CAAb,KAAqB,MAAzB,EAAiC;AACtC,QAAA,IAAI,GAAG,aAAa,CAAC,CAAD,CAApB;AACD;AACF,KAPD;AASA,UAAM,aAAa,GAAG,UAAU,CAAC,WAAX,CAAuB,QAAQ,CAAC,eAAD,CAA/B,EAAkD,mBAAlD,CAAtB;;AACA,QAAI,KAAK,KAAK,EAAV,IAAgB,IAAI,KAAK,EAAzB,IAA+B,aAAa,CAAC,MAAd,GAAuB,CAA1D,EAA6D;AAC3D,aAAO,IAAI,UAAJ,CAAe,KAAK,GAApB,CAAP;AACD;;AAED,UAAM,QAAQ,GAAG,UAAU,CAAC,4BAAX,CAAwC,aAAa,CAAC,CAAD,CAArD,CAAjB;AACA,UAAM,kBAAkB,GAAG,QAAQ,CAAC,eAAD,CAAR,CACxB,IADwB,GAExB,KAFwB,CAElB,UAAU,CAAC,IAFO,EAGxB,MAHwB,CAGhB,IAAD,IAAiB;AACvB,aAAO,IAAI,CAAC,OAAL,CAAa,SAAb,MAA4B,CAA5B,IAAiC,IAAI,CAAC,OAAL,CAAa,eAAb,MAAkC,CAA1E;AACD,KALwB,CAA3B;AAOA,UAAM,cAAc,GAAG,EAAvB;AACA,UAAM,CAAC,UAAD,EAAa,QAAb,IAAyB,QAAQ,CAAC,KAAT,CAAe,GAAf,EAAoB,GAApB,CAAwB,IAAI,IAAI,QAAQ,CAAC,IAAD,EAAO,EAAP,CAAxC,CAA/B;AAEA,QAAI,SAAS,GAAG,UAAhB;AACA,QAAI,OAAO,GAAG,QAAd;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,wBAApB,EAA8C,CAAC,EAA/C,EAAmD;AACjD,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,YAAY,SAAZ,GAAwB,SAAxB,GAAoC,KAA5D;AACA,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,YAAY,SAAZ,GAAwB,QAAxB,GAAmC,IAA3D;AACA,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,YAAY,OAAZ,GAAsB,SAAtB,GAAkC,KAA1D;AACA,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,YAAY,OAAZ,GAAsB,QAAtB,GAAiC,IAAzD;AACA,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,sBAAsB,SAAtB,GAAkC,GAAlC,GAAwC,OAAhE;AACA,MAAA,cAAc,CAAC,IAAf,CAAoB,SAApB;AACA,MAAA,SAAS,GAAG,SAAS,GAAG,CAAxB;AACA,MAAA,OAAO,GAAG,SAAS,GAAG,CAAtB;AACD;;AAED,IAAA,kBAAkB,CAAC,IAAnB,CAAwB,sBAAsB,cAAc,CAAC,IAAf,CAAoB,GAApB,CAA9C;AACA,IAAA,QAAQ,CAAC,eAAD,CAAR,GAA4B,kBAAkB,CAAC,IAAnB,CAAwB,UAAU,CAAC,IAAnC,IAA2C,UAAU,CAAC,IAAlF;AAEA,UAAM,MAAM,GAAG,QAAQ,CAAC,IAAT,CAAc,EAAd,CAAf;AACA,WAAO,IAAI,UAAJ,CAAe,MAAf,CAAP;AACD;;AAED,EAAA,0BAA0B,GAAA;AACxB,UAAM,MAAM,GAAW,KAAK,GAA5B;AACA,UAAM,QAAQ,GAAG,UAAU,CAAC,aAAX,CAAyB,MAAzB,CAAjB;;AACA,QAAI,QAAQ,CAAC,MAAT,GAAkB,CAAtB,EAAyB;AACvB,aAAO,EAAP;AACD;;AAED,UAAM,eAAe,GAAW,UAAU,CAAC,uBAAX,CAAmC,QAAnC,CAAhC;;AACA,QAAI,eAAe,KAAK,CAAC,CAAzB,EAA4B;AAC1B,aAAO,EAAP;AACD,KAVuB,CAYxB;;;AACA,UAAM,aAAa,GAAG,UAAU,CAAC,WAAX,CAAuB,QAAQ,CAAC,eAAD,CAA/B,EAAkD,mBAAlD,CAAtB;;AACA,QAAI,aAAa,CAAC,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,aAAO,EAAP;AACD;;AAED,UAAM,QAAQ,GAAG,UAAU,CAAC,4BAAX,CAAwC,aAAa,CAAC,CAAD,CAArD,CAAjB;AACA,UAAM,CAAC,UAAD,IAAe,QAAQ,CAAC,KAAT,CAAe,GAAf,EAAoB,GAApB,CAAwB,IAAI,IAAI,QAAQ,CAAC,IAAD,EAAO,EAAP,CAAxC,CAArB;AAEA,WAAO,UAAU,CAAC,QAAX,EAAP;AACD;;AAED,EAAA,gCAAgC,CAAC,OAAD,EAAa;AAC3C,UAAM,KAAK,GAAG,KAAK,0BAAL,EAAd;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,0BAAR,EAAd;;AACA,QAAI,KAAK,KAAK,EAAV,IAAgB,KAAK,KAAK,EAA9B,EAAkC;AAChC,aAAO,KAAP;AACD;;AACD,UAAM,aAAa,GAAG,QAAQ,CAAC,KAAD,EAAQ,EAAR,CAA9B;AACA,UAAM,aAAa,GAAG,QAAQ,CAAC,KAAD,EAAQ,EAAR,CAA9B;;AACA,QAAI,aAAa,KAAK,aAAtB,EAAqC;AACnC,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD;;AA3Z4B;;AAA/B,OAAA,CAAA,OAAA,GAAA,UAAA;AACiB,UAAA,CAAA,IAAA,GAAe,MAAf;AAER,UAAA,CAAA,oBAAA,GAAuB,IAAvB;AACA,UAAA,CAAA,qBAAA,GAAwB,MAAxB","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SDPCandidateType_1 = require(\"./SDPCandidateType\");\n/**\n * Implements [[SDP]]. [[SDP]] also includes a few helper functions for parsing string.\n */\nclass DefaultSDP {\n    constructor(sdp) {\n        this.sdp = sdp;\n    }\n    clone() {\n        return new DefaultSDP(this.sdp);\n    }\n    static isRTPCandidate(candidate) {\n        const match = /candidate[:](\\S+) (\\d+)/g.exec(candidate);\n        if (match === null || match[2] !== '1') {\n            return false;\n        }\n        return true;\n    }\n    static linesToSDP(lines) {\n        return new DefaultSDP(lines.join(DefaultSDP.CRLF));\n    }\n    static candidateTypeFromString(candidateType) {\n        switch (candidateType) {\n            case SDPCandidateType_1.default.Host:\n                return SDPCandidateType_1.default.Host;\n            case SDPCandidateType_1.default.ServerReflexive:\n                return SDPCandidateType_1.default.ServerReflexive;\n            case SDPCandidateType_1.default.PeerReflexive:\n                return SDPCandidateType_1.default.PeerReflexive;\n            case SDPCandidateType_1.default.Relay:\n                return SDPCandidateType_1.default.Relay;\n        }\n        return null;\n    }\n    static candidateType(sdpLine) {\n        const match = /a[=]candidate[:].* typ ([a-z]+) /g.exec(sdpLine);\n        if (match === null) {\n            return null;\n        }\n        return DefaultSDP.candidateTypeFromString(match[1]);\n    }\n    static splitLines(blob) {\n        return blob\n            .trim()\n            .split('\\n')\n            .map((line) => {\n            return line.trim();\n        });\n    }\n    static splitSections(sdp) {\n        // each section starts with \"m=\"\n        const sections = sdp.split('\\nm=');\n        return sections.map((section, index) => {\n            return (index > 0 ? 'm=' + section : section).trim() + DefaultSDP.CRLF;\n        });\n    }\n    static findActiveCameraSection(sections) {\n        let cameraLineIndex = 0;\n        let hasCamera = false;\n        for (const sec of sections) {\n            if (/^m=video/.test(sec)) {\n                if (sec.indexOf('sendrecv') > -1) {\n                    hasCamera = true;\n                    break;\n                }\n            }\n            cameraLineIndex++;\n        }\n        if (hasCamera === false) {\n            cameraLineIndex = -1;\n        }\n        return cameraLineIndex;\n    }\n    static parseSSRCMedia(ssrcMediaAttributeLine) {\n        const separator = ssrcMediaAttributeLine.indexOf(' ');\n        let ssrc = 0;\n        let attribute = '';\n        let value = '';\n        ssrc = DefaultSDP.extractSSRCFromAttributeLine(ssrcMediaAttributeLine);\n        const secondColon = ssrcMediaAttributeLine.indexOf(':', separator);\n        if (secondColon > -1) {\n            attribute = ssrcMediaAttributeLine.substr(separator + 1, secondColon - separator - 1);\n            value = ssrcMediaAttributeLine.substr(secondColon + 1);\n        }\n        else {\n            attribute = ssrcMediaAttributeLine.substr(separator + 1);\n        }\n        return [ssrc, attribute, value];\n    }\n    // a=ssrc-group:<semantics> <ssrc-id> ...\n    static extractSSRCsFromFIDGroupLine(figGroupLine) {\n        const ssrcStringMatch = /^a=ssrc-group:FID\\s(.+)/.exec(figGroupLine);\n        return ssrcStringMatch[1];\n    }\n    // a=ssrc:<ssrc-id> <attribute> or a=ssrc:<ssrc-id> <attribute>:<value>, ssrc-id is a 32bit integer\n    static extractSSRCFromAttributeLine(ssrcMediaAttributeLine) {\n        const ssrcStringMatch = /^a=ssrc:([0-9]+)\\s/.exec(ssrcMediaAttributeLine);\n        if (ssrcStringMatch === null) {\n            return 0;\n        }\n        return parseInt(ssrcStringMatch[1], 10);\n    }\n    static matchPrefix(blob, prefix) {\n        return DefaultSDP.splitLines(blob).filter((line) => {\n            return line.indexOf(prefix) === 0;\n        });\n    }\n    lines() {\n        return this.sdp.split(DefaultSDP.CRLF);\n    }\n    hasVideo() {\n        return /^m=video/gm.exec(this.sdp) !== null;\n    }\n    hasCandidates() {\n        const match = /a[=]candidate[:]/g.exec(this.sdp);\n        if (match === null) {\n            return false;\n        }\n        return true;\n    }\n    hasCandidatesForAllMLines() {\n        const isAnyCLineUsingLocalHost = this.sdp.indexOf('c=IN IP4 0.0.0.0') > -1;\n        const mLinesHaveCandidates = !isAnyCLineUsingLocalHost;\n        return mLinesHaveCandidates;\n    }\n    withBundleAudioVideo() {\n        const srcLines = this.lines();\n        const dstLines = [];\n        for (const line of srcLines) {\n            const mod = line.replace(/^a=group:BUNDLE audio$/, 'a=group:BUNDLE audio video');\n            if (mod !== line) {\n                dstLines.push(mod);\n                continue;\n            }\n            dstLines.push(line);\n        }\n        return DefaultSDP.linesToSDP(dstLines);\n    }\n    copyVideo(otherSDP) {\n        const otherLines = otherSDP.split(DefaultSDP.CRLF);\n        const dstLines = DefaultSDP.splitLines(this.sdp);\n        let inVideoMedia = false;\n        for (const line of otherLines) {\n            if (/^m=video/.test(line)) {\n                inVideoMedia = true;\n            }\n            else if (/^m=/.test(line)) {\n                inVideoMedia = false;\n            }\n            if (inVideoMedia) {\n                dstLines.push(line);\n            }\n        }\n        return DefaultSDP.linesToSDP(dstLines);\n    }\n    withoutCandidateType(candidateTypeToExclude) {\n        return DefaultSDP.linesToSDP(this.lines().filter(line => DefaultSDP.candidateType(line) !== candidateTypeToExclude));\n    }\n    withoutServerReflexiveCandidates() {\n        return this.withoutCandidateType(SDPCandidateType_1.default.ServerReflexive);\n    }\n    withBandwidthRestriction(maxBitrateKbps, isUnifiedPlan) {\n        const srcLines = this.lines();\n        const dstLines = [];\n        for (const line of srcLines) {\n            dstLines.push(line);\n            if (/^m=video/.test(line)) {\n                if (isUnifiedPlan) {\n                    dstLines.push(`b=TIAS:${maxBitrateKbps * 1000}`);\n                }\n                else {\n                    dstLines.push(`b=AS:${maxBitrateKbps}`);\n                }\n            }\n        }\n        return DefaultSDP.linesToSDP(dstLines);\n    }\n    withAudioMaxAverageBitrate(maxAverageBitrate) {\n        if (!maxAverageBitrate) {\n            return this.clone();\n        }\n        maxAverageBitrate = Math.trunc(Math.min(Math.max(maxAverageBitrate, DefaultSDP.rfc7587LowestBitrate), DefaultSDP.rfc7587HighestBitrate));\n        const srcLines = this.lines();\n        const dstLines = [];\n        const opusRtpMapRegex = /^a=rtpmap:\\s*(\\d+)\\s+opus\\/48000/;\n        let lookingForOpusRtpMap = false;\n        let fmtpAttribute = null;\n        for (const line of srcLines) {\n            if (line.startsWith('m=audio')) {\n                lookingForOpusRtpMap = true;\n                fmtpAttribute = null;\n            }\n            if (line.startsWith('m=video')) {\n                lookingForOpusRtpMap = false;\n                fmtpAttribute = null;\n            }\n            if (lookingForOpusRtpMap) {\n                const match = opusRtpMapRegex.exec(line);\n                if (match !== null) {\n                    fmtpAttribute = `a=fmtp:${match[1]} `;\n                    lookingForOpusRtpMap = false;\n                }\n            }\n            if (fmtpAttribute && line.startsWith(fmtpAttribute)) {\n                const oldParameters = line.slice(fmtpAttribute.length).split(';');\n                const newParameters = [];\n                for (const parameter of oldParameters) {\n                    if (!parameter.startsWith('maxaveragebitrate=')) {\n                        newParameters.push(parameter);\n                    }\n                }\n                newParameters.push(`maxaveragebitrate=${maxAverageBitrate}`);\n                dstLines.push(fmtpAttribute + newParameters.join(';'));\n            }\n            else {\n                dstLines.push(line);\n            }\n        }\n        return DefaultSDP.linesToSDP(dstLines);\n    }\n    // TODO: will remove this soon.\n    withUnifiedPlanFormat() {\n        let originalSdp = this.sdp;\n        if (originalSdp.includes('mozilla')) {\n            return this.clone();\n        }\n        else {\n            originalSdp = originalSdp.replace('o=-', 'o=mozilla-chrome');\n        }\n        return new DefaultSDP(originalSdp);\n    }\n    preferH264IfExists() {\n        const srcSDP = this.sdp;\n        const sections = DefaultSDP.splitSections(srcSDP);\n        if (sections.length < 2) {\n            return new DefaultSDP(this.sdp);\n        }\n        const newSections = [];\n        for (let i = 0; i < sections.length; i++) {\n            if (/^m=video/.test(sections[i])) {\n                const lines = DefaultSDP.splitLines(sections[i]);\n                let payloadTypeForVP8 = 0;\n                let payloadTypeForH264 = 0;\n                lines.forEach(attribute => {\n                    if (/^a=rtpmap:/.test(attribute)) {\n                        const payloadMatch = /^a=rtpmap:([0-9]+)\\s/.exec(attribute);\n                        if (attribute.toLowerCase().includes('vp8')) {\n                            payloadTypeForVP8 = parseInt(payloadMatch[1], 10);\n                        }\n                        else if (attribute.toLowerCase().includes('h264')) {\n                            payloadTypeForH264 = parseInt(payloadMatch[1], 10);\n                        }\n                    }\n                });\n                // m=video 9 UDP/+++ <payload>\n                if (payloadTypeForVP8 !== 0 && payloadTypeForH264 !== 0) {\n                    const mline = lines[0].split(' ');\n                    let indexForVP8 = -1;\n                    let indexForH264 = -1;\n                    for (let i = 3; i < mline.length; i++) {\n                        const payload = parseInt(mline[i], 10);\n                        if (payload === payloadTypeForVP8) {\n                            indexForVP8 = i;\n                        }\n                        else if (payload === payloadTypeForH264) {\n                            indexForH264 = i;\n                        }\n                    }\n                    if (indexForVP8 < indexForH264) {\n                        mline[indexForVP8] = payloadTypeForH264.toString();\n                        mline[indexForH264] = payloadTypeForVP8.toString();\n                    }\n                    lines[0] = mline.join(' ');\n                }\n                sections[i] = lines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF;\n                // since there is only H264 or VP8, we don't switch payload places\n            }\n            newSections.push(sections[i]);\n        }\n        const newSdp = newSections.join('');\n        return new DefaultSDP(newSdp);\n    }\n    withOldFashionedMungingSimulcast(videoSimulcastLayerCount) {\n        if (videoSimulcastLayerCount < 2) {\n            return this.clone();\n        }\n        const srcSDP = this.sdp;\n        const sections = DefaultSDP.splitSections(srcSDP);\n        if (sections.length < 2) {\n            return new DefaultSDP(this.sdp);\n        }\n        const cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n        if (cameraLineIndex === -1) {\n            return new DefaultSDP(this.sdp);\n        }\n        let cname = '';\n        let msid = '';\n        DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc:').forEach((line) => {\n            const ssrcAttrTuple = DefaultSDP.parseSSRCMedia(line);\n            if (ssrcAttrTuple[1] === 'cname') {\n                cname = ssrcAttrTuple[2];\n            }\n            else if (ssrcAttrTuple[1] === 'msid') {\n                msid = ssrcAttrTuple[2];\n            }\n        });\n        const fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n        if (cname === '' || msid === '' || fidGroupMatch.length < 1) {\n            return new DefaultSDP(this.sdp);\n        }\n        const fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n        const cameraSectionLines = sections[cameraLineIndex]\n            .trim()\n            .split(DefaultSDP.CRLF)\n            .filter((line) => {\n            return line.indexOf('a=ssrc:') !== 0 && line.indexOf('a=ssrc-group:') !== 0;\n        });\n        const simulcastSSRCs = [];\n        const [videoSSRC1, rtxSSRC1] = fidGroup.split(' ').map(ssrc => parseInt(ssrc, 10));\n        let videoSSRC = videoSSRC1;\n        let rtxSSRC = rtxSSRC1;\n        for (let i = 0; i < videoSimulcastLayerCount; i++) {\n            cameraSectionLines.push('a=ssrc:' + videoSSRC + ' cname:' + cname);\n            cameraSectionLines.push('a=ssrc:' + videoSSRC + ' msid:' + msid);\n            cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' cname:' + cname);\n            cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' msid:' + msid);\n            cameraSectionLines.push('a=ssrc-group:FID ' + videoSSRC + ' ' + rtxSSRC);\n            simulcastSSRCs.push(videoSSRC);\n            videoSSRC = videoSSRC + 1;\n            rtxSSRC = videoSSRC + 1;\n        }\n        cameraSectionLines.push('a=ssrc-group:SIM ' + simulcastSSRCs.join(' '));\n        sections[cameraLineIndex] = cameraSectionLines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF;\n        const newSDP = sections.join('');\n        return new DefaultSDP(newSDP);\n    }\n    ssrcForVideoSendingSection() {\n        const srcSDP = this.sdp;\n        const sections = DefaultSDP.splitSections(srcSDP);\n        if (sections.length < 2) {\n            return '';\n        }\n        const cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n        if (cameraLineIndex === -1) {\n            return '';\n        }\n        // TODO: match for Firefox. Currently all failures are not Firefox induced.\n        const fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n        if (fidGroupMatch.length < 1) {\n            return '';\n        }\n        const fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n        const [videoSSRC1] = fidGroup.split(' ').map(ssrc => parseInt(ssrc, 10));\n        return videoSSRC1.toString();\n    }\n    videoSendSectionHasDifferentSSRC(prevSdp) {\n        const ssrc1 = this.ssrcForVideoSendingSection();\n        const ssrc2 = prevSdp.ssrcForVideoSendingSection();\n        if (ssrc1 === '' || ssrc2 === '') {\n            return false;\n        }\n        const ssrc1InNumber = parseInt(ssrc1, 10);\n        const ssrc2InNumber = parseInt(ssrc2, 10);\n        if (ssrc1InNumber === ssrc2InNumber) {\n            return false;\n        }\n        return true;\n    }\n}\nexports.default = DefaultSDP;\nDefaultSDP.CRLF = '\\r\\n';\nDefaultSDP.rfc7587LowestBitrate = 6000;\nDefaultSDP.rfc7587HighestBitrate = 510000;\n//# sourceMappingURL=DefaultSDP.js.map"]},"metadata":{},"sourceType":"script"}