{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst SignalingClientConnectionRequest_1 = require(\"../signalingclient/SignalingClientConnectionRequest\");\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n\nclass OpenSignalingConnectionTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'OpenSignalingConnectionTask';\n    this.taskCanceler = null;\n  }\n\n  cancel() {\n    if (this.taskCanceler) {\n      this.taskCanceler.cancel();\n      this.taskCanceler = null;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const configuration = this.context.meetingSessionConfiguration;\n      this.context.signalingClient.openConnection(new SignalingClientConnectionRequest_1.default(configuration.urls.signalingURL, configuration.credentials.joinToken));\n      const startTimeMs = Date.now();\n\n      try {\n        yield new Promise((resolve, reject) => {\n          class WebSocketOpenInterceptor {\n            constructor(signalingClient) {\n              this.signalingClient = signalingClient;\n            }\n\n            cancel() {\n              this.signalingClient.removeObserver(this);\n              reject(new Error(`OpenSignalingConnectionTask got canceled while waiting to open signaling connection`));\n            }\n\n            handleSignalingClientEvent(event) {\n              switch (event.type) {\n                case SignalingClientEventType_1.default.WebSocketOpen:\n                  this.signalingClient.removeObserver(this);\n                  resolve();\n                  break;\n\n                case SignalingClientEventType_1.default.WebSocketFailed:\n                  this.signalingClient.removeObserver(this);\n                  reject(new Error('WebSocket connection failed'));\n                  break;\n              }\n            }\n\n          }\n\n          const interceptor = new WebSocketOpenInterceptor(this.context.signalingClient);\n          this.context.signalingClient.registerObserver(interceptor);\n          this.taskCanceler = interceptor;\n        });\n      } catch (error) {\n        throw error;\n      } finally {\n        this.context.signalingOpenDurationMs = Math.round(Date.now() - startTimeMs);\n      }\n    });\n  }\n\n}\n\nexports.default = OpenSignalingConnectionTask;","map":{"version":3,"sources":["../../src/task/OpenSignalingConnectionTask.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,MAAA,kCAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AAEA,MAAA,0BAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AAGA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAqB,2BAArB,SAAyD,UAAA,CAAA,OAAzD,CAAiE;AAK/D,EAAA,WAAA,CAAoB,OAApB,EAAsD;AACpD,UAAM,OAAO,CAAC,MAAd;AADkB,SAAA,OAAA,GAAA,OAAA;AAJV,SAAA,QAAA,GAAW,6BAAX;AAEF,SAAA,YAAA,GAAoC,IAApC;AAIP;;AAED,EAAA,MAAM,GAAA;AACJ,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,MAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACD;AACF;;AAEK,EAAA,GAAG,GAAA;;AACP,YAAM,aAAa,GAAG,KAAK,OAAL,CAAa,2BAAnC;AAEA,WAAK,OAAL,CAAa,eAAb,CAA6B,cAA7B,CACE,IAAI,kCAAA,CAAA,OAAJ,CACE,aAAa,CAAC,IAAd,CAAmB,YADrB,EAEE,aAAa,CAAC,WAAd,CAA0B,SAF5B,CADF;AAMA,YAAM,WAAW,GAAG,IAAI,CAAC,GAAL,EAApB;;AACA,UAAI;AACF,cAAM,IAAI,OAAJ,CAAkB,CAAC,OAAD,EAAU,MAAV,KAAoB;AAC1C,gBAAM,wBAAN,CAA8B;AAC5B,YAAA,WAAA,CAAoB,eAApB,EAAoD;AAAhC,mBAAA,eAAA,GAAA,eAAA;AAAoC;;AAExD,YAAA,MAAM,GAAA;AACJ,mBAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC;AACA,cAAA,MAAM,CACJ,IAAI,KAAJ,CACE,qFADF,CADI,CAAN;AAKD;;AAED,YAAA,0BAA0B,CAAC,KAAD,EAA4B;AACpD,sBAAQ,KAAK,CAAC,IAAd;AACE,qBAAK,0BAAA,CAAA,OAAA,CAAyB,aAA9B;AACE,uBAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC;AACA,kBAAA,OAAO;AACP;;AACF,qBAAK,0BAAA,CAAA,OAAA,CAAyB,eAA9B;AACE,uBAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC;AACA,kBAAA,MAAM,CAAC,IAAI,KAAJ,CAAU,6BAAV,CAAD,CAAN;AACA;AARJ;AAUD;;AAvB2B;;AAyB9B,gBAAM,WAAW,GAAG,IAAI,wBAAJ,CAA6B,KAAK,OAAL,CAAa,eAA1C,CAApB;AACA,eAAK,OAAL,CAAa,eAAb,CAA6B,gBAA7B,CAA8C,WAA9C;AACA,eAAK,YAAL,GAAoB,WAApB;AACD,SA7BK,CAAN;AA8BD,OA/BD,CA+BE,OAAO,KAAP,EAAc;AACd,cAAM,KAAN;AACD,OAjCD,SAiCU;AACR,aAAK,OAAL,CAAa,uBAAb,GAAuC,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,KAAa,WAAxB,CAAvC;AACD;AACF,K;AAAA;;AA9D8D;;AAAjE,OAAA,CAAA,OAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SignalingClientConnectionRequest_1 = require(\"../signalingclient/SignalingClientConnectionRequest\");\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\nconst BaseTask_1 = require(\"./BaseTask\");\nclass OpenSignalingConnectionTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'OpenSignalingConnectionTask';\n        this.taskCanceler = null;\n    }\n    cancel() {\n        if (this.taskCanceler) {\n            this.taskCanceler.cancel();\n            this.taskCanceler = null;\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const configuration = this.context.meetingSessionConfiguration;\n            this.context.signalingClient.openConnection(new SignalingClientConnectionRequest_1.default(configuration.urls.signalingURL, configuration.credentials.joinToken));\n            const startTimeMs = Date.now();\n            try {\n                yield new Promise((resolve, reject) => {\n                    class WebSocketOpenInterceptor {\n                        constructor(signalingClient) {\n                            this.signalingClient = signalingClient;\n                        }\n                        cancel() {\n                            this.signalingClient.removeObserver(this);\n                            reject(new Error(`OpenSignalingConnectionTask got canceled while waiting to open signaling connection`));\n                        }\n                        handleSignalingClientEvent(event) {\n                            switch (event.type) {\n                                case SignalingClientEventType_1.default.WebSocketOpen:\n                                    this.signalingClient.removeObserver(this);\n                                    resolve();\n                                    break;\n                                case SignalingClientEventType_1.default.WebSocketFailed:\n                                    this.signalingClient.removeObserver(this);\n                                    reject(new Error('WebSocket connection failed'));\n                                    break;\n                            }\n                        }\n                    }\n                    const interceptor = new WebSocketOpenInterceptor(this.context.signalingClient);\n                    this.context.signalingClient.registerObserver(interceptor);\n                    this.taskCanceler = interceptor;\n                });\n            }\n            catch (error) {\n                throw error;\n            }\n            finally {\n                this.context.signalingOpenDurationMs = Math.round(Date.now() - startTimeMs);\n            }\n        });\n    }\n}\nexports.default = OpenSignalingConnectionTask;\n//# sourceMappingURL=OpenSignalingConnectionTask.js.map"]},"metadata":{},"sourceType":"script"}