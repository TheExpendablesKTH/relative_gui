{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst MeetingSessionStatusCode_1 = require(\"../meetingsession/MeetingSessionStatusCode\");\n\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[FinishGatheringICECandidatesTask]] add ice-candidate event handler on peer connection to\n * collect ice candidates and wait for peer connection ice gathering state to complete\n */\n\n\nclass FinishGatheringICECandidatesTask extends BaseTask_1.default {\n  constructor(context, chromeVpnTimeoutMs = FinishGatheringICECandidatesTask.CHROME_VPN_TIMEOUT_MS) {\n    super(context.logger);\n    this.context = context;\n    this.chromeVpnTimeoutMs = chromeVpnTimeoutMs;\n    this.taskName = 'FinishGatheringICECandidatesTask';\n  }\n\n  removeEventListener() {\n    if (this.context.peer) {\n      this.context.peer.removeEventListener('icecandidate', this.context.iceCandidateHandler);\n\n      if (!this.context.turnCredentials) {\n        this.context.peer.removeEventListener('icegatheringstatechange', this.context.iceGatheringStateEventHandler);\n      }\n    }\n  }\n\n  cancel() {\n    let error; // TODO: Remove when the Chrome VPN reconnect bug is fixed.\n    // In Chrome, SDK may fail to establish TURN session after VPN reconnect.\n    // https://bugs.chromium.org/p/webrtc/issues/detail?id=9097\n\n    if (this.context.browserBehavior.requiresIceCandidateGatheringTimeoutWorkaround()) {\n      if (this.chromeVpnTimeoutMs < this.context.meetingSessionConfiguration.connectionTimeoutMs) {\n        const duration = Date.now() - this.startTimestampMs;\n\n        if (duration > this.chromeVpnTimeoutMs) {\n          error = new Error(`canceling ${this.name()} due to the meeting status code: ${MeetingSessionStatusCode_1.default.ICEGatheringTimeoutWorkaround}`);\n        }\n      }\n    } // Just in case. The baseCancel behavior should prevent this.\n\n    /* istanbul ignore else */\n\n\n    if (this.cancelPromise) {\n      error = error || new Error(`canceling ${this.name()}`);\n      this.cancelPromise(error);\n      delete this.cancelPromise;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.context.peer) {\n        this.logAndThrow(`session does not have peer connection; bypass ice gathering`);\n      }\n\n      if (this.context.browserBehavior.requiresCheckForSdpConnectionAttributes()) {\n        if (new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidatesForAllMLines()) {\n          this.context.logger.info(`ice gathering already complete; bypass gathering, current local description ${this.context.peer.localDescription.sdp}`);\n          return;\n        }\n      } else {\n        this.context.logger.info(`iOS device does not require checking for connection attributes in SDP, current local description ${this.context.peer.localDescription.sdp}`);\n      }\n      /*\n       * To bypass waiting for events, it is required that \"icegatheringstate\" to be complete and sdp to have candidate\n       * For Firefox, it takes long for iceGatheringState === 'complete'\n       * Ref: https://github.com/aws/amazon-chime-sdk-js/issues/609\n       */\n\n\n      if ((this.context.browserBehavior.hasFirefoxWebRTC() || this.context.peer.iceGatheringState === 'complete') && new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidates()) {\n        this.context.logger.info('ice gathering state is complete and candidates are in SDP; bypass gathering');\n        return;\n      }\n\n      try {\n        yield new Promise((resolve, reject) => {\n          this.cancelPromise = error => {\n            this.removeEventListener();\n            reject(error);\n          };\n\n          if (!this.context.turnCredentials) {\n            // if one day, we found a case where a FinishGatheringICECandidate did not resolve but ice gathering state is complete and SDP answer has ice candidates\n            // we may need to enable this\n            this.context.iceGatheringStateEventHandler = () => {\n              if (this.context.peer.iceGatheringState === 'complete') {\n                this.removeEventListener();\n                resolve();\n                delete this.cancelPromise;\n                return;\n              }\n            };\n\n            this.context.peer.addEventListener('icegatheringstatechange', this.context.iceGatheringStateEventHandler);\n          }\n\n          this.context.iceCandidateHandler = event => {\n            this.context.logger.info(`ice candidate: ${event.candidate ? event.candidate.candidate : '(null)'} state: ${this.context.peer.iceGatheringState}`); // Ice candidate arrives, do not need to wait anymore.\n            // https://webrtcglossary.com/trickle-ice/\n\n            if (event.candidate) {\n              if (DefaultSDP_1.default.isRTPCandidate(event.candidate.candidate)) {\n                this.context.iceCandidates.push(event.candidate);\n              } // Could there be a case the candidate is not written to SDP ?\n\n\n              if (this.context.turnCredentials && this.context.iceCandidates.length >= 1) {\n                this.context.logger.info('gathered at least one relay candidate');\n                this.removeEventListener();\n                resolve();\n                delete this.cancelPromise;\n                return;\n              }\n            } // Ice candidate gathering is complete, additional barrier to make sure sdp contain an ice candidate.\n            // TODO: Could there be a race where iceGatheringState is flipped after this task is run ? This could only be handled if ice state is monitored persistently.\n\n\n            if (this.context.peer.iceGatheringState === 'complete') {\n              this.context.logger.info('done gathering ice candidates');\n              this.removeEventListener();\n\n              if (!new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidates() || this.context.iceCandidates.length === 0) {\n                reject(new Error('no ice candidates were gathered'));\n                delete this.cancelPromise;\n              } else {\n                resolve();\n                delete this.cancelPromise;\n              }\n            }\n          }; // SDK does not catch candidate itself and send to sever. Rather, WebRTC handles candidate events and writes candidate to SDP.\n\n\n          this.context.peer.addEventListener('icecandidate', this.context.iceCandidateHandler);\n          this.startTimestampMs = Date.now();\n        });\n      } catch (error) {\n        throw error;\n      } finally {\n        /* istanbul ignore else */\n        if (this.startTimestampMs) {\n          this.context.iceGatheringDurationMs = Math.round(Date.now() - this.startTimestampMs);\n        }\n      }\n    });\n  }\n\n}\n\nexports.default = FinishGatheringICECandidatesTask;\nFinishGatheringICECandidatesTask.CHROME_VPN_TIMEOUT_MS = 5000;","map":{"version":3,"sources":["../../src/task/FinishGatheringICECandidatesTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MeetingSessionStatusCode_1 = require(\"../meetingsession/MeetingSessionStatusCode\");\nconst DefaultSDP_1 = require(\"../sdp/DefaultSDP\");\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[FinishGatheringICECandidatesTask]] add ice-candidate event handler on peer connection to\n * collect ice candidates and wait for peer connection ice gathering state to complete\n */\nclass FinishGatheringICECandidatesTask extends BaseTask_1.default {\n    constructor(context, chromeVpnTimeoutMs = FinishGatheringICECandidatesTask.CHROME_VPN_TIMEOUT_MS) {\n        super(context.logger);\n        this.context = context;\n        this.chromeVpnTimeoutMs = chromeVpnTimeoutMs;\n        this.taskName = 'FinishGatheringICECandidatesTask';\n    }\n    removeEventListener() {\n        if (this.context.peer) {\n            this.context.peer.removeEventListener('icecandidate', this.context.iceCandidateHandler);\n            if (!this.context.turnCredentials) {\n                this.context.peer.removeEventListener('icegatheringstatechange', this.context.iceGatheringStateEventHandler);\n            }\n        }\n    }\n    cancel() {\n        let error;\n        // TODO: Remove when the Chrome VPN reconnect bug is fixed.\n        // In Chrome, SDK may fail to establish TURN session after VPN reconnect.\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=9097\n        if (this.context.browserBehavior.requiresIceCandidateGatheringTimeoutWorkaround()) {\n            if (this.chromeVpnTimeoutMs < this.context.meetingSessionConfiguration.connectionTimeoutMs) {\n                const duration = Date.now() - this.startTimestampMs;\n                if (duration > this.chromeVpnTimeoutMs) {\n                    error = new Error(`canceling ${this.name()} due to the meeting status code: ${MeetingSessionStatusCode_1.default.ICEGatheringTimeoutWorkaround}`);\n                }\n            }\n        }\n        // Just in case. The baseCancel behavior should prevent this.\n        /* istanbul ignore else */\n        if (this.cancelPromise) {\n            error = error || new Error(`canceling ${this.name()}`);\n            this.cancelPromise(error);\n            delete this.cancelPromise;\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.context.peer) {\n                this.logAndThrow(`session does not have peer connection; bypass ice gathering`);\n            }\n            if (this.context.browserBehavior.requiresCheckForSdpConnectionAttributes()) {\n                if (new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidatesForAllMLines()) {\n                    this.context.logger.info(`ice gathering already complete; bypass gathering, current local description ${this.context.peer.localDescription.sdp}`);\n                    return;\n                }\n            }\n            else {\n                this.context.logger.info(`iOS device does not require checking for connection attributes in SDP, current local description ${this.context.peer.localDescription.sdp}`);\n            }\n            /*\n             * To bypass waiting for events, it is required that \"icegatheringstate\" to be complete and sdp to have candidate\n             * For Firefox, it takes long for iceGatheringState === 'complete'\n             * Ref: https://github.com/aws/amazon-chime-sdk-js/issues/609\n             */\n            if ((this.context.browserBehavior.hasFirefoxWebRTC() ||\n                this.context.peer.iceGatheringState === 'complete') &&\n                new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidates()) {\n                this.context.logger.info('ice gathering state is complete and candidates are in SDP; bypass gathering');\n                return;\n            }\n            try {\n                yield new Promise((resolve, reject) => {\n                    this.cancelPromise = (error) => {\n                        this.removeEventListener();\n                        reject(error);\n                    };\n                    if (!this.context.turnCredentials) {\n                        // if one day, we found a case where a FinishGatheringICECandidate did not resolve but ice gathering state is complete and SDP answer has ice candidates\n                        // we may need to enable this\n                        this.context.iceGatheringStateEventHandler = () => {\n                            if (this.context.peer.iceGatheringState === 'complete') {\n                                this.removeEventListener();\n                                resolve();\n                                delete this.cancelPromise;\n                                return;\n                            }\n                        };\n                        this.context.peer.addEventListener('icegatheringstatechange', this.context.iceGatheringStateEventHandler);\n                    }\n                    this.context.iceCandidateHandler = (event) => {\n                        this.context.logger.info(`ice candidate: ${event.candidate ? event.candidate.candidate : '(null)'} state: ${this.context.peer.iceGatheringState}`);\n                        // Ice candidate arrives, do not need to wait anymore.\n                        // https://webrtcglossary.com/trickle-ice/\n                        if (event.candidate) {\n                            if (DefaultSDP_1.default.isRTPCandidate(event.candidate.candidate)) {\n                                this.context.iceCandidates.push(event.candidate);\n                            }\n                            // Could there be a case the candidate is not written to SDP ?\n                            if (this.context.turnCredentials && this.context.iceCandidates.length >= 1) {\n                                this.context.logger.info('gathered at least one relay candidate');\n                                this.removeEventListener();\n                                resolve();\n                                delete this.cancelPromise;\n                                return;\n                            }\n                        }\n                        // Ice candidate gathering is complete, additional barrier to make sure sdp contain an ice candidate.\n                        // TODO: Could there be a race where iceGatheringState is flipped after this task is run ? This could only be handled if ice state is monitored persistently.\n                        if (this.context.peer.iceGatheringState === 'complete') {\n                            this.context.logger.info('done gathering ice candidates');\n                            this.removeEventListener();\n                            if (!new DefaultSDP_1.default(this.context.peer.localDescription.sdp).hasCandidates() ||\n                                this.context.iceCandidates.length === 0) {\n                                reject(new Error('no ice candidates were gathered'));\n                                delete this.cancelPromise;\n                            }\n                            else {\n                                resolve();\n                                delete this.cancelPromise;\n                            }\n                        }\n                    };\n                    // SDK does not catch candidate itself and send to sever. Rather, WebRTC handles candidate events and writes candidate to SDP.\n                    this.context.peer.addEventListener('icecandidate', this.context.iceCandidateHandler);\n                    this.startTimestampMs = Date.now();\n                });\n            }\n            catch (error) {\n                throw error;\n            }\n            finally {\n                /* istanbul ignore else */\n                if (this.startTimestampMs) {\n                    this.context.iceGatheringDurationMs = Math.round(Date.now() - this.startTimestampMs);\n                }\n            }\n        });\n    }\n}\nexports.default = FinishGatheringICECandidatesTask;\nFinishGatheringICECandidatesTask.CHROME_VPN_TIMEOUT_MS = 5000;\n//# sourceMappingURL=FinishGatheringICECandidatesTask.js.map"]},"metadata":{},"sourceType":"script"}