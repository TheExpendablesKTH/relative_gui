{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst CanvasVideoFrameBuffer_1 = require(\"./CanvasVideoFrameBuffer\");\n\nconst DEFAULT_FRAMERATE = 15;\n/**\n * [[DefaultVideoFrameProcessorPipeline]] implements {@link VideoFrameProcessorPipeline}.\n * It constructs a buffer {@link CanvasVideoFrameBuffer} as source by default and invokes processor based on `framerate`.\n * The default output type is `MediaStream`.\n */\n\nclass DefaultVideoFrameProcessorPipeline {\n  constructor(logger, stages) {\n    this.logger = logger;\n    this.stages = stages;\n    this.fr = DEFAULT_FRAMERATE; // initialize with dummy inactive MediaStream to keep strict type\n\n    this.outputMediaStream = new MediaStream();\n    this.videoInput = document.createElement('video');\n    this.canvasOutput = document.createElement('canvas');\n    this.outputCtx = this.canvasOutput.getContext('2d');\n    this.canvasInput = document.createElement('canvas');\n    this.inputCtx = this.canvasInput.getContext('2d');\n    this.inputVideoStream = null;\n    this.sourceBuffers = [];\n    this.destBuffers = [];\n    this.observers = new Set();\n    this.hasStarted = false;\n\n    this.process = _event => __awaiter(this, void 0, void 0, function* () {\n      if (!this.inputVideoStream) {\n        return;\n      }\n\n      const processVideoStart = performance.now(); // videoWidth is intrinsic video width\n\n      if (this.videoInput.videoWidth) {\n        if (this.canvasInput.width !== this.videoInput.videoWidth) {\n          this.canvasInput.width = this.videoInput.videoWidth;\n          this.canvasInput.height = this.videoInput.videoHeight;\n          this.sourceBuffers[0].height = this.canvasInput.height;\n          this.sourceBuffers[0].width = this.canvasInput.width;\n          this.sourceBuffers[0].framerate = this.framerate;\n        }\n\n        this.inputCtx.drawImage(this.videoInput, 0, 0);\n      } // processes input buffers\n\n\n      let buffers = [];\n      buffers.push(this.sourceBuffers[0]);\n\n      try {\n        for (const proc of this.processors) {\n          buffers = yield proc.process(buffers);\n        }\n      } catch (_error) {\n        this.forEachObserver(obs => {\n          if (obs.processingDidFailToStart) {\n            obs.processingDidFailToStart();\n          }\n        });\n        return;\n      }\n\n      this.destBuffers = buffers;\n      let imageSource;\n\n      try {\n        imageSource = yield this.destBuffers[0].asCanvasImageSource();\n      } catch (error) {\n        if (this.inputVideoStream) {\n          this.logger.info('buffers are destroyed and pipeline could not start');\n          this.forEachObserver(obs => {\n            if (obs.processingDidFailToStart) {\n              obs.processingDidFailToStart();\n            }\n          });\n        }\n\n        return;\n      } // finally draws the image\n\n\n      const frameWidth = imageSource.width;\n      const frameHeight = imageSource.height;\n\n      if (frameWidth !== 0 && frameHeight !== 0) {\n        if (this.canvasOutput.width !== frameWidth && this.canvasOutput.height !== frameHeight) {\n          this.canvasOutput.width = frameWidth;\n          this.canvasOutput.height = frameHeight;\n        }\n\n        this.outputCtx.drawImage(imageSource, 0, 0, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight);\n\n        if (!this.hasStarted) {\n          this.hasStarted = true;\n          this.forEachObserver(observer => {\n            if (observer.processingDidStart) {\n              observer.processingDidStart();\n            }\n          });\n        }\n      } // measures time\n\n\n      const processVideoLatency = performance.now() - processVideoStart;\n      const leave = 1000 * 2 / this.framerate - processVideoLatency; // half fps\n\n      const nextFrameDelay = Math.max(0, 1000 / this.framerate - processVideoLatency);\n\n      if (leave <= 0) {\n        this.forEachObserver(obs => {\n          if (obs.processingLatencyTooHigh) {\n            obs.processingLatencyTooHigh(processVideoLatency);\n          }\n        });\n      } // TODO: use requestAnimationFrame which is more organic and allows browser to conserve resources by its choices.\n\n\n      this.lastTimeOut = setTimeout(this.process, nextFrameDelay);\n    });\n  }\n\n  destroy() {\n    this.stop();\n\n    if (this.stages) {\n      for (const stage of this.stages) {\n        stage.destroy();\n      }\n    }\n  }\n\n  get framerate() {\n    return this.fr;\n  } // A negative framerate will cause `captureStream` to throw `NotSupportedError`.\n  // The setter prevents this by switching to the default framerate if less than 0.\n\n\n  set framerate(value) {\n    this.fr = value < 0 ? DEFAULT_FRAMERATE : value;\n  }\n\n  stop() {\n    // empty stream, stop pipeline\n    // null input media stream stops the pipeline.\n    this.videoInput.removeEventListener('loadedmetadata', this.process);\n    this.videoInput.srcObject = null; // Clean the input stream and buffers.\n\n    this.destroyInputMediaStreamAndBuffers(); // Stop all the output tracks, but don't discard the media stream,\n    // because it's how other parts of the codebase recognize when\n    // a selected stream is part of this transform device.\n\n    if (this.outputMediaStream) {\n      for (const track of this.outputMediaStream.getVideoTracks()) {\n        track.stop();\n      }\n    }\n\n    if (this.lastTimeOut) {\n      clearTimeout(this.lastTimeOut);\n      this.lastTimeOut = undefined;\n    }\n\n    if (this.hasStarted) {\n      this.hasStarted = false;\n      this.forEachObserver(observer => {\n        if (observer.processingDidStop) {\n          observer.processingDidStop();\n        }\n      });\n    }\n  }\n\n  addObserver(observer) {\n    this.observers.add(observer);\n  }\n\n  removeObserver(observer) {\n    this.observers.delete(observer);\n  }\n\n  getInputMediaStream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.inputVideoStream;\n    });\n  }\n\n  getActiveOutputMediaStream() {\n    if (this.outputMediaStream && this.outputMediaStream.active) {\n      return this.outputMediaStream;\n    }\n\n    return this.outputMediaStream = this.canvasOutput.captureStream(this.framerate);\n  }\n  /**\n   * `inputMediaStream` is by default used to construct one {@link CanvasVideoFrameBuffer}\n   * The buffer will be fed into the first {@link VideoFrameProcessor}.\n   */\n\n\n  setInputMediaStream(inputMediaStream) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!inputMediaStream) {\n        this.stop();\n        return;\n      }\n\n      if (inputMediaStream.getVideoTracks().length === 0) {\n        this.logger.error('No video tracks in input media stream, ignoring');\n        return;\n      }\n\n      this.inputVideoStream = inputMediaStream;\n      const settings = this.inputVideoStream.getVideoTracks()[0].getSettings();\n      this.logger.info(`processing pipeline input stream settings ${settings}`);\n      this.canvasOutput.width = settings.width;\n      this.canvasOutput.height = settings.height;\n      this.videoInput.addEventListener('loadedmetadata', this.process);\n      this.videoInput.srcObject = this.inputVideoStream; // avoid iOS safari full screen video\n\n      this.videoInput.setAttribute('playsinline', 'true'); // create sources\n\n      const canvasBuffer = new CanvasVideoFrameBuffer_1.default(this.canvasInput);\n      this.sourceBuffers.push(canvasBuffer);\n      this.videoInput.load();\n      yield this.videoInput.play();\n    });\n  }\n\n  set processors(stages) {\n    this.stages = stages;\n  }\n\n  get processors() {\n    return this.stages;\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.observers) {\n      setTimeout(() => {\n        observerFunc(observer);\n      }, 0);\n    }\n  }\n\n  destroyInputMediaStreamAndBuffers() {\n    if (this.inputVideoStream) {\n      for (const track of this.inputVideoStream.getTracks()) {\n        track.stop();\n      }\n    }\n\n    this.inputVideoStream = null;\n\n    for (const buffer of this.sourceBuffers) {\n      buffer.destroy();\n    }\n\n    this.sourceBuffers = [];\n  }\n\n}\n\nexports.default = DefaultVideoFrameProcessorPipeline;","map":{"version":3,"sources":["../../src/videoframeprocessor/DefaultVideoFrameProcessorPipeline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CanvasVideoFrameBuffer_1 = require(\"./CanvasVideoFrameBuffer\");\nconst DEFAULT_FRAMERATE = 15;\n/**\n * [[DefaultVideoFrameProcessorPipeline]] implements {@link VideoFrameProcessorPipeline}.\n * It constructs a buffer {@link CanvasVideoFrameBuffer} as source by default and invokes processor based on `framerate`.\n * The default output type is `MediaStream`.\n */\nclass DefaultVideoFrameProcessorPipeline {\n    constructor(logger, stages) {\n        this.logger = logger;\n        this.stages = stages;\n        this.fr = DEFAULT_FRAMERATE;\n        // initialize with dummy inactive MediaStream to keep strict type\n        this.outputMediaStream = new MediaStream();\n        this.videoInput = document.createElement('video');\n        this.canvasOutput = document.createElement('canvas');\n        this.outputCtx = this.canvasOutput.getContext('2d');\n        this.canvasInput = document.createElement('canvas');\n        this.inputCtx = this.canvasInput.getContext('2d');\n        this.inputVideoStream = null;\n        this.sourceBuffers = [];\n        this.destBuffers = [];\n        this.observers = new Set();\n        this.hasStarted = false;\n        this.process = (_event) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.inputVideoStream) {\n                return;\n            }\n            const processVideoStart = performance.now();\n            // videoWidth is intrinsic video width\n            if (this.videoInput.videoWidth) {\n                if (this.canvasInput.width !== this.videoInput.videoWidth) {\n                    this.canvasInput.width = this.videoInput.videoWidth;\n                    this.canvasInput.height = this.videoInput.videoHeight;\n                    this.sourceBuffers[0].height = this.canvasInput.height;\n                    this.sourceBuffers[0].width = this.canvasInput.width;\n                    this.sourceBuffers[0].framerate = this.framerate;\n                }\n                this.inputCtx.drawImage(this.videoInput, 0, 0);\n            }\n            // processes input buffers\n            let buffers = [];\n            buffers.push(this.sourceBuffers[0]);\n            try {\n                for (const proc of this.processors) {\n                    buffers = yield proc.process(buffers);\n                }\n            }\n            catch (_error) {\n                this.forEachObserver(obs => {\n                    if (obs.processingDidFailToStart) {\n                        obs.processingDidFailToStart();\n                    }\n                });\n                return;\n            }\n            this.destBuffers = buffers;\n            let imageSource;\n            try {\n                imageSource = yield this.destBuffers[0].asCanvasImageSource();\n            }\n            catch (error) {\n                if (this.inputVideoStream) {\n                    this.logger.info('buffers are destroyed and pipeline could not start');\n                    this.forEachObserver(obs => {\n                        if (obs.processingDidFailToStart) {\n                            obs.processingDidFailToStart();\n                        }\n                    });\n                }\n                return;\n            }\n            // finally draws the image\n            const frameWidth = imageSource.width;\n            const frameHeight = imageSource.height;\n            if (frameWidth !== 0 && frameHeight !== 0) {\n                if (this.canvasOutput.width !== frameWidth && this.canvasOutput.height !== frameHeight) {\n                    this.canvasOutput.width = frameWidth;\n                    this.canvasOutput.height = frameHeight;\n                }\n                this.outputCtx.drawImage(imageSource, 0, 0, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight);\n                if (!this.hasStarted) {\n                    this.hasStarted = true;\n                    this.forEachObserver(observer => {\n                        if (observer.processingDidStart) {\n                            observer.processingDidStart();\n                        }\n                    });\n                }\n            }\n            // measures time\n            const processVideoLatency = performance.now() - processVideoStart;\n            const leave = (1000 * 2) / this.framerate - processVideoLatency; // half fps\n            const nextFrameDelay = Math.max(0, 1000 / this.framerate - processVideoLatency);\n            if (leave <= 0) {\n                this.forEachObserver(obs => {\n                    if (obs.processingLatencyTooHigh) {\n                        obs.processingLatencyTooHigh(processVideoLatency);\n                    }\n                });\n            }\n            // TODO: use requestAnimationFrame which is more organic and allows browser to conserve resources by its choices.\n            this.lastTimeOut = setTimeout(this.process, nextFrameDelay);\n        });\n    }\n    destroy() {\n        this.stop();\n        if (this.stages) {\n            for (const stage of this.stages) {\n                stage.destroy();\n            }\n        }\n    }\n    get framerate() {\n        return this.fr;\n    }\n    // A negative framerate will cause `captureStream` to throw `NotSupportedError`.\n    // The setter prevents this by switching to the default framerate if less than 0.\n    set framerate(value) {\n        this.fr = value < 0 ? DEFAULT_FRAMERATE : value;\n    }\n    stop() {\n        // empty stream, stop pipeline\n        // null input media stream stops the pipeline.\n        this.videoInput.removeEventListener('loadedmetadata', this.process);\n        this.videoInput.srcObject = null;\n        // Clean the input stream and buffers.\n        this.destroyInputMediaStreamAndBuffers();\n        // Stop all the output tracks, but don't discard the media stream,\n        // because it's how other parts of the codebase recognize when\n        // a selected stream is part of this transform device.\n        if (this.outputMediaStream) {\n            for (const track of this.outputMediaStream.getVideoTracks()) {\n                track.stop();\n            }\n        }\n        if (this.lastTimeOut) {\n            clearTimeout(this.lastTimeOut);\n            this.lastTimeOut = undefined;\n        }\n        if (this.hasStarted) {\n            this.hasStarted = false;\n            this.forEachObserver(observer => {\n                if (observer.processingDidStop) {\n                    observer.processingDidStop();\n                }\n            });\n        }\n    }\n    addObserver(observer) {\n        this.observers.add(observer);\n    }\n    removeObserver(observer) {\n        this.observers.delete(observer);\n    }\n    getInputMediaStream() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.inputVideoStream;\n        });\n    }\n    getActiveOutputMediaStream() {\n        if (this.outputMediaStream && this.outputMediaStream.active) {\n            return this.outputMediaStream;\n        }\n        return (this.outputMediaStream = this.canvasOutput.captureStream(this.framerate));\n    }\n    /**\n     * `inputMediaStream` is by default used to construct one {@link CanvasVideoFrameBuffer}\n     * The buffer will be fed into the first {@link VideoFrameProcessor}.\n     */\n    setInputMediaStream(inputMediaStream) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!inputMediaStream) {\n                this.stop();\n                return;\n            }\n            if (inputMediaStream.getVideoTracks().length === 0) {\n                this.logger.error('No video tracks in input media stream, ignoring');\n                return;\n            }\n            this.inputVideoStream = inputMediaStream;\n            const settings = this.inputVideoStream.getVideoTracks()[0].getSettings();\n            this.logger.info(`processing pipeline input stream settings ${settings}`);\n            this.canvasOutput.width = settings.width;\n            this.canvasOutput.height = settings.height;\n            this.videoInput.addEventListener('loadedmetadata', this.process);\n            this.videoInput.srcObject = this.inputVideoStream;\n            // avoid iOS safari full screen video\n            this.videoInput.setAttribute('playsinline', 'true');\n            // create sources\n            const canvasBuffer = new CanvasVideoFrameBuffer_1.default(this.canvasInput);\n            this.sourceBuffers.push(canvasBuffer);\n            this.videoInput.load();\n            yield this.videoInput.play();\n        });\n    }\n    set processors(stages) {\n        this.stages = stages;\n    }\n    get processors() {\n        return this.stages;\n    }\n    forEachObserver(observerFunc) {\n        for (const observer of this.observers) {\n            setTimeout(() => {\n                observerFunc(observer);\n            }, 0);\n        }\n    }\n    destroyInputMediaStreamAndBuffers() {\n        if (this.inputVideoStream) {\n            for (const track of this.inputVideoStream.getTracks()) {\n                track.stop();\n            }\n        }\n        this.inputVideoStream = null;\n        for (const buffer of this.sourceBuffers) {\n            buffer.destroy();\n        }\n        this.sourceBuffers = [];\n    }\n}\nexports.default = DefaultVideoFrameProcessorPipeline;\n//# sourceMappingURL=DefaultVideoFrameProcessorPipeline.js.map"]},"metadata":{},"sourceType":"script"}