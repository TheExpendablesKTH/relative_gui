{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nconst Maybe_1 = require(\"../maybe/Maybe\");\n\nconst DefaultMediaDeviceFactory_1 = require(\"../mediadevicefactory/DefaultMediaDeviceFactory\");\n\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\n\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\n\nconst DefaultVideoTile_1 = require(\"../videotile/DefaultVideoTile\");\n\nconst AudioTransformDevice_1 = require(\"./AudioTransformDevice\");\n\nconst DeviceSelection_1 = require(\"./DeviceSelection\");\n\nconst GetUserMediaError_1 = require(\"./GetUserMediaError\");\n\nconst NotFoundError_1 = require(\"./NotFoundError\");\n\nconst NotReadableError_1 = require(\"./NotReadableError\");\n\nconst OverconstrainedError_1 = require(\"./OverconstrainedError\");\n\nconst PermissionDeniedError_1 = require(\"./PermissionDeniedError\");\n\nconst TypeError_1 = require(\"./TypeError\");\n\nconst VideoQualitySettings_1 = require(\"./VideoQualitySettings\");\n\nconst VideoTransformDevice_1 = require(\"./VideoTransformDevice\");\n\nfunction fillSMPTEColorBars(canvas, xShift) {\n  const w = canvas.width;\n  const h = canvas.height;\n  const h1 = h * 2 / 3;\n  const h2 = h * 3 / 4;\n  const h3 = h;\n  const top = ['#c0c0c0', '#c0c000', '#00c0c0', '#00c000', '#c000c0', '#c00000', '#0000c0'];\n  const middle = ['#0000c0', '#000000', '#c000c0', '#000000', '#00c0c0', '#000000', '#c0c0c0'];\n  const bottom = ['#00214c', '#ffffff', '#32006a', '#131313', '#090909', '#131313', '#1d1d1d', '#131313'];\n  const bottomX = [w * 0, w * 1 / 4 * (5 / 7), w * 2 / 4 * (5 / 7), w * 3 / 4 * (5 / 7), w * (5 / 7), w * (5 / 7 + 1 / 21), w * (5 / 7 + 2 / 21), w * (6 / 7), w * 1];\n  const segmentWidth = w / top.length;\n  const ctx = canvas.getContext('2d');\n\n  for (let i = 0; i < top.length; i++) {\n    ctx.fillStyle = top[i];\n    ctx.fillRect(xShift + i * segmentWidth, 0, segmentWidth, h1);\n    ctx.fillStyle = middle[i];\n    ctx.fillRect(xShift + i * segmentWidth, h1, segmentWidth, h2 - h1);\n  }\n\n  for (let i = 0; i < bottom.length; i++) {\n    ctx.fillStyle = bottom[i];\n    ctx.fillRect(xShift + bottomX[i], h2, bottomX[i + 1] - bottomX[i], h3 - h2);\n  }\n} // This is a top-level function so that its captured environment is as small as possible,\n// minimizing leaks -- the interval scheduler will cause everything here to be retained\n// until it is stopped.\n\n\nfunction makeColorBars(canvas, colorOrPattern) {\n  const scheduler = new IntervalScheduler_1.default(1000);\n  const context = canvas.getContext('2d'); // @ts-ignore\n\n  const stream = canvas.captureStream(5) || null;\n\n  if (!stream) {\n    return undefined;\n  }\n\n  const onTick = () => {\n    if (colorOrPattern === 'smpte') {\n      fillSMPTEColorBars(canvas, 0);\n    } else {\n      context.fillStyle = colorOrPattern;\n      context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n  };\n\n  scheduler.start(onTick);\n\n  const listener = () => {\n    scheduler.stop();\n  }; // This event listener will leak unless you remove it.\n\n\n  stream.getVideoTracks()[0].addEventListener('ended', listener);\n  return {\n    listener,\n    scheduler,\n    stream\n  };\n}\n\nclass DefaultDeviceController {\n  constructor(logger, options, browserBehavior = new DefaultBrowserBehavior_1.default()) {\n    this.logger = logger;\n    this.browserBehavior = browserBehavior;\n    this.deviceInfoCache = null;\n    this.activeDevices = {\n      audio: null,\n      video: null\n    }; // `chosenVideoTransformDevice` is tracked and owned by device controller.\n    // It is saved when `chooseVideoInputDevice` is called with VideoTransformDevice object.\n\n    this.chosenVideoTransformDevice = null;\n    this.audioOutputDeviceId = null;\n    this.deviceChangeObservers = new Set();\n\n    this.deviceLabelTrigger = () => {\n      return navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true\n      });\n    };\n\n    this.audioInputDestinationNode = null;\n    this.audioInputSourceNode = null;\n    this.videoInputQualitySettings = null;\n    this.useWebAudio = false;\n    this.inputDeviceCount = 0;\n    this.alreadyHandlingDeviceChange = false;\n    const {\n      enableWebAudio = false\n    } = options || {};\n    this.useWebAudio = enableWebAudio;\n\n    this.muteCallback = muted => {\n      var _a;\n\n      (_a = this.transform) === null || _a === void 0 ? void 0 : _a.device.mute(muted);\n    };\n\n    this.videoInputQualitySettings = new VideoQualitySettings_1.default(DefaultDeviceController.defaultVideoWidth, DefaultDeviceController.defaultVideoHeight, DefaultDeviceController.defaultVideoFrameRate, DefaultDeviceController.defaultVideoMaxBandwidthKbps);\n    const dimension = this.browserBehavior.requiresResolutionAlignment(this.videoInputQualitySettings.videoWidth, this.videoInputQualitySettings.videoHeight);\n    this.videoInputQualitySettings.videoWidth = dimension[0];\n    this.videoInputQualitySettings.videoHeight = dimension[1];\n    this.logger.info(`DefaultDeviceController video dimension ${this.videoInputQualitySettings.videoWidth} x ${this.videoInputQualitySettings.videoHeight}`);\n\n    try {\n      this.mediaDeviceWrapper = new DefaultMediaDeviceFactory_1.default().create();\n      const supportedConstraints = navigator.mediaDevices.getSupportedConstraints();\n      this.logger.info(`Supported Constraints in this browser ${JSON.stringify(supportedConstraints)}`);\n    } catch (error) {\n      logger.error(error.message);\n    }\n  }\n\n  isWatchingForDeviceChanges() {\n    return !!this.onDeviceChangeCallback;\n  }\n\n  ensureWatchingDeviceChanges() {\n    if (this.isWatchingForDeviceChanges()) {\n      return;\n    }\n\n    this.logger.info('Starting devicechange listener.');\n\n    this.onDeviceChangeCallback = () => this.handleDeviceChange();\n\n    this.mediaDeviceWrapper.addEventListener('devicechange', this.onDeviceChangeCallback);\n  }\n  /**\n   * Unsubscribe from the `devicechange` event, which allows the device controller to\n   * update its device cache.\n   */\n\n\n  stopWatchingDeviceChanges() {\n    if (!this.isWatchingForDeviceChanges()) {\n      return;\n    }\n\n    this.logger.info('Stopping devicechange listener.');\n    this.mediaDeviceWrapper.removeEventListener('devicechange', this.onDeviceChangeCallback);\n    this.onDeviceChangeCallback = undefined;\n  }\n\n  shouldObserveDeviceChanges() {\n    if (this.deviceChangeObservers.size) {\n      return true;\n    }\n\n    const hasActiveDevices = this.activeDevices['audio'] && this.activeDevices['audio'].constraints !== null || this.activeDevices['video'] && this.activeDevices['video'].constraints !== null || !!this.audioOutputDeviceId;\n    return hasActiveDevices;\n  }\n\n  watchForDeviceChangesIfNecessary() {\n    if (this.shouldObserveDeviceChanges()) {\n      this.ensureWatchingDeviceChanges();\n    } else {\n      this.stopWatchingDeviceChanges();\n    }\n  }\n\n  destroy() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      // Remove device change callbacks.\n      this.stopWatchingDeviceChanges(); // Deselect any audio input devices and throw away the streams.\n      // Discard the current video device, if there is one.\n      // Discard any audio or video transforms.\n\n      yield this.chooseAudioInputDevice(null);\n      yield this.chooseVideoInputDevice(null); // Tear down any Web Audio infrastructure we have hanging around.\n\n      (_a = this.audioInputSourceNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n      (_b = this.audioInputDestinationNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n      this.audioInputSourceNode = undefined;\n      this.audioInputDestinationNode = undefined;\n    });\n  }\n\n  listAudioInputDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.listDevicesOfKind('audioinput');\n      this.trace('listAudioInputDevices', null, result);\n      return result;\n    });\n  }\n\n  listVideoInputDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.listDevicesOfKind('videoinput');\n      this.trace('listVideoInputDevices', null, result);\n      return result;\n    });\n  }\n\n  listAudioOutputDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.listDevicesOfKind('audiooutput');\n      this.trace('listAudioOutputDevices', null, result);\n      return result;\n    });\n  }\n\n  pushAudioMeetingStateForPermissions(device) {\n    var _a, _b;\n\n    (_b = (_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.eventController) === null || _b === void 0 ? void 0 : _b.publishEvent(device === null ? 'audioInputUnselected' : 'audioInputSelected');\n  }\n\n  pushVideoMeetingStateForPermissions(device) {\n    var _a, _b;\n\n    (_b = (_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.eventController) === null || _b === void 0 ? void 0 : _b.publishEvent(device === null ? 'videoInputUnselected' : 'videoInputSelected');\n  }\n\n  chooseAudioInputDevice(device) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (device === undefined) {\n        this.logger.error('Audio input device cannot be undefined');\n        return;\n      }\n\n      if (AudioTransformDevice_1.isAudioTransformDevice(device)) {\n        // N.B., do not JSON.stringify here — for some kinds of devices this\n        // will cause a cyclic object reference error.\n        this.logger.info(`Choosing transform input device ${device}`);\n        /*\n         * This block of code is a workaround for a Chromium bug:\n         * https://bugs.chromium.org/p/chromium/issues/detail?id=1173656\n         *\n         * In short: if we are about to select an audio device with a transform, which we assume for\n         * safety's sake uses AudioWorklet, we recreate the audio context and the nodes that\n         * are linked to it.\n         *\n         * This causes Chrome to rejig its buffers and the second context works correctly.\n         *\n         * This is theoretically worse for performance, but in practice it is fine.\n         *\n         * This is not safe in the general case: an application that already\n         * retrieved the audio context in order to build an audio graph for some other purpose\n         * will fail at this point as we pull the context out from under it.\n         *\n         * An application that always uses the supplied context in an\n         * `AudioTransformDevice.createAudioNode` call should work correctly.\n         *\n         * If you are confident that your application does not use AudioWorklet, does not run in\n         * an un-fixed Chromium version, or will never be used with sample-rate-switching Bluetooth\n         * devices, you can disable this workaround by suppling a custom {@link ExtendedBrowserBehavior}\n         * when you create your device controller.\n         *\n         * We can't tell in advance whether we need to give the device a different audio context,\n         * because checking whether the resulting node is an AudioWorkletNode needs it to have been\n         * created first.\n         */\n\n        const recreateAudioContext = this.browserBehavior.requiresContextRecreationForAudioWorklet();\n\n        if (recreateAudioContext) {\n          this.logger.info('Recreating audio context when selecting transform device.');\n\n          if (this.transform) {\n            /* istanbul ignore else */\n            if (this.transform.nodes) {\n              this.transform.nodes.end.disconnect();\n              this.transform.nodes = undefined;\n            }\n\n            this.transform = undefined;\n          }\n          /* istanbul ignore else */\n\n\n          if (this.audioInputSourceNode) {\n            this.audioInputSourceNode.disconnect();\n            this.audioInputSourceNode = undefined;\n          }\n          /* istanbul ignore else */\n\n\n          if (this.audioInputDestinationNode) {\n            this.audioInputDestinationNode.disconnect();\n            this.audioInputDestinationNode = undefined;\n          }\n\n          DefaultDeviceController.closeAudioContext();\n        }\n\n        yield this.chooseAudioTransformInputDevice(device);\n\n        if (recreateAudioContext && ((_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.rtcPeerConnection)) {\n          this.boundAudioVideoController.restartLocalAudio(() => {\n            this.logger.info('Local audio restarted.');\n          });\n        }\n\n        return this.pushAudioMeetingStateForPermissions(device);\n      }\n\n      this.removeTransform();\n      yield this.chooseInputIntrinsicDevice('audio', device, false);\n      this.trace('chooseAudioInputDevice', device, `success`);\n      this.pushAudioMeetingStateForPermissions(device);\n    });\n  }\n\n  chooseAudioTransformInputDevice(device) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (((_a = this.transform) === null || _a === void 0 ? void 0 : _a.device) === device) {\n        return;\n      }\n\n      if (!this.useWebAudio) {\n        throw new Error('Cannot apply transform device without enabling Web Audio.');\n      }\n\n      const context = DefaultDeviceController.getAudioContext();\n\n      if (context instanceof OfflineAudioContext) {// Nothing to do.\n      } else {\n        switch (context.state) {\n          case 'running':\n            // Nothing to do.\n            break;\n\n          case 'closed':\n            // A closed context cannot be used for creating nodes, so the correct\n            // thing to do is to raise a descriptive error sooner.\n            throw new Error('Cannot choose a transform device with a closed audio context.');\n\n          case 'suspended':\n            // A context might be suspended after page load. We try to resume it\n            // here, otherwise audio won't work.\n            yield context.resume();\n        }\n      }\n\n      let nodes;\n\n      try {\n        nodes = yield device.createAudioNode(context);\n      } catch (e) {\n        this.logger.error(`Unable to create transform device node: ${e}.`);\n        throw e;\n      } // Pick the plain ol' inner device as the source. It will be\n      // connected to the node.\n\n\n      const inner = yield device.intrinsicDevice();\n      yield this.chooseInputIntrinsicDevice('audio', inner, false);\n      this.logger.debug(`Got inner stream: ${inner}.`); // Otherwise, continue: hook up the new node.\n\n      this.setTransform(device, nodes);\n    });\n  }\n\n  chooseVideoTransformInputDevice(device) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (device === this.chosenVideoTransformDevice) {\n        this.logger.info('Reselecting same VideoTransformDevice');\n        return;\n      }\n\n      const prevVideoTransformDevice = this.chosenVideoTransformDevice;\n\n      if (prevVideoTransformDevice) {\n        this.logger.info('Switched from previous VideoTransformDevice');\n      }\n\n      const wasUsingTransformDevice = !!prevVideoTransformDevice;\n      const inner = yield device.intrinsicDevice();\n      const canReuseMediaStream = this.isMediaStreamReusableByDeviceId((_a = this.activeDevices['video']) === null || _a === void 0 ? void 0 : _a.stream, inner);\n\n      if (!canReuseMediaStream) {\n        this.logger.info('video transform device needs new intrinsic device');\n\n        if (wasUsingTransformDevice) {\n          // detach input media stream - turn off the camera or leave it be if inner is media stream\n          prevVideoTransformDevice.onOutputStreamDisconnect();\n        }\n\n        this.chosenVideoTransformDevice = device; // VideoTransformDevice owns input MediaStream\n\n        this.activeDevices['video'] = null;\n        yield this.chooseInputIntrinsicDevice('video', inner, false, true);\n        return;\n      } // When saved stream is reusable, only switch the saved stream to filtered stream for sending\n      // but keep the saved stream intact.\n      // Note: to keep the chosen media stream intact, it is important to avoid a full stop\n      // because videoTileUpdate can be called when video is stopped and user might call `bindVideoElement` to disconnect the element.\n      // In current implementation, disconnecting the element will `hard` stop the media stream.\n      // Update device and stream\n\n\n      this.chosenVideoTransformDevice = device;\n      const newMediaStream = this.activeDevices['video'].stream;\n      this.logger.info('video transform device uses previous stream'); // Input is not a MediaStream. Update constraints\n\n      if (!inner.id) {\n        const constraint = inner;\n        constraint.width = constraint.width || this.videoInputQualitySettings.videoWidth;\n        constraint.height = constraint.height || this.videoInputQualitySettings.videoHeight;\n        constraint.frameRate = constraint.frameRate || this.videoInputQualitySettings.videoFrameRate;\n        yield newMediaStream.getVideoTracks()[0].applyConstraints(constraint);\n      } // `transformStream` will start processing.\n\n\n      yield device.transformStream(this.activeDevices['video'].stream); // Replace video to send\n\n      if ((_b = this.boundAudioVideoController) === null || _b === void 0 ? void 0 : _b.videoTileController.hasStartedLocalVideoTile()) {\n        // optimized method exists, a negotiation can be avoided\n        if (this.boundAudioVideoController.replaceLocalVideo) {\n          this.restartLocalVideoAfterSelection(null, false, true);\n        } else {\n          // non-optimized path, a negotiation is coming\n          yield this.boundAudioVideoController.update();\n        }\n      }\n    });\n  }\n\n  chooseVideoInputDevice(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (device === undefined) {\n        this.logger.error('Video input device cannot be undefined');\n        return;\n      }\n\n      if (VideoTransformDevice_1.isVideoTransformDevice(device)) {\n        this.logger.info(`Choosing video transform device ${device}`);\n        return this.chooseVideoTransformInputDevice(device);\n      }\n\n      this.updateMaxBandwidthKbps(); // handle direct switching from VideoTransformDevice to Device\n      // From WebRTC point, it is a device switching.\n\n      if (this.chosenVideoInputIsTransformDevice()) {\n        // disconnect old stream\n        this.chosenVideoTransformDevice.onOutputStreamDisconnect();\n        this.chosenVideoTransformDevice = null;\n      }\n\n      yield this.chooseInputIntrinsicDevice('video', device, false);\n      this.trace('chooseVideoInputDevice', device);\n      this.pushVideoMeetingStateForPermissions(device);\n    });\n  }\n\n  chooseAudioOutputDevice(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.audioOutputDeviceId = deviceId;\n      this.watchForDeviceChangesIfNecessary();\n      yield this.bindAudioOutput();\n      this.trace('chooseAudioOutputDevice', deviceId, null);\n      return;\n    });\n  }\n\n  addDeviceChangeObserver(observer) {\n    this.logger.info('adding device change observer');\n    this.deviceChangeObservers.add(observer);\n    this.watchForDeviceChangesIfNecessary();\n    this.trace('addDeviceChangeObserver');\n  }\n\n  removeDeviceChangeObserver(observer) {\n    this.logger.info('removing device change observer');\n    this.deviceChangeObservers.delete(observer);\n    this.watchForDeviceChangesIfNecessary();\n    this.trace('removeDeviceChangeObserver');\n  }\n\n  createAnalyserNodeForAudioInput() {\n    var _a, _b;\n\n    if (!this.activeDevices['audio']) {\n      return null;\n    } // If there is a WebAudio node in the graph, we use that as the source instead of the stream.\n\n\n    const node = (_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.end;\n\n    if (node) {\n      const analyser = node.context.createAnalyser();\n\n      analyser.removeOriginalInputs = () => {\n        try {\n          node.disconnect(analyser);\n        } catch (e) {// This can fail in some unusual cases, but this is best-effort.\n        }\n      };\n\n      node.connect(analyser);\n      return analyser;\n    }\n\n    return this.createAnalyserNodeForRawAudioInput();\n  } //\n  // N.B., this bypasses any applied transform node.\n  //\n\n\n  createAnalyserNodeForRawAudioInput() {\n    if (!this.activeDevices['audio']) {\n      return null;\n    }\n\n    return this.createAnalyserNodeForStream(this.activeDevices['audio'].stream);\n  }\n\n  createAnalyserNodeForStream(stream) {\n    const audioContext = DefaultDeviceController.getAudioContext();\n    const analyser = audioContext.createAnalyser();\n    const source = audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n    this.trace('createAnalyserNodeForAudioInput');\n\n    analyser.removeOriginalInputs = () => {\n      try {\n        source.disconnect(analyser);\n      } catch (e) {// This can fail in some unusual cases, but this is best-effort.\n      }\n    };\n\n    return analyser;\n  }\n\n  startVideoPreviewForVideoInput(element) {\n    if (!this.activeDevices['video']) {\n      this.logger.warn('cannot bind video preview since video input device has not been chosen');\n      this.trace('startVideoPreviewForVideoInput', element.id);\n      return;\n    } // TODO: implement MediaDestroyer to provide single release MediaStream function\n\n\n    this.releaseMediaStream(element.srcObject);\n    DefaultVideoTile_1.default.disconnectVideoStreamFromVideoElement(element, false);\n    navigator.mediaDevices.getUserMedia(this.activeDevices['video'].constraints).then(previewStream => {\n      DefaultVideoTile_1.default.connectVideoStreamToVideoElement(previewStream, element, true);\n    }).catch(error => {\n      this.logger.warn(`Unable to reacquire video stream for preview to element ${element.id}: ${error}`);\n    });\n    this.trace('startVideoPreviewForVideoInput', element.id);\n  }\n\n  stopVideoPreviewForVideoInput(element) {\n    const stream = element.srcObject;\n    const activeVideoDevice = this.activeDevices['video']; // Safety.\n\n    /* istanbul ignore else */\n\n    if (activeVideoDevice) {\n      this.releaseActiveDevice(activeVideoDevice);\n    }\n\n    if (stream) {\n      this.releaseMediaStream(stream);\n      DefaultVideoTile_1.default.disconnectVideoStreamFromVideoElement(element, false);\n    }\n\n    this.trace('stopVideoPreviewForVideoInput', element.id);\n  }\n\n  setDeviceLabelTrigger(trigger) {\n    this.deviceLabelTrigger = trigger;\n    this.trace('setDeviceLabelTrigger');\n  }\n\n  mixIntoAudioInput(stream) {\n    let node = null;\n\n    if (this.useWebAudio) {\n      node = DefaultDeviceController.getAudioContext().createMediaStreamSource(stream);\n      node.connect(this.getMediaStreamOutputNode());\n    } else {\n      this.logger.warn('WebAudio is not enabled, mixIntoAudioInput will not work');\n    }\n\n    this.trace('mixIntoAudioInput', stream.id);\n    return node;\n  }\n\n  chooseVideoInputQuality(width, height, frameRate, maxBandwidthKbps) {\n    const dimension = this.browserBehavior.requiresResolutionAlignment(width, height);\n    this.videoInputQualitySettings = new VideoQualitySettings_1.default(dimension[0], dimension[1], frameRate, maxBandwidthKbps);\n    this.updateMaxBandwidthKbps();\n  }\n\n  getVideoInputQualitySettings() {\n    return this.videoInputQualitySettings;\n  }\n\n  acquireAudioInputStream() {\n    return this.acquireInputStream('audio');\n  }\n\n  acquireVideoInputStream() {\n    return this.acquireInputStream('video');\n  }\n\n  acquireDisplayInputStream(streamConstraints) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (streamConstraints && streamConstraints.video && // @ts-ignore\n      streamConstraints.video.mandatory && // @ts-ignore\n      streamConstraints.video.mandatory.chromeMediaSource && // @ts-ignore\n      streamConstraints.video.mandatory.chromeMediaSourceId) {\n        return navigator.mediaDevices.getUserMedia(streamConstraints);\n      } // @ts-ignore https://github.com/microsoft/TypeScript/issues/31821\n\n\n      return navigator.mediaDevices.getDisplayMedia(streamConstraints);\n    });\n  }\n  /**\n   * This function helps `releaseMediaStream` do the right thing.\n   *\n   * We need to do three things:\n   *\n   * * Close the tracks of the source stream.\n   * * Remove the transform.\n   * * Clean up the _source_ stream's callback, as if `releaseMediaStream` had\n   *   been called with that stream -- that's the stream that's tracked in\n   *   `activeDevices` and needs to have its callbacks removed.\n   *\n   * This is a little fiddly because the stream broker interface doesn't\n   * know about the innards of the device controller, and only has the\n   * meeting session state's stream to work with.\n   *\n   */\n\n\n  releaseAudioTransformStream() {\n    this.logger.info('Stopping audio track for Web Audio graph');\n    this.stopTracksAndRemoveCallback('audio');\n    this.logger.info('Removing audio transform, if there is one.');\n    this.removeTransform(); // Remove the input and output nodes. They will be recreated later if\n    // needed.\n\n    this.audioInputSourceNode.disconnect();\n    this.audioInputSourceNode = undefined;\n    this.audioInputDestinationNode.disconnect();\n    this.audioInputDestinationNode = undefined;\n  }\n\n  releaseVideoTransformStream() {\n    this.logger.info('Stopping video track for transform');\n    this.stopTracksAndRemoveCallback('video');\n    this.logger.info('Disconnecting video transform');\n    this.chosenVideoTransformDevice.onOutputStreamDisconnect();\n    this.chosenVideoTransformDevice = null;\n  }\n\n  stopTracksAndRemoveCallback(kind) {\n    const activeDevice = this.activeDevices[kind];\n    /* istanbul ignore next */\n\n    const endedCallback = activeDevice === null || activeDevice === void 0 ? void 0 : activeDevice.endedCallback;\n\n    for (const track of activeDevice.stream.getTracks()) {\n      track.stop();\n      /* istanbul ignore else */\n\n      if (endedCallback) {\n        track.removeEventListener('ended', endedCallback);\n        delete activeDevice.endedCallback;\n      }\n\n      delete this.activeDevices[kind];\n    }\n  }\n\n  releaseOrdinaryStream(mediaStreamToRelease) {\n    var _a;\n\n    const tracksToStop = mediaStreamToRelease.getTracks();\n\n    if (!tracksToStop.length) {\n      return;\n    }\n\n    for (const track of tracksToStop) {\n      track.stop();\n    } // This function is called from `CleanStoppedSessionTask` using the\n    // session state, which does not allow us to clean up any associated 'ended'\n    // callbacks in advance. Look here to see if we have any to clean up.\n\n\n    for (const kind in this.activeDevices) {\n      const activeDevice = this.activeDevices[kind];\n\n      if ((activeDevice === null || activeDevice === void 0 ? void 0 : activeDevice.stream) !== mediaStreamToRelease) {\n        continue;\n      }\n\n      if (activeDevice.endedCallback) {\n        tracksToStop[0].removeEventListener('ended', activeDevice.endedCallback);\n        delete activeDevice.endedCallback;\n      }\n\n      delete this.activeDevices[kind];\n\n      if (kind === 'video' && ((_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.videoTileController.hasStartedLocalVideoTile())) {\n        this.boundAudioVideoController.videoTileController.stopLocalVideoTile();\n      }\n    }\n  }\n\n  releaseMediaStream(mediaStreamToRelease) {\n    var _a, _b;\n\n    if (!mediaStreamToRelease) {\n      return;\n    }\n\n    try {\n      // This method can be called with the output of an audio transform's\n      // Web Audio graph. That graph runs from a `MediaStreamSourceNode`, through\n      // the transform (if present), to a `MediaStreamDestinationNode`, and out to\n      // WebRTC.\n      //\n      // The call teardown task will call `releaseMediaStream` with the stream it\n      // receives — the destination stream.\n      //\n      // This function detects with this comparison:\n      const isReleasingAudioDestinationStream = mediaStreamToRelease === ((_a = this.audioInputDestinationNode) === null || _a === void 0 ? void 0 : _a.stream);\n\n      if (isReleasingAudioDestinationStream) {\n        this.releaseAudioTransformStream();\n        return;\n      } // Similarly, it can be called with a video transform's output stream.\n      // As with the Web Audio case, we need to release the actual input stream to\n      // really stop it.\n\n\n      const isReleasingVideoOutputStream = mediaStreamToRelease === ((_b = this.chosenVideoTransformDevice) === null || _b === void 0 ? void 0 : _b.outputMediaStream);\n\n      if (isReleasingVideoOutputStream) {\n        this.releaseVideoTransformStream();\n        return;\n      } // Otherwise, this is one of our inputs that was plumbed straight through to\n      // WebRTC. Go ahead and release it track by track.\n\n\n      this.releaseOrdinaryStream(mediaStreamToRelease);\n    } finally {\n      this.watchForDeviceChangesIfNecessary();\n    }\n  }\n\n  chosenVideoInputIsTransformDevice() {\n    return !!this.chosenVideoTransformDevice;\n  }\n\n  bindToAudioVideoController(audioVideoController) {\n    if (this.boundAudioVideoController) {\n      this.unsubscribeFromMuteAndUnmuteLocalAudio();\n    }\n\n    this.boundAudioVideoController = audioVideoController;\n    this.subscribeToMuteAndUnmuteLocalAudio();\n\n    if (this.browserBehavior.supportsSetSinkId()) {\n      AsyncScheduler_1.default.nextTick(() => {\n        this.bindAudioOutput();\n      });\n    }\n  }\n\n  subscribeToMuteAndUnmuteLocalAudio() {\n    if (!this.boundAudioVideoController) {\n      return;\n    } // Safety that's hard to test.\n\n    /* istanbul ignore next */\n\n\n    if (!this.boundAudioVideoController.realtimeController) {\n      return;\n    }\n\n    this.boundAudioVideoController.realtimeController.realtimeSubscribeToMuteAndUnmuteLocalAudio(this.muteCallback);\n  }\n\n  unsubscribeFromMuteAndUnmuteLocalAudio() {\n    // Safety that's hard to test.\n\n    /* istanbul ignore next */\n    if (!this.boundAudioVideoController.realtimeController) {\n      return;\n    }\n\n    this.boundAudioVideoController.realtimeController.realtimeUnsubscribeToMuteAndUnmuteLocalAudio(this.muteCallback);\n  }\n\n  static getIntrinsicDeviceId(device) {\n    if (device === undefined) {\n      return undefined;\n    }\n\n    if (device === null) {\n      return null;\n    }\n\n    if (typeof device === 'string') {\n      return device;\n    }\n\n    if (device.id) {\n      return device.id;\n    }\n\n    const constraints = device;\n    const deviceIdConstraints = constraints.deviceId;\n\n    if (deviceIdConstraints === undefined) {\n      return undefined;\n    }\n\n    if (deviceIdConstraints === null) {\n      return null;\n    }\n\n    if (typeof deviceIdConstraints === 'string' || Array.isArray(deviceIdConstraints)) {\n      return deviceIdConstraints;\n    }\n\n    const constraintStringParams = deviceIdConstraints;\n\n    if (typeof constraintStringParams.exact === 'string' || Array.isArray(constraintStringParams.exact)) {\n      return constraintStringParams.exact;\n    }\n\n    return undefined;\n  }\n\n  static createEmptyAudioDevice() {\n    return DefaultDeviceController.synthesizeAudioDevice(0);\n  }\n\n  static createEmptyVideoDevice() {\n    return DefaultDeviceController.synthesizeVideoDevice('black');\n  }\n\n  static synthesizeAudioDevice(toneHz) {\n    const audioContext = DefaultDeviceController.getAudioContext();\n    const outputNode = audioContext.createMediaStreamDestination();\n\n    if (!toneHz) {\n      const source = audioContext.createBufferSource(); // The AudioContext object uses the sample rate of the default output device\n      // if not specified. Creating an AudioBuffer object with the output device's\n      // sample rate fails in some browsers, e.g. Safari with a Bluetooth headphone.\n\n      try {\n        source.buffer = audioContext.createBuffer(1, audioContext.sampleRate * 5, audioContext.sampleRate);\n      } catch (error) {\n        if (error && error.name === 'NotSupportedError') {\n          source.buffer = audioContext.createBuffer(1, DefaultDeviceController.defaultSampleRate * 5, DefaultDeviceController.defaultSampleRate);\n        } else {\n          throw error;\n        }\n      } // Some browsers will not play audio out the MediaStreamDestination\n      // unless there is actually audio to play, so we add a small amount of\n      // noise here to ensure that audio is played out.\n\n\n      source.buffer.getChannelData(0)[0] = 0.0003;\n      source.loop = true;\n      source.connect(outputNode);\n      source.start();\n    } else {\n      const gainNode = audioContext.createGain();\n      gainNode.gain.value = 0.1;\n      gainNode.connect(outputNode);\n      const oscillatorNode = audioContext.createOscillator();\n      oscillatorNode.frequency.value = toneHz;\n      oscillatorNode.connect(gainNode);\n      oscillatorNode.start();\n    }\n\n    return outputNode.stream;\n  }\n\n  static synthesizeVideoDevice(colorOrPattern) {\n    const canvas = document.createElement('canvas');\n    canvas.width = 480;\n    canvas.height = canvas.width / 16 * 9;\n    const colorBars = makeColorBars(canvas, colorOrPattern);\n\n    if (!colorBars) {\n      return null;\n    } // `scheduler` and `listener` will leak.\n\n\n    const {\n      stream\n    } = colorBars;\n    return stream;\n  }\n\n  updateMaxBandwidthKbps() {\n    if (this.boundAudioVideoController) {\n      this.boundAudioVideoController.setVideoMaxBandwidthKbps(this.videoInputQualitySettings.videoMaxBandwidthKbps);\n    }\n  }\n\n  listDevicesOfKind(deviceKind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.deviceInfoCache === null || !this.isWatchingForDeviceChanges()) {\n        yield this.updateDeviceInfoCacheFromBrowser();\n      }\n\n      return this.listCachedDevicesOfKind(deviceKind);\n    });\n  }\n\n  updateDeviceInfoCacheFromBrowser() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const doesNotHaveAccessToMediaDevices = typeof MediaDeviceInfo === 'undefined';\n\n      if (doesNotHaveAccessToMediaDevices) {\n        this.deviceInfoCache = [];\n        return;\n      }\n\n      let devices = yield navigator.mediaDevices.enumerateDevices();\n      let hasDeviceLabels = true;\n\n      for (const device of devices) {\n        if (!device.label) {\n          hasDeviceLabels = false;\n          break;\n        }\n      }\n\n      if (!hasDeviceLabels) {\n        try {\n          this.logger.info('attempting to trigger media device labels since they are hidden');\n          const triggerStream = yield this.deviceLabelTrigger();\n          devices = yield navigator.mediaDevices.enumerateDevices();\n\n          for (const track of triggerStream.getTracks()) {\n            track.stop();\n          }\n        } catch (err) {\n          this.logger.info('unable to get media device labels');\n        }\n      }\n\n      this.deviceInfoCache = devices;\n    });\n  }\n\n  listCachedDevicesOfKind(deviceKind) {\n    const devicesOfKind = [];\n\n    for (const device of this.deviceInfoCache) {\n      if (device.kind === deviceKind) {\n        devicesOfKind.push(device);\n      }\n    }\n\n    return devicesOfKind;\n  }\n\n  handleDeviceChange() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.deviceInfoCache === null) {\n        return;\n      }\n\n      if (this.alreadyHandlingDeviceChange) {\n        AsyncScheduler_1.default.nextTick(() => {\n          this.handleDeviceChange();\n        });\n        return;\n      }\n\n      this.alreadyHandlingDeviceChange = true;\n      const oldAudioInputDevices = this.listCachedDevicesOfKind('audioinput');\n      const oldVideoInputDevices = this.listCachedDevicesOfKind('videoinput');\n      const oldAudioOutputDevices = this.listCachedDevicesOfKind('audiooutput');\n      yield this.updateDeviceInfoCacheFromBrowser();\n      const newAudioInputDevices = this.listCachedDevicesOfKind('audioinput');\n      const newVideoInputDevices = this.listCachedDevicesOfKind('videoinput');\n      const newAudioOutputDevices = this.listCachedDevicesOfKind('audiooutput');\n      this.forEachObserver(observer => {\n        if (!this.areDeviceListsEqual(oldAudioInputDevices, newAudioInputDevices)) {\n          Maybe_1.default.of(observer.audioInputsChanged).map(f => f.bind(observer)(newAudioInputDevices));\n        }\n\n        if (!this.areDeviceListsEqual(oldVideoInputDevices, newVideoInputDevices)) {\n          Maybe_1.default.of(observer.videoInputsChanged).map(f => f.bind(observer)(newVideoInputDevices));\n        }\n\n        if (!this.areDeviceListsEqual(oldAudioOutputDevices, newAudioOutputDevices)) {\n          Maybe_1.default.of(observer.audioOutputsChanged).map(f => f.bind(observer)(newAudioOutputDevices));\n        }\n      });\n      this.alreadyHandlingDeviceChange = false;\n    });\n  }\n\n  handleDeviceStreamEnded(kind, deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.chooseInputIntrinsicDevice(kind, null, false);\n      } catch (e) {\n        /* istanbul ignore next */\n        this.logger.error('Failed to choose null device after stream ended.');\n      }\n\n      if (kind === 'audio') {\n        this.forEachObserver(observer => {\n          Maybe_1.default.of(observer.audioInputStreamEnded).map(f => f.bind(observer)(deviceId));\n        });\n      } else {\n        this.forEachObserver(observer => {\n          Maybe_1.default.of(observer.videoInputStreamEnded).map(f => f.bind(observer)(deviceId));\n        });\n      }\n    });\n  }\n\n  forEachObserver(observerFunc) {\n    for (const observer of this.deviceChangeObservers) {\n      AsyncScheduler_1.default.nextTick(() => {\n        /* istanbul ignore else */\n        if (this.deviceChangeObservers.has(observer)) {\n          observerFunc(observer);\n        }\n      });\n    }\n  }\n\n  areDeviceListsEqual(a, b) {\n    return JSON.stringify(a.map(device => JSON.stringify(device)).sort()) === JSON.stringify(b.map(device => JSON.stringify(device)).sort());\n  }\n\n  intrinsicDeviceAsMediaStream(device) {\n    // @ts-ignore\n    return device && device.id ? device : null;\n  }\n\n  hasSameGroupId(groupId, kind, device) {\n    if (groupId === '') {\n      return true;\n    }\n\n    const deviceIds = DefaultDeviceController.getIntrinsicDeviceId(device);\n\n    if (typeof deviceIds === 'string' && groupId === this.getGroupIdFromDeviceId(kind, deviceIds)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getGroupIdFromDeviceId(kind, deviceId) {\n    if (this.deviceInfoCache !== null) {\n      const cachedDeviceInfo = this.listCachedDevicesOfKind(`${kind}input`).find(cachedDevice => cachedDevice.deviceId === deviceId);\n\n      if (cachedDeviceInfo && cachedDeviceInfo.groupId) {\n        return cachedDeviceInfo.groupId;\n      }\n    }\n\n    return '';\n  }\n\n  getActiveDeviceId(kind) {\n    /* istanbul ignore else */\n    if (this.activeDevices[kind] && this.activeDevices[kind].constraints) {\n      const activeDeviceMediaTrackConstraints = this.activeDevices[kind].constraints.audio || this.activeDevices[kind].constraints.video;\n      const activeDeviceConstrainDOMStringParameters = activeDeviceMediaTrackConstraints.deviceId;\n      let activeDeviceId;\n\n      if (typeof activeDeviceConstrainDOMStringParameters === 'string') {\n        activeDeviceId = activeDeviceConstrainDOMStringParameters;\n      } else {\n        activeDeviceId = activeDeviceConstrainDOMStringParameters.exact;\n      }\n\n      return activeDeviceId;\n    }\n    /* istanbul ignore next */\n\n\n    return null;\n  }\n\n  restartLocalVideoAfterSelection(oldDevice, fromAcquire, fromVideoTransformDevice) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!fromAcquire && this.boundAudioVideoController && this.boundAudioVideoController.videoTileController.hasStartedLocalVideoTile()) {\n        if (fromVideoTransformDevice) {\n          // similar to `useWebaudio`, either Device or VideoTransformDevice, `this.activeDevices['video']` tracks the supplied inner Device.\n          // Upon in-meeting switching to VideoTransformDevice, device controller releases old \"supplied\" stream and\n          // calls replaceLocalVideo to avoid a full stop-start update.\n          yield this.boundAudioVideoController.replaceLocalVideo();\n          this.logger.info('successfully replaced video track');\n\n          if (oldDevice === null || oldDevice === void 0 ? void 0 : oldDevice.stream.active) {\n            this.logger.warn('previous media stream is not stopped during restart video');\n            this.releaseActiveDevice(oldDevice);\n          }\n        } else {\n          // not from VideoTransformDevice, usual behavior.\n          this.logger.info('restarting local video to switch to new device');\n          this.boundAudioVideoController.restartLocalVideo(() => {\n            // TODO: implement MediaStreamDestroyer\n            // tracks of oldStream should be stopped when video tile is disconnected from MediaStream\n            // otherwise, camera is still being accessed and we need to stop it here.\n            if (oldDevice === null || oldDevice === void 0 ? void 0 : oldDevice.stream.active) {\n              this.logger.warn('previous media stream is not stopped during restart video');\n              this.releaseActiveDevice(oldDevice);\n            }\n          });\n        }\n      } else {\n        this.releaseActiveDevice(oldDevice);\n      }\n    });\n  }\n\n  handleGetUserMediaError(error, errorTimeMs) {\n    if (!error) {\n      throw new GetUserMediaError_1.default(error);\n    }\n\n    switch (error.name) {\n      case 'NotReadableError':\n      case 'TrackStartError':\n        throw new NotReadableError_1.default(error);\n\n      case 'NotFoundError':\n      case 'DevicesNotFoundError':\n        throw new NotFoundError_1.default(error);\n\n      case 'NotAllowedError':\n      case 'PermissionDeniedError':\n      case 'SecurityError':\n        if (errorTimeMs && errorTimeMs < DefaultDeviceController.permissionDeniedOriginDetectionThresholdMs) {\n          throw new PermissionDeniedError_1.default(error, 'Permission denied by browser');\n        } else {\n          throw new PermissionDeniedError_1.default(error, 'Permission denied by user');\n        }\n\n      case 'OverconstrainedError':\n      case 'ConstraintNotSatisfiedError':\n        throw new OverconstrainedError_1.default(error);\n\n      case 'TypeError':\n        throw new TypeError_1.default(error);\n\n      case 'AbortError':\n      default:\n        throw new GetUserMediaError_1.default(error);\n    }\n  }\n\n  releaseActiveDevice(device) {\n    if (!device || !device.stream) {\n      return;\n    }\n\n    if (device.endedCallback) {\n      const track = device.stream.getTracks()[0]; // Safety.\n\n      /* istanbul ignore else */\n\n      if (track) {\n        track.removeEventListener('ended', device.endedCallback);\n      }\n    }\n\n    delete device.endedCallback;\n    this.releaseMediaStream(device.stream);\n    delete device.stream;\n  }\n\n  chooseInputIntrinsicDevice(kind, device, fromAcquire, fromVideoTransformDevice = false) {\n    var _a, _b, _c, _d, _e;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      this.inputDeviceCount += 1;\n      const callCount = this.inputDeviceCount;\n\n      if (device === null && kind === 'video') {\n        this.lastNoVideoInputDeviceCount = this.inputDeviceCount;\n        const active = this.activeDevices[kind];\n\n        if (active) {\n          this.releaseActiveDevice(active);\n          delete this.activeDevices[kind];\n          this.watchForDeviceChangesIfNecessary();\n        }\n\n        return;\n      } // N.B.,: the input device might already have augmented constraints supplied\n      // by an `AudioTransformDevice`. `calculateMediaStreamConstraints` will respect\n      // settings supplied by the device.\n\n\n      const proposedConstraints = this.calculateMediaStreamConstraints(kind, device); // TODO: `matchesConstraints` should really return compatible/incompatible/exact --\n      // `applyConstraints` can be used to reuse the active device while changing the\n      // requested constraints.\n\n      if (this.activeDevices[kind] && this.activeDevices[kind].matchesConstraints(proposedConstraints) && this.activeDevices[kind].stream.active && this.activeDevices[kind].groupId !== null && this.hasSameGroupId(this.activeDevices[kind].groupId, kind, device)) {\n        this.logger.info(`reusing existing ${kind} device`);\n        return;\n      }\n\n      if (kind === 'audio' && this.activeDevices[kind] && this.activeDevices[kind].stream) {\n        this.releaseActiveDevice(this.activeDevices[kind]);\n      }\n\n      const startTimeMs = Date.now();\n      const newDevice = new DeviceSelection_1.default();\n\n      try {\n        this.logger.info(`requesting new ${kind} device with constraint ${JSON.stringify(proposedConstraints)}`);\n        const stream = this.intrinsicDeviceAsMediaStream(device);\n\n        if (kind === 'audio' && device === null) {\n          newDevice.stream = DefaultDeviceController.createEmptyAudioDevice();\n          newDevice.constraints = null;\n        } else if (stream) {\n          this.logger.info(`using media stream ${stream.id} for ${kind} device`);\n          newDevice.stream = stream;\n          newDevice.constraints = proposedConstraints;\n        } else {\n          newDevice.stream = yield navigator.mediaDevices.getUserMedia(proposedConstraints);\n          newDevice.constraints = proposedConstraints;\n\n          if (kind === 'video' && this.lastNoVideoInputDeviceCount > callCount) {\n            this.logger.warn(`ignored to get video device for constraints ${JSON.stringify(proposedConstraints)} as no device was requested`);\n            this.releaseMediaStream(newDevice.stream);\n            return;\n          }\n\n          yield this.handleDeviceChange();\n          const track = newDevice.stream.getTracks()[0];\n\n          newDevice.endedCallback = () => {\n            // Hard to test, but the safety check is worthwhile.\n\n            /* istanbul ignore else */\n            if (this.activeDevices[kind] && this.activeDevices[kind].stream === newDevice.stream) {\n              this.logger.warn(`${kind} input device which was active is no longer available, resetting to null device`);\n              this.handleDeviceStreamEnded(kind, this.getActiveDeviceId(kind));\n              delete newDevice.endedCallback;\n            }\n          };\n\n          track.addEventListener('ended', newDevice.endedCallback, {\n            once: true\n          });\n        }\n\n        newDevice.groupId = ((_a = this.getMediaTrackSettings(newDevice.stream)) === null || _a === void 0 ? void 0 : _a.groupId) || '';\n      } catch (error) {\n        let errorMessage;\n\n        if ((error === null || error === void 0 ? void 0 : error.name) && error.message) {\n          errorMessage = `${error.name}: ${error.message}`;\n        } else if (error === null || error === void 0 ? void 0 : error.name) {\n          errorMessage = error.name;\n        } else if (error === null || error === void 0 ? void 0 : error.message) {\n          errorMessage = error.message;\n        } else {\n          errorMessage = 'UnknownError';\n        }\n\n        if (kind === 'audio') {\n          (_c = (_b = this.boundAudioVideoController) === null || _b === void 0 ? void 0 : _b.eventController) === null || _c === void 0 ? void 0 : _c.publishEvent('audioInputFailed', {\n            audioInputErrorMessage: errorMessage\n          });\n        } else {\n          (_e = (_d = this.boundAudioVideoController) === null || _d === void 0 ? void 0 : _d.eventController) === null || _e === void 0 ? void 0 : _e.publishEvent('videoInputFailed', {\n            videoInputErrorMessage: errorMessage\n          });\n        }\n\n        this.logger.error(`failed to get ${kind} device for constraints ${JSON.stringify(proposedConstraints)}: ${errorMessage}`); // This is effectively `error instanceof OverconstrainedError` but works in Node.\n\n        if (error && 'constraint' in error) {\n          this.logger.error(`Over-constrained by constraint: ${error.constraint}`);\n        }\n        /*\n         * If there is any error while acquiring the audio device, we fall back to null device.\n         * Reason: If device selection fails (e.g. NotReadableError), the peer connection is left hanging\n         * with no active audio track since we release the previously attached track.\n         * If no audio packet has yet been sent to the server, the server will not emit the joined event.\n         */\n\n\n        if (kind === 'audio') {\n          this.logger.info(`choosing null ${kind} device instead`);\n\n          try {\n            newDevice.stream = DefaultDeviceController.createEmptyAudioDevice();\n            newDevice.constraints = null;\n            yield this.handleNewInputDevice(kind, newDevice, fromAcquire);\n          } catch (error) {\n            this.logger.error(`failed to choose null ${kind} device. ${error.name}: ${error.message}`);\n          }\n        }\n\n        this.handleGetUserMediaError(error, Date.now() - startTimeMs);\n      } finally {\n        this.watchForDeviceChangesIfNecessary();\n      }\n\n      this.logger.info(`got ${kind} device for constraints ${JSON.stringify(proposedConstraints)}`);\n      yield this.handleNewInputDevice(kind, newDevice, fromAcquire, fromVideoTransformDevice);\n      return;\n    });\n  }\n\n  handleNewInputDevice(kind, newDevice, fromAcquire, fromVideoTransformDevice = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const oldDevice = this.activeDevices[kind];\n      this.activeDevices[kind] = newDevice;\n      this.watchForDeviceChangesIfNecessary();\n\n      if (kind === 'video') {\n        // attempts to mirror `this.useWebAudio`. The difference is that audio destination stream stays the same\n        // but video sending needs to switch streams.\n        if (this.chosenVideoInputIsTransformDevice()) {\n          this.logger.info('apply processors to transform');\n          yield this.chosenVideoTransformDevice.transformStream(this.activeDevices['video'].stream);\n        }\n\n        yield this.restartLocalVideoAfterSelection(oldDevice, fromAcquire, fromVideoTransformDevice);\n      } else {\n        this.releaseActiveDevice(oldDevice);\n\n        if (this.useWebAudio) {\n          this.attachAudioInputStreamToAudioContext(this.activeDevices[kind].stream);\n        } else if (this.boundAudioVideoController) {\n          try {\n            yield this.boundAudioVideoController.restartLocalAudio(() => {});\n          } catch (error) {\n            this.logger.info(`cannot replace audio track due to: ${error.message}`);\n          }\n        } else {\n          this.logger.info('no audio-video controller is bound to the device controller');\n        }\n      }\n    });\n  }\n\n  bindAudioOutput() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.boundAudioVideoController) {\n        return;\n      }\n\n      const deviceInfo = this.deviceInfoFromDeviceId('audiooutput', this.audioOutputDeviceId);\n      yield this.boundAudioVideoController.audioMixController.bindAudioDevice(deviceInfo);\n    });\n  }\n\n  calculateMediaStreamConstraints(kind, device) {\n    let trackConstraints = {};\n\n    if (device === '') {\n      device = null;\n    }\n\n    const stream = this.intrinsicDeviceAsMediaStream(device);\n\n    if (device === null) {\n      return null;\n    } else if (typeof device === 'string') {\n      if (this.browserBehavior.requiresNoExactMediaStreamConstraints() && this.browserBehavior.requiresGroupIdMediaStreamConstraints()) {\n        // In Samsung Internet browser, navigator.mediaDevices.enumerateDevices()\n        // returns same deviceId but different groupdId for some audioinput and videoinput devices.\n        // To handle this, we select appropriate device using deviceId + groupId.\n        trackConstraints.deviceId = device;\n        trackConstraints.groupId = this.getGroupIdFromDeviceId(kind, device);\n      } else if (this.browserBehavior.requiresNoExactMediaStreamConstraints()) {\n        trackConstraints.deviceId = device;\n      } else {\n        trackConstraints.deviceId = {\n          exact: device\n        };\n      }\n    } else if (stream) {\n      // @ts-ignore - create a fake track constraint using the stream id\n      trackConstraints.streamId = stream.id;\n    } else if (isMediaDeviceInfo(device)) {\n      trackConstraints.deviceId = device.deviceId;\n      trackConstraints.groupId = device.groupId;\n    } else {\n      // Take the input set of constraints. Note that this allows\n      // the builder to specify overrides for properties like `autoGainControl`.\n      // @ts-ignore - device is a MediaTrackConstraints\n      trackConstraints = device;\n    }\n\n    if (kind === 'video') {\n      trackConstraints.width = trackConstraints.width || {\n        ideal: this.videoInputQualitySettings.videoWidth\n      };\n      trackConstraints.height = trackConstraints.height || {\n        ideal: this.videoInputQualitySettings.videoHeight\n      };\n      trackConstraints.frameRate = trackConstraints.frameRate || {\n        ideal: this.videoInputQualitySettings.videoFrameRate\n      }; // TODO: try to replace hard-code value related to videos into quality-level presets\n      // The following configs relaxes CPU overuse detection threshold to offer better encoding quality\n      // @ts-ignore\n\n      trackConstraints.googCpuOveruseDetection = true; // @ts-ignore\n\n      trackConstraints.googCpuOveruseEncodeUsage = true; // @ts-ignore\n\n      trackConstraints.googCpuOveruseThreshold = 85; // @ts-ignore\n\n      trackConstraints.googCpuUnderuseThreshold = 55;\n    }\n\n    if (kind === 'audio' && this.supportSampleRateConstraint()) {\n      trackConstraints.sampleRate = {\n        ideal: DefaultDeviceController.defaultSampleRate\n      };\n    }\n\n    if (kind === 'audio' && this.supportSampleSizeConstraint()) {\n      trackConstraints.sampleSize = {\n        ideal: DefaultDeviceController.defaultSampleSize\n      };\n    }\n\n    if (kind === 'audio' && this.supportChannelCountConstraint()) {\n      trackConstraints.channelCount = {\n        ideal: DefaultDeviceController.defaultChannelCount\n      };\n    }\n\n    if (kind === 'audio') {\n      const augmented = Object.assign({\n        echoCancellation: true,\n        googEchoCancellation: true,\n        googEchoCancellation2: true,\n        googAutoGainControl: true,\n        googAutoGainControl2: true,\n        googNoiseSuppression: true,\n        googNoiseSuppression2: true,\n        googHighpassFilter: true\n      }, trackConstraints);\n      trackConstraints = augmented;\n    }\n\n    return kind === 'audio' ? {\n      audio: trackConstraints\n    } : {\n      video: trackConstraints\n    };\n  }\n\n  deviceInfoFromDeviceId(deviceKind, deviceId) {\n    if (this.deviceInfoCache === null) {\n      return null;\n    }\n\n    for (const device of this.deviceInfoCache) {\n      if (device.kind === deviceKind && device.deviceId === deviceId) {\n        return device;\n      }\n    }\n\n    return null;\n  }\n\n  acquireInputStream(kind) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (kind === 'audio') {\n        if (this.useWebAudio) {\n          const dest = this.getMediaStreamDestinationNode();\n          return dest.stream;\n        }\n      } // mirrors `this.useWebAudio`\n\n\n      if (kind === 'video') {\n        if (this.chosenVideoInputIsTransformDevice()) {\n          return this.chosenVideoTransformDevice.outputMediaStream;\n        }\n      }\n\n      let existingConstraints = null;\n\n      if (!this.activeDevices[kind]) {\n        if (kind === 'audio') {\n          this.logger.info(`no ${kind} device chosen, creating empty ${kind} device`);\n        } else {\n          this.logger.error(`no ${kind} device chosen, stopping local video tile`);\n          this.boundAudioVideoController.videoTileController.stopLocalVideoTile();\n          throw new Error(`no ${kind} device chosen, stopping local video tile`);\n        }\n      } else {\n        this.logger.info(`checking whether existing ${kind} device can be reused`);\n        const active = this.activeDevices[kind]; // @ts-ignore\n\n        existingConstraints = active.constraints ? active.constraints[kind] : null;\n      }\n\n      try {\n        yield this.chooseInputIntrinsicDevice(kind, existingConstraints, true);\n      } catch (e) {\n        this.logger.error(`unable to acquire ${kind} device`);\n\n        if (e instanceof PermissionDeniedError_1.default) {\n          throw e;\n        }\n\n        throw new GetUserMediaError_1.default(e, `unable to acquire ${kind} device`);\n      }\n\n      return this.activeDevices[kind].stream;\n    });\n  }\n\n  hasAppliedTransform() {\n    return !!this.transform;\n  }\n\n  isMediaStreamReusableByDeviceId(stream, device) {\n    // for null device, assume the stream is not reusable\n    if (!stream || !stream.active || !device) {\n      return false;\n    }\n\n    if (device.id) {\n      return stream.id === device.id;\n    }\n\n    const settings = this.getMediaTrackSettings(stream); // If a device does not specify deviceId, we have to assume the stream is not reusable.\n\n    if (!settings.deviceId) {\n      return false;\n    }\n\n    const deviceIds = DefaultDeviceController.getIntrinsicDeviceId(device);\n\n    if (typeof deviceIds === 'string') {\n      return settings.deviceId === deviceIds;\n    }\n\n    return false;\n  }\n\n  getMediaTrackSettings(stream) {\n    var _a;\n\n    return (_a = stream.getTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings();\n  }\n\n  reconnectAudioInputs() {\n    if (!this.audioInputSourceNode) {\n      return;\n    }\n\n    this.audioInputSourceNode.disconnect();\n    const output = this.getMediaStreamOutputNode();\n    this.audioInputSourceNode.connect(output);\n  }\n\n  setTransform(device, nodes) {\n    var _a, _b;\n\n    (_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.end.disconnect();\n    this.transform = {\n      nodes,\n      device\n    };\n    const proc = nodes === null || nodes === void 0 ? void 0 : nodes.end;\n    const dest = this.getMediaStreamDestinationNode();\n    this.logger.debug(`Connecting transform node ${proc} to destination ${dest}.`);\n    proc === null || proc === void 0 ? void 0 : proc.connect(dest);\n    this.reconnectAudioInputs();\n  }\n\n  removeTransform() {\n    var _a;\n\n    const previous = this.transform;\n\n    if (!previous) {\n      return undefined;\n    }\n\n    (_a = this.transform.nodes) === null || _a === void 0 ? void 0 : _a.end.disconnect();\n    this.transform = undefined;\n    this.reconnectAudioInputs();\n    return previous;\n  }\n\n  attachAudioInputStreamToAudioContext(stream) {\n    var _a;\n\n    (_a = this.audioInputSourceNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n    this.audioInputSourceNode = DefaultDeviceController.getAudioContext().createMediaStreamSource(stream);\n    const output = this.getMediaStreamOutputNode();\n    this.audioInputSourceNode.connect(output);\n  }\n  /**\n   * Return the end of the Web Audio graph: post-transform audio.\n   */\n\n\n  getMediaStreamDestinationNode() {\n    if (!this.audioInputDestinationNode) {\n      this.audioInputDestinationNode = DefaultDeviceController.getAudioContext().createMediaStreamDestination();\n    }\n\n    return this.audioInputDestinationNode;\n  }\n  /**\n   * Return the start of the Web Audio graph: pre-transform audio.\n   * If there's no transform node, this is the destination node.\n   */\n\n\n  getMediaStreamOutputNode() {\n    var _a, _b;\n\n    return ((_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.start) || this.getMediaStreamDestinationNode();\n  }\n\n  static getAudioContext() {\n    if (!DefaultDeviceController.audioContext) {\n      const options = {};\n\n      if (navigator.mediaDevices.getSupportedConstraints().sampleRate) {\n        options.sampleRate = DefaultDeviceController.defaultSampleRate;\n      } // @ts-ignore\n\n\n      DefaultDeviceController.audioContext = new (window.AudioContext || window.webkitAudioContext)(options);\n    }\n\n    return DefaultDeviceController.audioContext;\n  }\n\n  static closeAudioContext() {\n    if (DefaultDeviceController.audioContext) {\n      try {\n        DefaultDeviceController.audioContext.close();\n      } catch (e) {// Nothing we can do.\n      }\n    }\n\n    DefaultDeviceController.audioContext = null;\n  }\n\n  supportSampleRateConstraint() {\n    return this.useWebAudio && !!navigator.mediaDevices.getSupportedConstraints().sampleRate;\n  }\n\n  supportSampleSizeConstraint() {\n    return this.useWebAudio && !!navigator.mediaDevices.getSupportedConstraints().sampleSize;\n  }\n\n  supportChannelCountConstraint() {\n    return this.useWebAudio && !!navigator.mediaDevices.getSupportedConstraints().channelCount;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  trace(name, input, output) {\n    let s = `API/DefaultDeviceController/${name}`;\n\n    if (typeof input !== 'undefined') {\n      s += ` ${JSON.stringify(input)}`;\n    }\n\n    if (typeof output !== 'undefined') {\n      s += ` -> ${JSON.stringify(output)}`;\n    }\n\n    this.logger.info(s);\n  }\n\n}\n\nexports.default = DefaultDeviceController;\nDefaultDeviceController.permissionDeniedOriginDetectionThresholdMs = 500;\nDefaultDeviceController.defaultVideoWidth = 960;\nDefaultDeviceController.defaultVideoHeight = 540;\nDefaultDeviceController.defaultVideoFrameRate = 15;\nDefaultDeviceController.defaultVideoMaxBandwidthKbps = 1400;\nDefaultDeviceController.defaultSampleRate = 48000;\nDefaultDeviceController.defaultSampleSize = 16;\nDefaultDeviceController.defaultChannelCount = 1;\nDefaultDeviceController.audioContext = null;\n\nfunction isMediaDeviceInfo(device) {\n  return typeof device === 'object' && 'deviceId' in device && 'groupId' in device && 'kind' in device && 'label' in device;\n}","map":{"version":3,"sources":["../../src/devicecontroller/DefaultDeviceController.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\nconst Maybe_1 = require(\"../maybe/Maybe\");\nconst DefaultMediaDeviceFactory_1 = require(\"../mediadevicefactory/DefaultMediaDeviceFactory\");\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\nconst DefaultVideoTile_1 = require(\"../videotile/DefaultVideoTile\");\nconst AudioTransformDevice_1 = require(\"./AudioTransformDevice\");\nconst DeviceSelection_1 = require(\"./DeviceSelection\");\nconst GetUserMediaError_1 = require(\"./GetUserMediaError\");\nconst NotFoundError_1 = require(\"./NotFoundError\");\nconst NotReadableError_1 = require(\"./NotReadableError\");\nconst OverconstrainedError_1 = require(\"./OverconstrainedError\");\nconst PermissionDeniedError_1 = require(\"./PermissionDeniedError\");\nconst TypeError_1 = require(\"./TypeError\");\nconst VideoQualitySettings_1 = require(\"./VideoQualitySettings\");\nconst VideoTransformDevice_1 = require(\"./VideoTransformDevice\");\nfunction fillSMPTEColorBars(canvas, xShift) {\n    const w = canvas.width;\n    const h = canvas.height;\n    const h1 = (h * 2) / 3;\n    const h2 = (h * 3) / 4;\n    const h3 = h;\n    const top = ['#c0c0c0', '#c0c000', '#00c0c0', '#00c000', '#c000c0', '#c00000', '#0000c0'];\n    const middle = ['#0000c0', '#000000', '#c000c0', '#000000', '#00c0c0', '#000000', '#c0c0c0'];\n    const bottom = [\n        '#00214c',\n        '#ffffff',\n        '#32006a',\n        '#131313',\n        '#090909',\n        '#131313',\n        '#1d1d1d',\n        '#131313',\n    ];\n    const bottomX = [\n        w * 0,\n        ((w * 1) / 4) * (5 / 7),\n        ((w * 2) / 4) * (5 / 7),\n        ((w * 3) / 4) * (5 / 7),\n        w * (5 / 7),\n        w * (5 / 7 + 1 / 21),\n        w * (5 / 7 + 2 / 21),\n        w * (6 / 7),\n        w * 1,\n    ];\n    const segmentWidth = w / top.length;\n    const ctx = canvas.getContext('2d');\n    for (let i = 0; i < top.length; i++) {\n        ctx.fillStyle = top[i];\n        ctx.fillRect(xShift + i * segmentWidth, 0, segmentWidth, h1);\n        ctx.fillStyle = middle[i];\n        ctx.fillRect(xShift + i * segmentWidth, h1, segmentWidth, h2 - h1);\n    }\n    for (let i = 0; i < bottom.length; i++) {\n        ctx.fillStyle = bottom[i];\n        ctx.fillRect(xShift + bottomX[i], h2, bottomX[i + 1] - bottomX[i], h3 - h2);\n    }\n}\n// This is a top-level function so that its captured environment is as small as possible,\n// minimizing leaks -- the interval scheduler will cause everything here to be retained\n// until it is stopped.\nfunction makeColorBars(canvas, colorOrPattern) {\n    const scheduler = new IntervalScheduler_1.default(1000);\n    const context = canvas.getContext('2d');\n    // @ts-ignore\n    const stream = canvas.captureStream(5) || null;\n    if (!stream) {\n        return undefined;\n    }\n    const onTick = () => {\n        if (colorOrPattern === 'smpte') {\n            fillSMPTEColorBars(canvas, 0);\n        }\n        else {\n            context.fillStyle = colorOrPattern;\n            context.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    };\n    scheduler.start(onTick);\n    const listener = () => {\n        scheduler.stop();\n    };\n    // This event listener will leak unless you remove it.\n    stream.getVideoTracks()[0].addEventListener('ended', listener);\n    return { listener, scheduler, stream };\n}\nclass DefaultDeviceController {\n    constructor(logger, options, browserBehavior = new DefaultBrowserBehavior_1.default()) {\n        this.logger = logger;\n        this.browserBehavior = browserBehavior;\n        this.deviceInfoCache = null;\n        this.activeDevices = { audio: null, video: null };\n        // `chosenVideoTransformDevice` is tracked and owned by device controller.\n        // It is saved when `chooseVideoInputDevice` is called with VideoTransformDevice object.\n        this.chosenVideoTransformDevice = null;\n        this.audioOutputDeviceId = null;\n        this.deviceChangeObservers = new Set();\n        this.deviceLabelTrigger = () => {\n            return navigator.mediaDevices.getUserMedia({ audio: true, video: true });\n        };\n        this.audioInputDestinationNode = null;\n        this.audioInputSourceNode = null;\n        this.videoInputQualitySettings = null;\n        this.useWebAudio = false;\n        this.inputDeviceCount = 0;\n        this.alreadyHandlingDeviceChange = false;\n        const { enableWebAudio = false } = options || {};\n        this.useWebAudio = enableWebAudio;\n        this.muteCallback = (muted) => {\n            var _a;\n            (_a = this.transform) === null || _a === void 0 ? void 0 : _a.device.mute(muted);\n        };\n        this.videoInputQualitySettings = new VideoQualitySettings_1.default(DefaultDeviceController.defaultVideoWidth, DefaultDeviceController.defaultVideoHeight, DefaultDeviceController.defaultVideoFrameRate, DefaultDeviceController.defaultVideoMaxBandwidthKbps);\n        const dimension = this.browserBehavior.requiresResolutionAlignment(this.videoInputQualitySettings.videoWidth, this.videoInputQualitySettings.videoHeight);\n        this.videoInputQualitySettings.videoWidth = dimension[0];\n        this.videoInputQualitySettings.videoHeight = dimension[1];\n        this.logger.info(`DefaultDeviceController video dimension ${this.videoInputQualitySettings.videoWidth} x ${this.videoInputQualitySettings.videoHeight}`);\n        try {\n            this.mediaDeviceWrapper = new DefaultMediaDeviceFactory_1.default().create();\n            const supportedConstraints = navigator.mediaDevices.getSupportedConstraints();\n            this.logger.info(`Supported Constraints in this browser ${JSON.stringify(supportedConstraints)}`);\n        }\n        catch (error) {\n            logger.error(error.message);\n        }\n    }\n    isWatchingForDeviceChanges() {\n        return !!this.onDeviceChangeCallback;\n    }\n    ensureWatchingDeviceChanges() {\n        if (this.isWatchingForDeviceChanges()) {\n            return;\n        }\n        this.logger.info('Starting devicechange listener.');\n        this.onDeviceChangeCallback = () => this.handleDeviceChange();\n        this.mediaDeviceWrapper.addEventListener('devicechange', this.onDeviceChangeCallback);\n    }\n    /**\n     * Unsubscribe from the `devicechange` event, which allows the device controller to\n     * update its device cache.\n     */\n    stopWatchingDeviceChanges() {\n        if (!this.isWatchingForDeviceChanges()) {\n            return;\n        }\n        this.logger.info('Stopping devicechange listener.');\n        this.mediaDeviceWrapper.removeEventListener('devicechange', this.onDeviceChangeCallback);\n        this.onDeviceChangeCallback = undefined;\n    }\n    shouldObserveDeviceChanges() {\n        if (this.deviceChangeObservers.size) {\n            return true;\n        }\n        const hasActiveDevices = (this.activeDevices['audio'] && this.activeDevices['audio'].constraints !== null) ||\n            (this.activeDevices['video'] && this.activeDevices['video'].constraints !== null) ||\n            !!this.audioOutputDeviceId;\n        return hasActiveDevices;\n    }\n    watchForDeviceChangesIfNecessary() {\n        if (this.shouldObserveDeviceChanges()) {\n            this.ensureWatchingDeviceChanges();\n        }\n        else {\n            this.stopWatchingDeviceChanges();\n        }\n    }\n    destroy() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            // Remove device change callbacks.\n            this.stopWatchingDeviceChanges();\n            // Deselect any audio input devices and throw away the streams.\n            // Discard the current video device, if there is one.\n            // Discard any audio or video transforms.\n            yield this.chooseAudioInputDevice(null);\n            yield this.chooseVideoInputDevice(null);\n            // Tear down any Web Audio infrastructure we have hanging around.\n            (_a = this.audioInputSourceNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n            (_b = this.audioInputDestinationNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n            this.audioInputSourceNode = undefined;\n            this.audioInputDestinationNode = undefined;\n        });\n    }\n    listAudioInputDevices() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.listDevicesOfKind('audioinput');\n            this.trace('listAudioInputDevices', null, result);\n            return result;\n        });\n    }\n    listVideoInputDevices() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.listDevicesOfKind('videoinput');\n            this.trace('listVideoInputDevices', null, result);\n            return result;\n        });\n    }\n    listAudioOutputDevices() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.listDevicesOfKind('audiooutput');\n            this.trace('listAudioOutputDevices', null, result);\n            return result;\n        });\n    }\n    pushAudioMeetingStateForPermissions(device) {\n        var _a, _b;\n        (_b = (_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.eventController) === null || _b === void 0 ? void 0 : _b.publishEvent(device === null ? 'audioInputUnselected' : 'audioInputSelected');\n    }\n    pushVideoMeetingStateForPermissions(device) {\n        var _a, _b;\n        (_b = (_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.eventController) === null || _b === void 0 ? void 0 : _b.publishEvent(device === null ? 'videoInputUnselected' : 'videoInputSelected');\n    }\n    chooseAudioInputDevice(device) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (device === undefined) {\n                this.logger.error('Audio input device cannot be undefined');\n                return;\n            }\n            if (AudioTransformDevice_1.isAudioTransformDevice(device)) {\n                // N.B., do not JSON.stringify here — for some kinds of devices this\n                // will cause a cyclic object reference error.\n                this.logger.info(`Choosing transform input device ${device}`);\n                /*\n                 * This block of code is a workaround for a Chromium bug:\n                 * https://bugs.chromium.org/p/chromium/issues/detail?id=1173656\n                 *\n                 * In short: if we are about to select an audio device with a transform, which we assume for\n                 * safety's sake uses AudioWorklet, we recreate the audio context and the nodes that\n                 * are linked to it.\n                 *\n                 * This causes Chrome to rejig its buffers and the second context works correctly.\n                 *\n                 * This is theoretically worse for performance, but in practice it is fine.\n                 *\n                 * This is not safe in the general case: an application that already\n                 * retrieved the audio context in order to build an audio graph for some other purpose\n                 * will fail at this point as we pull the context out from under it.\n                 *\n                 * An application that always uses the supplied context in an\n                 * `AudioTransformDevice.createAudioNode` call should work correctly.\n                 *\n                 * If you are confident that your application does not use AudioWorklet, does not run in\n                 * an un-fixed Chromium version, or will never be used with sample-rate-switching Bluetooth\n                 * devices, you can disable this workaround by suppling a custom {@link ExtendedBrowserBehavior}\n                 * when you create your device controller.\n                 *\n                 * We can't tell in advance whether we need to give the device a different audio context,\n                 * because checking whether the resulting node is an AudioWorkletNode needs it to have been\n                 * created first.\n                 */\n                const recreateAudioContext = this.browserBehavior.requiresContextRecreationForAudioWorklet();\n                if (recreateAudioContext) {\n                    this.logger.info('Recreating audio context when selecting transform device.');\n                    if (this.transform) {\n                        /* istanbul ignore else */\n                        if (this.transform.nodes) {\n                            this.transform.nodes.end.disconnect();\n                            this.transform.nodes = undefined;\n                        }\n                        this.transform = undefined;\n                    }\n                    /* istanbul ignore else */\n                    if (this.audioInputSourceNode) {\n                        this.audioInputSourceNode.disconnect();\n                        this.audioInputSourceNode = undefined;\n                    }\n                    /* istanbul ignore else */\n                    if (this.audioInputDestinationNode) {\n                        this.audioInputDestinationNode.disconnect();\n                        this.audioInputDestinationNode = undefined;\n                    }\n                    DefaultDeviceController.closeAudioContext();\n                }\n                yield this.chooseAudioTransformInputDevice(device);\n                if (recreateAudioContext && ((_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.rtcPeerConnection)) {\n                    this.boundAudioVideoController.restartLocalAudio(() => {\n                        this.logger.info('Local audio restarted.');\n                    });\n                }\n                return this.pushAudioMeetingStateForPermissions(device);\n            }\n            this.removeTransform();\n            yield this.chooseInputIntrinsicDevice('audio', device, false);\n            this.trace('chooseAudioInputDevice', device, `success`);\n            this.pushAudioMeetingStateForPermissions(device);\n        });\n    }\n    chooseAudioTransformInputDevice(device) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (((_a = this.transform) === null || _a === void 0 ? void 0 : _a.device) === device) {\n                return;\n            }\n            if (!this.useWebAudio) {\n                throw new Error('Cannot apply transform device without enabling Web Audio.');\n            }\n            const context = DefaultDeviceController.getAudioContext();\n            if (context instanceof OfflineAudioContext) {\n                // Nothing to do.\n            }\n            else {\n                switch (context.state) {\n                    case 'running':\n                        // Nothing to do.\n                        break;\n                    case 'closed':\n                        // A closed context cannot be used for creating nodes, so the correct\n                        // thing to do is to raise a descriptive error sooner.\n                        throw new Error('Cannot choose a transform device with a closed audio context.');\n                    case 'suspended':\n                        // A context might be suspended after page load. We try to resume it\n                        // here, otherwise audio won't work.\n                        yield context.resume();\n                }\n            }\n            let nodes;\n            try {\n                nodes = yield device.createAudioNode(context);\n            }\n            catch (e) {\n                this.logger.error(`Unable to create transform device node: ${e}.`);\n                throw e;\n            }\n            // Pick the plain ol' inner device as the source. It will be\n            // connected to the node.\n            const inner = yield device.intrinsicDevice();\n            yield this.chooseInputIntrinsicDevice('audio', inner, false);\n            this.logger.debug(`Got inner stream: ${inner}.`);\n            // Otherwise, continue: hook up the new node.\n            this.setTransform(device, nodes);\n        });\n    }\n    chooseVideoTransformInputDevice(device) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (device === this.chosenVideoTransformDevice) {\n                this.logger.info('Reselecting same VideoTransformDevice');\n                return;\n            }\n            const prevVideoTransformDevice = this.chosenVideoTransformDevice;\n            if (prevVideoTransformDevice) {\n                this.logger.info('Switched from previous VideoTransformDevice');\n            }\n            const wasUsingTransformDevice = !!prevVideoTransformDevice;\n            const inner = yield device.intrinsicDevice();\n            const canReuseMediaStream = this.isMediaStreamReusableByDeviceId((_a = this.activeDevices['video']) === null || _a === void 0 ? void 0 : _a.stream, inner);\n            if (!canReuseMediaStream) {\n                this.logger.info('video transform device needs new intrinsic device');\n                if (wasUsingTransformDevice) {\n                    // detach input media stream - turn off the camera or leave it be if inner is media stream\n                    prevVideoTransformDevice.onOutputStreamDisconnect();\n                }\n                this.chosenVideoTransformDevice = device;\n                // VideoTransformDevice owns input MediaStream\n                this.activeDevices['video'] = null;\n                yield this.chooseInputIntrinsicDevice('video', inner, false, true);\n                return;\n            }\n            // When saved stream is reusable, only switch the saved stream to filtered stream for sending\n            // but keep the saved stream intact.\n            // Note: to keep the chosen media stream intact, it is important to avoid a full stop\n            // because videoTileUpdate can be called when video is stopped and user might call `bindVideoElement` to disconnect the element.\n            // In current implementation, disconnecting the element will `hard` stop the media stream.\n            // Update device and stream\n            this.chosenVideoTransformDevice = device;\n            const newMediaStream = this.activeDevices['video'].stream;\n            this.logger.info('video transform device uses previous stream');\n            // Input is not a MediaStream. Update constraints\n            if (!inner.id) {\n                const constraint = inner;\n                constraint.width = constraint.width || this.videoInputQualitySettings.videoWidth;\n                constraint.height = constraint.height || this.videoInputQualitySettings.videoHeight;\n                constraint.frameRate = constraint.frameRate || this.videoInputQualitySettings.videoFrameRate;\n                yield newMediaStream.getVideoTracks()[0].applyConstraints(constraint);\n            }\n            // `transformStream` will start processing.\n            yield device.transformStream(this.activeDevices['video'].stream);\n            // Replace video to send\n            if ((_b = this.boundAudioVideoController) === null || _b === void 0 ? void 0 : _b.videoTileController.hasStartedLocalVideoTile()) {\n                // optimized method exists, a negotiation can be avoided\n                if (this.boundAudioVideoController.replaceLocalVideo) {\n                    this.restartLocalVideoAfterSelection(null, false, true);\n                }\n                else {\n                    // non-optimized path, a negotiation is coming\n                    yield this.boundAudioVideoController.update();\n                }\n            }\n        });\n    }\n    chooseVideoInputDevice(device) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (device === undefined) {\n                this.logger.error('Video input device cannot be undefined');\n                return;\n            }\n            if (VideoTransformDevice_1.isVideoTransformDevice(device)) {\n                this.logger.info(`Choosing video transform device ${device}`);\n                return this.chooseVideoTransformInputDevice(device);\n            }\n            this.updateMaxBandwidthKbps();\n            // handle direct switching from VideoTransformDevice to Device\n            // From WebRTC point, it is a device switching.\n            if (this.chosenVideoInputIsTransformDevice()) {\n                // disconnect old stream\n                this.chosenVideoTransformDevice.onOutputStreamDisconnect();\n                this.chosenVideoTransformDevice = null;\n            }\n            yield this.chooseInputIntrinsicDevice('video', device, false);\n            this.trace('chooseVideoInputDevice', device);\n            this.pushVideoMeetingStateForPermissions(device);\n        });\n    }\n    chooseAudioOutputDevice(deviceId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.audioOutputDeviceId = deviceId;\n            this.watchForDeviceChangesIfNecessary();\n            yield this.bindAudioOutput();\n            this.trace('chooseAudioOutputDevice', deviceId, null);\n            return;\n        });\n    }\n    addDeviceChangeObserver(observer) {\n        this.logger.info('adding device change observer');\n        this.deviceChangeObservers.add(observer);\n        this.watchForDeviceChangesIfNecessary();\n        this.trace('addDeviceChangeObserver');\n    }\n    removeDeviceChangeObserver(observer) {\n        this.logger.info('removing device change observer');\n        this.deviceChangeObservers.delete(observer);\n        this.watchForDeviceChangesIfNecessary();\n        this.trace('removeDeviceChangeObserver');\n    }\n    createAnalyserNodeForAudioInput() {\n        var _a, _b;\n        if (!this.activeDevices['audio']) {\n            return null;\n        }\n        // If there is a WebAudio node in the graph, we use that as the source instead of the stream.\n        const node = (_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.end;\n        if (node) {\n            const analyser = node.context.createAnalyser();\n            analyser.removeOriginalInputs = () => {\n                try {\n                    node.disconnect(analyser);\n                }\n                catch (e) {\n                    // This can fail in some unusual cases, but this is best-effort.\n                }\n            };\n            node.connect(analyser);\n            return analyser;\n        }\n        return this.createAnalyserNodeForRawAudioInput();\n    }\n    //\n    // N.B., this bypasses any applied transform node.\n    //\n    createAnalyserNodeForRawAudioInput() {\n        if (!this.activeDevices['audio']) {\n            return null;\n        }\n        return this.createAnalyserNodeForStream(this.activeDevices['audio'].stream);\n    }\n    createAnalyserNodeForStream(stream) {\n        const audioContext = DefaultDeviceController.getAudioContext();\n        const analyser = audioContext.createAnalyser();\n        const source = audioContext.createMediaStreamSource(stream);\n        source.connect(analyser);\n        this.trace('createAnalyserNodeForAudioInput');\n        analyser.removeOriginalInputs = () => {\n            try {\n                source.disconnect(analyser);\n            }\n            catch (e) {\n                // This can fail in some unusual cases, but this is best-effort.\n            }\n        };\n        return analyser;\n    }\n    startVideoPreviewForVideoInput(element) {\n        if (!this.activeDevices['video']) {\n            this.logger.warn('cannot bind video preview since video input device has not been chosen');\n            this.trace('startVideoPreviewForVideoInput', element.id);\n            return;\n        }\n        // TODO: implement MediaDestroyer to provide single release MediaStream function\n        this.releaseMediaStream(element.srcObject);\n        DefaultVideoTile_1.default.disconnectVideoStreamFromVideoElement(element, false);\n        navigator.mediaDevices\n            .getUserMedia(this.activeDevices['video'].constraints)\n            .then(previewStream => {\n            DefaultVideoTile_1.default.connectVideoStreamToVideoElement(previewStream, element, true);\n        })\n            .catch(error => {\n            this.logger.warn(`Unable to reacquire video stream for preview to element ${element.id}: ${error}`);\n        });\n        this.trace('startVideoPreviewForVideoInput', element.id);\n    }\n    stopVideoPreviewForVideoInput(element) {\n        const stream = element.srcObject;\n        const activeVideoDevice = this.activeDevices['video'];\n        // Safety.\n        /* istanbul ignore else */\n        if (activeVideoDevice) {\n            this.releaseActiveDevice(activeVideoDevice);\n        }\n        if (stream) {\n            this.releaseMediaStream(stream);\n            DefaultVideoTile_1.default.disconnectVideoStreamFromVideoElement(element, false);\n        }\n        this.trace('stopVideoPreviewForVideoInput', element.id);\n    }\n    setDeviceLabelTrigger(trigger) {\n        this.deviceLabelTrigger = trigger;\n        this.trace('setDeviceLabelTrigger');\n    }\n    mixIntoAudioInput(stream) {\n        let node = null;\n        if (this.useWebAudio) {\n            node = DefaultDeviceController.getAudioContext().createMediaStreamSource(stream);\n            node.connect(this.getMediaStreamOutputNode());\n        }\n        else {\n            this.logger.warn('WebAudio is not enabled, mixIntoAudioInput will not work');\n        }\n        this.trace('mixIntoAudioInput', stream.id);\n        return node;\n    }\n    chooseVideoInputQuality(width, height, frameRate, maxBandwidthKbps) {\n        const dimension = this.browserBehavior.requiresResolutionAlignment(width, height);\n        this.videoInputQualitySettings = new VideoQualitySettings_1.default(dimension[0], dimension[1], frameRate, maxBandwidthKbps);\n        this.updateMaxBandwidthKbps();\n    }\n    getVideoInputQualitySettings() {\n        return this.videoInputQualitySettings;\n    }\n    acquireAudioInputStream() {\n        return this.acquireInputStream('audio');\n    }\n    acquireVideoInputStream() {\n        return this.acquireInputStream('video');\n    }\n    acquireDisplayInputStream(streamConstraints) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (streamConstraints &&\n                streamConstraints.video &&\n                // @ts-ignore\n                streamConstraints.video.mandatory &&\n                // @ts-ignore\n                streamConstraints.video.mandatory.chromeMediaSource &&\n                // @ts-ignore\n                streamConstraints.video.mandatory.chromeMediaSourceId) {\n                return navigator.mediaDevices.getUserMedia(streamConstraints);\n            }\n            // @ts-ignore https://github.com/microsoft/TypeScript/issues/31821\n            return navigator.mediaDevices.getDisplayMedia(streamConstraints);\n        });\n    }\n    /**\n     * This function helps `releaseMediaStream` do the right thing.\n     *\n     * We need to do three things:\n     *\n     * * Close the tracks of the source stream.\n     * * Remove the transform.\n     * * Clean up the _source_ stream's callback, as if `releaseMediaStream` had\n     *   been called with that stream -- that's the stream that's tracked in\n     *   `activeDevices` and needs to have its callbacks removed.\n     *\n     * This is a little fiddly because the stream broker interface doesn't\n     * know about the innards of the device controller, and only has the\n     * meeting session state's stream to work with.\n     *\n     */\n    releaseAudioTransformStream() {\n        this.logger.info('Stopping audio track for Web Audio graph');\n        this.stopTracksAndRemoveCallback('audio');\n        this.logger.info('Removing audio transform, if there is one.');\n        this.removeTransform();\n        // Remove the input and output nodes. They will be recreated later if\n        // needed.\n        this.audioInputSourceNode.disconnect();\n        this.audioInputSourceNode = undefined;\n        this.audioInputDestinationNode.disconnect();\n        this.audioInputDestinationNode = undefined;\n    }\n    releaseVideoTransformStream() {\n        this.logger.info('Stopping video track for transform');\n        this.stopTracksAndRemoveCallback('video');\n        this.logger.info('Disconnecting video transform');\n        this.chosenVideoTransformDevice.onOutputStreamDisconnect();\n        this.chosenVideoTransformDevice = null;\n    }\n    stopTracksAndRemoveCallback(kind) {\n        const activeDevice = this.activeDevices[kind];\n        /* istanbul ignore next */\n        const endedCallback = activeDevice === null || activeDevice === void 0 ? void 0 : activeDevice.endedCallback;\n        for (const track of activeDevice.stream.getTracks()) {\n            track.stop();\n            /* istanbul ignore else */\n            if (endedCallback) {\n                track.removeEventListener('ended', endedCallback);\n                delete activeDevice.endedCallback;\n            }\n            delete this.activeDevices[kind];\n        }\n    }\n    releaseOrdinaryStream(mediaStreamToRelease) {\n        var _a;\n        const tracksToStop = mediaStreamToRelease.getTracks();\n        if (!tracksToStop.length) {\n            return;\n        }\n        for (const track of tracksToStop) {\n            track.stop();\n        }\n        // This function is called from `CleanStoppedSessionTask` using the\n        // session state, which does not allow us to clean up any associated 'ended'\n        // callbacks in advance. Look here to see if we have any to clean up.\n        for (const kind in this.activeDevices) {\n            const activeDevice = this.activeDevices[kind];\n            if ((activeDevice === null || activeDevice === void 0 ? void 0 : activeDevice.stream) !== mediaStreamToRelease) {\n                continue;\n            }\n            if (activeDevice.endedCallback) {\n                tracksToStop[0].removeEventListener('ended', activeDevice.endedCallback);\n                delete activeDevice.endedCallback;\n            }\n            delete this.activeDevices[kind];\n            if (kind === 'video' &&\n                ((_a = this.boundAudioVideoController) === null || _a === void 0 ? void 0 : _a.videoTileController.hasStartedLocalVideoTile())) {\n                this.boundAudioVideoController.videoTileController.stopLocalVideoTile();\n            }\n        }\n    }\n    releaseMediaStream(mediaStreamToRelease) {\n        var _a, _b;\n        if (!mediaStreamToRelease) {\n            return;\n        }\n        try {\n            // This method can be called with the output of an audio transform's\n            // Web Audio graph. That graph runs from a `MediaStreamSourceNode`, through\n            // the transform (if present), to a `MediaStreamDestinationNode`, and out to\n            // WebRTC.\n            //\n            // The call teardown task will call `releaseMediaStream` with the stream it\n            // receives — the destination stream.\n            //\n            // This function detects with this comparison:\n            const isReleasingAudioDestinationStream = mediaStreamToRelease === ((_a = this.audioInputDestinationNode) === null || _a === void 0 ? void 0 : _a.stream);\n            if (isReleasingAudioDestinationStream) {\n                this.releaseAudioTransformStream();\n                return;\n            }\n            // Similarly, it can be called with a video transform's output stream.\n            // As with the Web Audio case, we need to release the actual input stream to\n            // really stop it.\n            const isReleasingVideoOutputStream = mediaStreamToRelease === ((_b = this.chosenVideoTransformDevice) === null || _b === void 0 ? void 0 : _b.outputMediaStream);\n            if (isReleasingVideoOutputStream) {\n                this.releaseVideoTransformStream();\n                return;\n            }\n            // Otherwise, this is one of our inputs that was plumbed straight through to\n            // WebRTC. Go ahead and release it track by track.\n            this.releaseOrdinaryStream(mediaStreamToRelease);\n        }\n        finally {\n            this.watchForDeviceChangesIfNecessary();\n        }\n    }\n    chosenVideoInputIsTransformDevice() {\n        return !!this.chosenVideoTransformDevice;\n    }\n    bindToAudioVideoController(audioVideoController) {\n        if (this.boundAudioVideoController) {\n            this.unsubscribeFromMuteAndUnmuteLocalAudio();\n        }\n        this.boundAudioVideoController = audioVideoController;\n        this.subscribeToMuteAndUnmuteLocalAudio();\n        if (this.browserBehavior.supportsSetSinkId()) {\n            AsyncScheduler_1.default.nextTick(() => {\n                this.bindAudioOutput();\n            });\n        }\n    }\n    subscribeToMuteAndUnmuteLocalAudio() {\n        if (!this.boundAudioVideoController) {\n            return;\n        }\n        // Safety that's hard to test.\n        /* istanbul ignore next */\n        if (!this.boundAudioVideoController.realtimeController) {\n            return;\n        }\n        this.boundAudioVideoController.realtimeController.realtimeSubscribeToMuteAndUnmuteLocalAudio(this.muteCallback);\n    }\n    unsubscribeFromMuteAndUnmuteLocalAudio() {\n        // Safety that's hard to test.\n        /* istanbul ignore next */\n        if (!this.boundAudioVideoController.realtimeController) {\n            return;\n        }\n        this.boundAudioVideoController.realtimeController.realtimeUnsubscribeToMuteAndUnmuteLocalAudio(this.muteCallback);\n    }\n    static getIntrinsicDeviceId(device) {\n        if (device === undefined) {\n            return undefined;\n        }\n        if (device === null) {\n            return null;\n        }\n        if (typeof device === 'string') {\n            return device;\n        }\n        if (device.id) {\n            return device.id;\n        }\n        const constraints = device;\n        const deviceIdConstraints = constraints.deviceId;\n        if (deviceIdConstraints === undefined) {\n            return undefined;\n        }\n        if (deviceIdConstraints === null) {\n            return null;\n        }\n        if (typeof deviceIdConstraints === 'string' || Array.isArray(deviceIdConstraints)) {\n            return deviceIdConstraints;\n        }\n        const constraintStringParams = deviceIdConstraints;\n        if (typeof constraintStringParams.exact === 'string' ||\n            Array.isArray(constraintStringParams.exact)) {\n            return constraintStringParams.exact;\n        }\n        return undefined;\n    }\n    static createEmptyAudioDevice() {\n        return DefaultDeviceController.synthesizeAudioDevice(0);\n    }\n    static createEmptyVideoDevice() {\n        return DefaultDeviceController.synthesizeVideoDevice('black');\n    }\n    static synthesizeAudioDevice(toneHz) {\n        const audioContext = DefaultDeviceController.getAudioContext();\n        const outputNode = audioContext.createMediaStreamDestination();\n        if (!toneHz) {\n            const source = audioContext.createBufferSource();\n            // The AudioContext object uses the sample rate of the default output device\n            // if not specified. Creating an AudioBuffer object with the output device's\n            // sample rate fails in some browsers, e.g. Safari with a Bluetooth headphone.\n            try {\n                source.buffer = audioContext.createBuffer(1, audioContext.sampleRate * 5, audioContext.sampleRate);\n            }\n            catch (error) {\n                if (error && error.name === 'NotSupportedError') {\n                    source.buffer = audioContext.createBuffer(1, DefaultDeviceController.defaultSampleRate * 5, DefaultDeviceController.defaultSampleRate);\n                }\n                else {\n                    throw error;\n                }\n            }\n            // Some browsers will not play audio out the MediaStreamDestination\n            // unless there is actually audio to play, so we add a small amount of\n            // noise here to ensure that audio is played out.\n            source.buffer.getChannelData(0)[0] = 0.0003;\n            source.loop = true;\n            source.connect(outputNode);\n            source.start();\n        }\n        else {\n            const gainNode = audioContext.createGain();\n            gainNode.gain.value = 0.1;\n            gainNode.connect(outputNode);\n            const oscillatorNode = audioContext.createOscillator();\n            oscillatorNode.frequency.value = toneHz;\n            oscillatorNode.connect(gainNode);\n            oscillatorNode.start();\n        }\n        return outputNode.stream;\n    }\n    static synthesizeVideoDevice(colorOrPattern) {\n        const canvas = document.createElement('canvas');\n        canvas.width = 480;\n        canvas.height = (canvas.width / 16) * 9;\n        const colorBars = makeColorBars(canvas, colorOrPattern);\n        if (!colorBars) {\n            return null;\n        }\n        // `scheduler` and `listener` will leak.\n        const { stream } = colorBars;\n        return stream;\n    }\n    updateMaxBandwidthKbps() {\n        if (this.boundAudioVideoController) {\n            this.boundAudioVideoController.setVideoMaxBandwidthKbps(this.videoInputQualitySettings.videoMaxBandwidthKbps);\n        }\n    }\n    listDevicesOfKind(deviceKind) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.deviceInfoCache === null || !this.isWatchingForDeviceChanges()) {\n                yield this.updateDeviceInfoCacheFromBrowser();\n            }\n            return this.listCachedDevicesOfKind(deviceKind);\n        });\n    }\n    updateDeviceInfoCacheFromBrowser() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doesNotHaveAccessToMediaDevices = typeof MediaDeviceInfo === 'undefined';\n            if (doesNotHaveAccessToMediaDevices) {\n                this.deviceInfoCache = [];\n                return;\n            }\n            let devices = yield navigator.mediaDevices.enumerateDevices();\n            let hasDeviceLabels = true;\n            for (const device of devices) {\n                if (!device.label) {\n                    hasDeviceLabels = false;\n                    break;\n                }\n            }\n            if (!hasDeviceLabels) {\n                try {\n                    this.logger.info('attempting to trigger media device labels since they are hidden');\n                    const triggerStream = yield this.deviceLabelTrigger();\n                    devices = yield navigator.mediaDevices.enumerateDevices();\n                    for (const track of triggerStream.getTracks()) {\n                        track.stop();\n                    }\n                }\n                catch (err) {\n                    this.logger.info('unable to get media device labels');\n                }\n            }\n            this.deviceInfoCache = devices;\n        });\n    }\n    listCachedDevicesOfKind(deviceKind) {\n        const devicesOfKind = [];\n        for (const device of this.deviceInfoCache) {\n            if (device.kind === deviceKind) {\n                devicesOfKind.push(device);\n            }\n        }\n        return devicesOfKind;\n    }\n    handleDeviceChange() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.deviceInfoCache === null) {\n                return;\n            }\n            if (this.alreadyHandlingDeviceChange) {\n                AsyncScheduler_1.default.nextTick(() => {\n                    this.handleDeviceChange();\n                });\n                return;\n            }\n            this.alreadyHandlingDeviceChange = true;\n            const oldAudioInputDevices = this.listCachedDevicesOfKind('audioinput');\n            const oldVideoInputDevices = this.listCachedDevicesOfKind('videoinput');\n            const oldAudioOutputDevices = this.listCachedDevicesOfKind('audiooutput');\n            yield this.updateDeviceInfoCacheFromBrowser();\n            const newAudioInputDevices = this.listCachedDevicesOfKind('audioinput');\n            const newVideoInputDevices = this.listCachedDevicesOfKind('videoinput');\n            const newAudioOutputDevices = this.listCachedDevicesOfKind('audiooutput');\n            this.forEachObserver((observer) => {\n                if (!this.areDeviceListsEqual(oldAudioInputDevices, newAudioInputDevices)) {\n                    Maybe_1.default.of(observer.audioInputsChanged).map(f => f.bind(observer)(newAudioInputDevices));\n                }\n                if (!this.areDeviceListsEqual(oldVideoInputDevices, newVideoInputDevices)) {\n                    Maybe_1.default.of(observer.videoInputsChanged).map(f => f.bind(observer)(newVideoInputDevices));\n                }\n                if (!this.areDeviceListsEqual(oldAudioOutputDevices, newAudioOutputDevices)) {\n                    Maybe_1.default.of(observer.audioOutputsChanged).map(f => f.bind(observer)(newAudioOutputDevices));\n                }\n            });\n            this.alreadyHandlingDeviceChange = false;\n        });\n    }\n    handleDeviceStreamEnded(kind, deviceId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.chooseInputIntrinsicDevice(kind, null, false);\n            }\n            catch (e) {\n                /* istanbul ignore next */\n                this.logger.error('Failed to choose null device after stream ended.');\n            }\n            if (kind === 'audio') {\n                this.forEachObserver((observer) => {\n                    Maybe_1.default.of(observer.audioInputStreamEnded).map(f => f.bind(observer)(deviceId));\n                });\n            }\n            else {\n                this.forEachObserver((observer) => {\n                    Maybe_1.default.of(observer.videoInputStreamEnded).map(f => f.bind(observer)(deviceId));\n                });\n            }\n        });\n    }\n    forEachObserver(observerFunc) {\n        for (const observer of this.deviceChangeObservers) {\n            AsyncScheduler_1.default.nextTick(() => {\n                /* istanbul ignore else */\n                if (this.deviceChangeObservers.has(observer)) {\n                    observerFunc(observer);\n                }\n            });\n        }\n    }\n    areDeviceListsEqual(a, b) {\n        return (JSON.stringify(a.map(device => JSON.stringify(device)).sort()) ===\n            JSON.stringify(b.map(device => JSON.stringify(device)).sort()));\n    }\n    intrinsicDeviceAsMediaStream(device) {\n        // @ts-ignore\n        return device && device.id ? device : null;\n    }\n    hasSameGroupId(groupId, kind, device) {\n        if (groupId === '') {\n            return true;\n        }\n        const deviceIds = DefaultDeviceController.getIntrinsicDeviceId(device);\n        if (typeof deviceIds === 'string' && groupId === this.getGroupIdFromDeviceId(kind, deviceIds)) {\n            return true;\n        }\n        return false;\n    }\n    getGroupIdFromDeviceId(kind, deviceId) {\n        if (this.deviceInfoCache !== null) {\n            const cachedDeviceInfo = this.listCachedDevicesOfKind(`${kind}input`).find((cachedDevice) => cachedDevice.deviceId === deviceId);\n            if (cachedDeviceInfo && cachedDeviceInfo.groupId) {\n                return cachedDeviceInfo.groupId;\n            }\n        }\n        return '';\n    }\n    getActiveDeviceId(kind) {\n        /* istanbul ignore else */\n        if (this.activeDevices[kind] && this.activeDevices[kind].constraints) {\n            const activeDeviceMediaTrackConstraints = this.activeDevices[kind].constraints.audio || this.activeDevices[kind].constraints.video;\n            const activeDeviceConstrainDOMStringParameters = activeDeviceMediaTrackConstraints\n                .deviceId;\n            let activeDeviceId;\n            if (typeof activeDeviceConstrainDOMStringParameters === 'string') {\n                activeDeviceId = activeDeviceConstrainDOMStringParameters;\n            }\n            else {\n                activeDeviceId = activeDeviceConstrainDOMStringParameters\n                    .exact;\n            }\n            return activeDeviceId;\n        }\n        /* istanbul ignore next */\n        return null;\n    }\n    restartLocalVideoAfterSelection(oldDevice, fromAcquire, fromVideoTransformDevice) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!fromAcquire &&\n                this.boundAudioVideoController &&\n                this.boundAudioVideoController.videoTileController.hasStartedLocalVideoTile()) {\n                if (fromVideoTransformDevice) {\n                    // similar to `useWebaudio`, either Device or VideoTransformDevice, `this.activeDevices['video']` tracks the supplied inner Device.\n                    // Upon in-meeting switching to VideoTransformDevice, device controller releases old \"supplied\" stream and\n                    // calls replaceLocalVideo to avoid a full stop-start update.\n                    yield this.boundAudioVideoController.replaceLocalVideo();\n                    this.logger.info('successfully replaced video track');\n                    if (oldDevice === null || oldDevice === void 0 ? void 0 : oldDevice.stream.active) {\n                        this.logger.warn('previous media stream is not stopped during restart video');\n                        this.releaseActiveDevice(oldDevice);\n                    }\n                }\n                else {\n                    // not from VideoTransformDevice, usual behavior.\n                    this.logger.info('restarting local video to switch to new device');\n                    this.boundAudioVideoController.restartLocalVideo(() => {\n                        // TODO: implement MediaStreamDestroyer\n                        // tracks of oldStream should be stopped when video tile is disconnected from MediaStream\n                        // otherwise, camera is still being accessed and we need to stop it here.\n                        if (oldDevice === null || oldDevice === void 0 ? void 0 : oldDevice.stream.active) {\n                            this.logger.warn('previous media stream is not stopped during restart video');\n                            this.releaseActiveDevice(oldDevice);\n                        }\n                    });\n                }\n            }\n            else {\n                this.releaseActiveDevice(oldDevice);\n            }\n        });\n    }\n    handleGetUserMediaError(error, errorTimeMs) {\n        if (!error) {\n            throw new GetUserMediaError_1.default(error);\n        }\n        switch (error.name) {\n            case 'NotReadableError':\n            case 'TrackStartError':\n                throw new NotReadableError_1.default(error);\n            case 'NotFoundError':\n            case 'DevicesNotFoundError':\n                throw new NotFoundError_1.default(error);\n            case 'NotAllowedError':\n            case 'PermissionDeniedError':\n            case 'SecurityError':\n                if (errorTimeMs &&\n                    errorTimeMs < DefaultDeviceController.permissionDeniedOriginDetectionThresholdMs) {\n                    throw new PermissionDeniedError_1.default(error, 'Permission denied by browser');\n                }\n                else {\n                    throw new PermissionDeniedError_1.default(error, 'Permission denied by user');\n                }\n            case 'OverconstrainedError':\n            case 'ConstraintNotSatisfiedError':\n                throw new OverconstrainedError_1.default(error);\n            case 'TypeError':\n                throw new TypeError_1.default(error);\n            case 'AbortError':\n            default:\n                throw new GetUserMediaError_1.default(error);\n        }\n    }\n    releaseActiveDevice(device) {\n        if (!device || !device.stream) {\n            return;\n        }\n        if (device.endedCallback) {\n            const track = device.stream.getTracks()[0];\n            // Safety.\n            /* istanbul ignore else */\n            if (track) {\n                track.removeEventListener('ended', device.endedCallback);\n            }\n        }\n        delete device.endedCallback;\n        this.releaseMediaStream(device.stream);\n        delete device.stream;\n    }\n    chooseInputIntrinsicDevice(kind, device, fromAcquire, fromVideoTransformDevice = false) {\n        var _a, _b, _c, _d, _e;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.inputDeviceCount += 1;\n            const callCount = this.inputDeviceCount;\n            if (device === null && kind === 'video') {\n                this.lastNoVideoInputDeviceCount = this.inputDeviceCount;\n                const active = this.activeDevices[kind];\n                if (active) {\n                    this.releaseActiveDevice(active);\n                    delete this.activeDevices[kind];\n                    this.watchForDeviceChangesIfNecessary();\n                }\n                return;\n            }\n            // N.B.,: the input device might already have augmented constraints supplied\n            // by an `AudioTransformDevice`. `calculateMediaStreamConstraints` will respect\n            // settings supplied by the device.\n            const proposedConstraints = this.calculateMediaStreamConstraints(kind, device);\n            // TODO: `matchesConstraints` should really return compatible/incompatible/exact --\n            // `applyConstraints` can be used to reuse the active device while changing the\n            // requested constraints.\n            if (this.activeDevices[kind] &&\n                this.activeDevices[kind].matchesConstraints(proposedConstraints) &&\n                this.activeDevices[kind].stream.active &&\n                this.activeDevices[kind].groupId !== null &&\n                this.hasSameGroupId(this.activeDevices[kind].groupId, kind, device)) {\n                this.logger.info(`reusing existing ${kind} device`);\n                return;\n            }\n            if (kind === 'audio' && this.activeDevices[kind] && this.activeDevices[kind].stream) {\n                this.releaseActiveDevice(this.activeDevices[kind]);\n            }\n            const startTimeMs = Date.now();\n            const newDevice = new DeviceSelection_1.default();\n            try {\n                this.logger.info(`requesting new ${kind} device with constraint ${JSON.stringify(proposedConstraints)}`);\n                const stream = this.intrinsicDeviceAsMediaStream(device);\n                if (kind === 'audio' && device === null) {\n                    newDevice.stream = DefaultDeviceController.createEmptyAudioDevice();\n                    newDevice.constraints = null;\n                }\n                else if (stream) {\n                    this.logger.info(`using media stream ${stream.id} for ${kind} device`);\n                    newDevice.stream = stream;\n                    newDevice.constraints = proposedConstraints;\n                }\n                else {\n                    newDevice.stream = yield navigator.mediaDevices.getUserMedia(proposedConstraints);\n                    newDevice.constraints = proposedConstraints;\n                    if (kind === 'video' && this.lastNoVideoInputDeviceCount > callCount) {\n                        this.logger.warn(`ignored to get video device for constraints ${JSON.stringify(proposedConstraints)} as no device was requested`);\n                        this.releaseMediaStream(newDevice.stream);\n                        return;\n                    }\n                    yield this.handleDeviceChange();\n                    const track = newDevice.stream.getTracks()[0];\n                    newDevice.endedCallback = () => {\n                        // Hard to test, but the safety check is worthwhile.\n                        /* istanbul ignore else */\n                        if (this.activeDevices[kind] && this.activeDevices[kind].stream === newDevice.stream) {\n                            this.logger.warn(`${kind} input device which was active is no longer available, resetting to null device`);\n                            this.handleDeviceStreamEnded(kind, this.getActiveDeviceId(kind));\n                            delete newDevice.endedCallback;\n                        }\n                    };\n                    track.addEventListener('ended', newDevice.endedCallback, { once: true });\n                }\n                newDevice.groupId = ((_a = this.getMediaTrackSettings(newDevice.stream)) === null || _a === void 0 ? void 0 : _a.groupId) || '';\n            }\n            catch (error) {\n                let errorMessage;\n                if ((error === null || error === void 0 ? void 0 : error.name) && error.message) {\n                    errorMessage = `${error.name}: ${error.message}`;\n                }\n                else if (error === null || error === void 0 ? void 0 : error.name) {\n                    errorMessage = error.name;\n                }\n                else if (error === null || error === void 0 ? void 0 : error.message) {\n                    errorMessage = error.message;\n                }\n                else {\n                    errorMessage = 'UnknownError';\n                }\n                if (kind === 'audio') {\n                    (_c = (_b = this.boundAudioVideoController) === null || _b === void 0 ? void 0 : _b.eventController) === null || _c === void 0 ? void 0 : _c.publishEvent('audioInputFailed', {\n                        audioInputErrorMessage: errorMessage,\n                    });\n                }\n                else {\n                    (_e = (_d = this.boundAudioVideoController) === null || _d === void 0 ? void 0 : _d.eventController) === null || _e === void 0 ? void 0 : _e.publishEvent('videoInputFailed', {\n                        videoInputErrorMessage: errorMessage,\n                    });\n                }\n                this.logger.error(`failed to get ${kind} device for constraints ${JSON.stringify(proposedConstraints)}: ${errorMessage}`);\n                // This is effectively `error instanceof OverconstrainedError` but works in Node.\n                if (error && 'constraint' in error) {\n                    this.logger.error(`Over-constrained by constraint: ${error.constraint}`);\n                }\n                /*\n                 * If there is any error while acquiring the audio device, we fall back to null device.\n                 * Reason: If device selection fails (e.g. NotReadableError), the peer connection is left hanging\n                 * with no active audio track since we release the previously attached track.\n                 * If no audio packet has yet been sent to the server, the server will not emit the joined event.\n                 */\n                if (kind === 'audio') {\n                    this.logger.info(`choosing null ${kind} device instead`);\n                    try {\n                        newDevice.stream = DefaultDeviceController.createEmptyAudioDevice();\n                        newDevice.constraints = null;\n                        yield this.handleNewInputDevice(kind, newDevice, fromAcquire);\n                    }\n                    catch (error) {\n                        this.logger.error(`failed to choose null ${kind} device. ${error.name}: ${error.message}`);\n                    }\n                }\n                this.handleGetUserMediaError(error, Date.now() - startTimeMs);\n            }\n            finally {\n                this.watchForDeviceChangesIfNecessary();\n            }\n            this.logger.info(`got ${kind} device for constraints ${JSON.stringify(proposedConstraints)}`);\n            yield this.handleNewInputDevice(kind, newDevice, fromAcquire, fromVideoTransformDevice);\n            return;\n        });\n    }\n    handleNewInputDevice(kind, newDevice, fromAcquire, fromVideoTransformDevice = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const oldDevice = this.activeDevices[kind];\n            this.activeDevices[kind] = newDevice;\n            this.watchForDeviceChangesIfNecessary();\n            if (kind === 'video') {\n                // attempts to mirror `this.useWebAudio`. The difference is that audio destination stream stays the same\n                // but video sending needs to switch streams.\n                if (this.chosenVideoInputIsTransformDevice()) {\n                    this.logger.info('apply processors to transform');\n                    yield this.chosenVideoTransformDevice.transformStream(this.activeDevices['video'].stream);\n                }\n                yield this.restartLocalVideoAfterSelection(oldDevice, fromAcquire, fromVideoTransformDevice);\n            }\n            else {\n                this.releaseActiveDevice(oldDevice);\n                if (this.useWebAudio) {\n                    this.attachAudioInputStreamToAudioContext(this.activeDevices[kind].stream);\n                }\n                else if (this.boundAudioVideoController) {\n                    try {\n                        yield this.boundAudioVideoController.restartLocalAudio(() => { });\n                    }\n                    catch (error) {\n                        this.logger.info(`cannot replace audio track due to: ${error.message}`);\n                    }\n                }\n                else {\n                    this.logger.info('no audio-video controller is bound to the device controller');\n                }\n            }\n        });\n    }\n    bindAudioOutput() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.boundAudioVideoController) {\n                return;\n            }\n            const deviceInfo = this.deviceInfoFromDeviceId('audiooutput', this.audioOutputDeviceId);\n            yield this.boundAudioVideoController.audioMixController.bindAudioDevice(deviceInfo);\n        });\n    }\n    calculateMediaStreamConstraints(kind, device) {\n        let trackConstraints = {};\n        if (device === '') {\n            device = null;\n        }\n        const stream = this.intrinsicDeviceAsMediaStream(device);\n        if (device === null) {\n            return null;\n        }\n        else if (typeof device === 'string') {\n            if (this.browserBehavior.requiresNoExactMediaStreamConstraints() &&\n                this.browserBehavior.requiresGroupIdMediaStreamConstraints()) {\n                // In Samsung Internet browser, navigator.mediaDevices.enumerateDevices()\n                // returns same deviceId but different groupdId for some audioinput and videoinput devices.\n                // To handle this, we select appropriate device using deviceId + groupId.\n                trackConstraints.deviceId = device;\n                trackConstraints.groupId = this.getGroupIdFromDeviceId(kind, device);\n            }\n            else if (this.browserBehavior.requiresNoExactMediaStreamConstraints()) {\n                trackConstraints.deviceId = device;\n            }\n            else {\n                trackConstraints.deviceId = { exact: device };\n            }\n        }\n        else if (stream) {\n            // @ts-ignore - create a fake track constraint using the stream id\n            trackConstraints.streamId = stream.id;\n        }\n        else if (isMediaDeviceInfo(device)) {\n            trackConstraints.deviceId = device.deviceId;\n            trackConstraints.groupId = device.groupId;\n        }\n        else {\n            // Take the input set of constraints. Note that this allows\n            // the builder to specify overrides for properties like `autoGainControl`.\n            // @ts-ignore - device is a MediaTrackConstraints\n            trackConstraints = device;\n        }\n        if (kind === 'video') {\n            trackConstraints.width = trackConstraints.width || {\n                ideal: this.videoInputQualitySettings.videoWidth,\n            };\n            trackConstraints.height = trackConstraints.height || {\n                ideal: this.videoInputQualitySettings.videoHeight,\n            };\n            trackConstraints.frameRate = trackConstraints.frameRate || {\n                ideal: this.videoInputQualitySettings.videoFrameRate,\n            };\n            // TODO: try to replace hard-code value related to videos into quality-level presets\n            // The following configs relaxes CPU overuse detection threshold to offer better encoding quality\n            // @ts-ignore\n            trackConstraints.googCpuOveruseDetection = true;\n            // @ts-ignore\n            trackConstraints.googCpuOveruseEncodeUsage = true;\n            // @ts-ignore\n            trackConstraints.googCpuOveruseThreshold = 85;\n            // @ts-ignore\n            trackConstraints.googCpuUnderuseThreshold = 55;\n        }\n        if (kind === 'audio' && this.supportSampleRateConstraint()) {\n            trackConstraints.sampleRate = { ideal: DefaultDeviceController.defaultSampleRate };\n        }\n        if (kind === 'audio' && this.supportSampleSizeConstraint()) {\n            trackConstraints.sampleSize = { ideal: DefaultDeviceController.defaultSampleSize };\n        }\n        if (kind === 'audio' && this.supportChannelCountConstraint()) {\n            trackConstraints.channelCount = { ideal: DefaultDeviceController.defaultChannelCount };\n        }\n        if (kind === 'audio') {\n            const augmented = Object.assign({ echoCancellation: true, googEchoCancellation: true, googEchoCancellation2: true, googAutoGainControl: true, googAutoGainControl2: true, googNoiseSuppression: true, googNoiseSuppression2: true, googHighpassFilter: true }, trackConstraints);\n            trackConstraints = augmented;\n        }\n        return kind === 'audio' ? { audio: trackConstraints } : { video: trackConstraints };\n    }\n    deviceInfoFromDeviceId(deviceKind, deviceId) {\n        if (this.deviceInfoCache === null) {\n            return null;\n        }\n        for (const device of this.deviceInfoCache) {\n            if (device.kind === deviceKind && device.deviceId === deviceId) {\n                return device;\n            }\n        }\n        return null;\n    }\n    acquireInputStream(kind) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (kind === 'audio') {\n                if (this.useWebAudio) {\n                    const dest = this.getMediaStreamDestinationNode();\n                    return dest.stream;\n                }\n            }\n            // mirrors `this.useWebAudio`\n            if (kind === 'video') {\n                if (this.chosenVideoInputIsTransformDevice()) {\n                    return this.chosenVideoTransformDevice.outputMediaStream;\n                }\n            }\n            let existingConstraints = null;\n            if (!this.activeDevices[kind]) {\n                if (kind === 'audio') {\n                    this.logger.info(`no ${kind} device chosen, creating empty ${kind} device`);\n                }\n                else {\n                    this.logger.error(`no ${kind} device chosen, stopping local video tile`);\n                    this.boundAudioVideoController.videoTileController.stopLocalVideoTile();\n                    throw new Error(`no ${kind} device chosen, stopping local video tile`);\n                }\n            }\n            else {\n                this.logger.info(`checking whether existing ${kind} device can be reused`);\n                const active = this.activeDevices[kind];\n                // @ts-ignore\n                existingConstraints = active.constraints ? active.constraints[kind] : null;\n            }\n            try {\n                yield this.chooseInputIntrinsicDevice(kind, existingConstraints, true);\n            }\n            catch (e) {\n                this.logger.error(`unable to acquire ${kind} device`);\n                if (e instanceof PermissionDeniedError_1.default) {\n                    throw e;\n                }\n                throw new GetUserMediaError_1.default(e, `unable to acquire ${kind} device`);\n            }\n            return this.activeDevices[kind].stream;\n        });\n    }\n    hasAppliedTransform() {\n        return !!this.transform;\n    }\n    isMediaStreamReusableByDeviceId(stream, device) {\n        // for null device, assume the stream is not reusable\n        if (!stream || !stream.active || !device) {\n            return false;\n        }\n        if (device.id) {\n            return stream.id === device.id;\n        }\n        const settings = this.getMediaTrackSettings(stream);\n        // If a device does not specify deviceId, we have to assume the stream is not reusable.\n        if (!settings.deviceId) {\n            return false;\n        }\n        const deviceIds = DefaultDeviceController.getIntrinsicDeviceId(device);\n        if (typeof deviceIds === 'string') {\n            return settings.deviceId === deviceIds;\n        }\n        return false;\n    }\n    getMediaTrackSettings(stream) {\n        var _a;\n        return (_a = stream.getTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings();\n    }\n    reconnectAudioInputs() {\n        if (!this.audioInputSourceNode) {\n            return;\n        }\n        this.audioInputSourceNode.disconnect();\n        const output = this.getMediaStreamOutputNode();\n        this.audioInputSourceNode.connect(output);\n    }\n    setTransform(device, nodes) {\n        var _a, _b;\n        (_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.end.disconnect();\n        this.transform = { nodes, device };\n        const proc = nodes === null || nodes === void 0 ? void 0 : nodes.end;\n        const dest = this.getMediaStreamDestinationNode();\n        this.logger.debug(`Connecting transform node ${proc} to destination ${dest}.`);\n        proc === null || proc === void 0 ? void 0 : proc.connect(dest);\n        this.reconnectAudioInputs();\n    }\n    removeTransform() {\n        var _a;\n        const previous = this.transform;\n        if (!previous) {\n            return undefined;\n        }\n        (_a = this.transform.nodes) === null || _a === void 0 ? void 0 : _a.end.disconnect();\n        this.transform = undefined;\n        this.reconnectAudioInputs();\n        return previous;\n    }\n    attachAudioInputStreamToAudioContext(stream) {\n        var _a;\n        (_a = this.audioInputSourceNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.audioInputSourceNode = DefaultDeviceController.getAudioContext().createMediaStreamSource(stream);\n        const output = this.getMediaStreamOutputNode();\n        this.audioInputSourceNode.connect(output);\n    }\n    /**\n     * Return the end of the Web Audio graph: post-transform audio.\n     */\n    getMediaStreamDestinationNode() {\n        if (!this.audioInputDestinationNode) {\n            this.audioInputDestinationNode = DefaultDeviceController.getAudioContext().createMediaStreamDestination();\n        }\n        return this.audioInputDestinationNode;\n    }\n    /**\n     * Return the start of the Web Audio graph: pre-transform audio.\n     * If there's no transform node, this is the destination node.\n     */\n    getMediaStreamOutputNode() {\n        var _a, _b;\n        return ((_b = (_a = this.transform) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.start) || this.getMediaStreamDestinationNode();\n    }\n    static getAudioContext() {\n        if (!DefaultDeviceController.audioContext) {\n            const options = {};\n            if (navigator.mediaDevices.getSupportedConstraints().sampleRate) {\n                options.sampleRate = DefaultDeviceController.defaultSampleRate;\n            }\n            // @ts-ignore\n            DefaultDeviceController.audioContext = new (window.AudioContext || window.webkitAudioContext)(options);\n        }\n        return DefaultDeviceController.audioContext;\n    }\n    static closeAudioContext() {\n        if (DefaultDeviceController.audioContext) {\n            try {\n                DefaultDeviceController.audioContext.close();\n            }\n            catch (e) {\n                // Nothing we can do.\n            }\n        }\n        DefaultDeviceController.audioContext = null;\n    }\n    supportSampleRateConstraint() {\n        return this.useWebAudio && !!navigator.mediaDevices.getSupportedConstraints().sampleRate;\n    }\n    supportSampleSizeConstraint() {\n        return this.useWebAudio && !!navigator.mediaDevices.getSupportedConstraints().sampleSize;\n    }\n    supportChannelCountConstraint() {\n        return this.useWebAudio && !!navigator.mediaDevices.getSupportedConstraints().channelCount;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    trace(name, input, output) {\n        let s = `API/DefaultDeviceController/${name}`;\n        if (typeof input !== 'undefined') {\n            s += ` ${JSON.stringify(input)}`;\n        }\n        if (typeof output !== 'undefined') {\n            s += ` -> ${JSON.stringify(output)}`;\n        }\n        this.logger.info(s);\n    }\n}\nexports.default = DefaultDeviceController;\nDefaultDeviceController.permissionDeniedOriginDetectionThresholdMs = 500;\nDefaultDeviceController.defaultVideoWidth = 960;\nDefaultDeviceController.defaultVideoHeight = 540;\nDefaultDeviceController.defaultVideoFrameRate = 15;\nDefaultDeviceController.defaultVideoMaxBandwidthKbps = 1400;\nDefaultDeviceController.defaultSampleRate = 48000;\nDefaultDeviceController.defaultSampleSize = 16;\nDefaultDeviceController.defaultChannelCount = 1;\nDefaultDeviceController.audioContext = null;\nfunction isMediaDeviceInfo(device) {\n    return (typeof device === 'object' &&\n        'deviceId' in device &&\n        'groupId' in device &&\n        'kind' in device &&\n        'label' in device);\n}\n//# sourceMappingURL=DefaultDeviceController.js.map"]},"metadata":{},"sourceType":"script"}