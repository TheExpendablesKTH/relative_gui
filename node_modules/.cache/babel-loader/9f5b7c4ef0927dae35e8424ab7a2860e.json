{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n/**\n * A device that augments an {@link Device} to apply Amazon Voice Focus\n * noise suppression to an audio input.\n */\n\n\nclass VoiceFocusTransformDevice {\n  /** @internal */\n  constructor(device, voiceFocus, delegate, nodeOptions, failed = false, node = undefined, browserBehavior = new DefaultBrowserBehavior_1.default()) {\n    this.device = device;\n    this.voiceFocus = voiceFocus;\n    this.delegate = delegate;\n    this.nodeOptions = nodeOptions;\n    this.failed = failed;\n    this.node = node;\n    this.browserBehavior = browserBehavior;\n  }\n  /**\n   * Return the inner device as provided during construction, or updated via\n   * {@link chooseNewInnerDevice}. Do not confuse this method with {@link intrinsicDevice}.\n   */\n\n\n  getInnerDevice() {\n    return this.device;\n  }\n  /**\n   * Disable the audio node while muted to reduce CPU usage.\n   *\n   * @param muted whether the audio device should be muted.\n   */\n\n\n  mute(muted) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.node) {\n        return;\n      }\n\n      if (muted) {\n        yield this.node.disable();\n      } else {\n        yield this.node.enable();\n      }\n    });\n  }\n  /**\n   * Dispose of the inner workings of the transform device. After this method is called\n   * you will need to create a new device to use Amazon Voice Focus again.\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.node) {\n        return;\n      }\n\n      this.node.disconnect();\n      yield this.node.stop();\n    });\n  }\n  /**\n   * If you wish to choose a different inner device, but continue to use Amazon Voice Focus, you\n   * can use this method to efficiently create a new device that will reuse\n   * the same internal state. Only one of the two devices can be used at a time: switch\n   * between them using {@link DeviceController.chooseAudioInputDevice}.\n   *\n   * If the same device is passed as is currently in use, `this` is returned.\n   *\n   * @param inner The new inner device to use.\n   */\n\n\n  chooseNewInnerDevice(inner) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // If the new device is 'default', always recreate. Chrome can switch out\n      // the real device underneath us.\n      if (this.device === inner && !isDefaultDevice(inner)) {\n        return this;\n      }\n\n      return new VoiceFocusTransformDevice(inner, this.voiceFocus, this.delegate, this.nodeOptions, this.failed, this.node, this.browserBehavior);\n    });\n  }\n\n  intrinsicDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.failed) {\n        return this.device;\n      } // Turn the Device into constraints with appropriate AGC settings.\n\n\n      const trackConstraints = {\n        echoCancellation: true,\n        // @ts-ignore\n        googEchoCancellation: true,\n        // @ts-ignore\n        googEchoCancellation2: true,\n        noiseSuppression: false,\n        // @ts-ignore\n        googNoiseSuppression: false,\n        // @ts-ignore\n        googHighpassFilter: false,\n        // @ts-ignore\n        googNoiseSuppression2: false\n      };\n      let useBuiltInAGC;\n\n      if (this.nodeOptions && this.nodeOptions.agc !== undefined) {\n        useBuiltInAGC = this.nodeOptions.agc.useBuiltInAGC;\n      } else {\n        useBuiltInAGC = true;\n      }\n\n      trackConstraints.autoGainControl = useBuiltInAGC; // @ts-ignore\n\n      trackConstraints.googAutoGainControl = useBuiltInAGC; // @ts-ignore\n\n      trackConstraints.googAutoGainControl2 = useBuiltInAGC; // Empty string and null.\n\n      if (!this.device) {\n        return trackConstraints;\n      } // Device ID.\n\n\n      if (typeof this.device === 'string') {\n        /* istanbul ignore if */\n        if (this.browserBehavior.requiresNoExactMediaStreamConstraints()) {\n          trackConstraints.deviceId = this.device;\n        } else {\n          trackConstraints.deviceId = {\n            exact: this.device\n          };\n        }\n\n        return trackConstraints;\n      } // It's a stream.\n\n\n      if (this.device.id) {\n        // Nothing we can do.\n        return this.device;\n      } // It's constraints.\n\n\n      return Object.assign(Object.assign({}, this.device), trackConstraints);\n    });\n  }\n\n  createAudioNode(context) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (((_a = this.node) === null || _a === void 0 ? void 0 : _a.context) === context) {\n        return {\n          start: this.node,\n          end: this.node\n        };\n      }\n\n      const agc = {\n        useVoiceFocusAGC: false\n      };\n      const options = Object.assign({\n        enabled: true,\n        agc\n      }, this.nodeOptions);\n\n      try {\n        (_b = this.node) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.node = yield this.voiceFocus.createNode(context, options);\n        const start = this.node;\n        const end = this.node;\n        return {\n          start,\n          end\n        };\n      } catch (e) {\n        // It's better to return some audio stream than nothing.\n        this.failed = true;\n        this.delegate.onFallback(this, e);\n        throw e;\n      }\n    });\n  }\n  /**\n   * Add an observer to receive notifications about Amazon Voice Focus lifecycle events.\n   * See {@link VoiceFocusTransformDeviceObserver} for details.\n   * If the observer has already been added, this method call has no effect.\n   */\n\n\n  addObserver(observer) {\n    this.delegate.addObserver(observer);\n  }\n  /**\n   * Remove an existing observer. If the observer has not been previously {@link\n   * VoiceFocusTransformDevice.addObserver|added}, this method call has no effect.\n   */\n\n\n  removeObserver(observer) {\n    this.delegate.removeObserver(observer);\n  }\n\n}\n\nfunction isDefaultDevice(device) {\n  if (device === 'default') {\n    return true;\n  }\n\n  if (!device || typeof device !== 'object') {\n    return false;\n  }\n\n  if ('deviceId' in device && device.deviceId === 'default') {\n    return true;\n  }\n\n  if ('id' in device && device.id === 'default') {\n    return true;\n  }\n\n  return false;\n}\n\nexports.default = VoiceFocusTransformDevice;","map":{"version":3,"sources":["../../src/voicefocus/VoiceFocusTransformDevice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n/**\n * A device that augments an {@link Device} to apply Amazon Voice Focus\n * noise suppression to an audio input.\n */\nclass VoiceFocusTransformDevice {\n    /** @internal */\n    constructor(device, voiceFocus, delegate, nodeOptions, failed = false, node = undefined, browserBehavior = new DefaultBrowserBehavior_1.default()) {\n        this.device = device;\n        this.voiceFocus = voiceFocus;\n        this.delegate = delegate;\n        this.nodeOptions = nodeOptions;\n        this.failed = failed;\n        this.node = node;\n        this.browserBehavior = browserBehavior;\n    }\n    /**\n     * Return the inner device as provided during construction, or updated via\n     * {@link chooseNewInnerDevice}. Do not confuse this method with {@link intrinsicDevice}.\n     */\n    getInnerDevice() {\n        return this.device;\n    }\n    /**\n     * Disable the audio node while muted to reduce CPU usage.\n     *\n     * @param muted whether the audio device should be muted.\n     */\n    mute(muted) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.node) {\n                return;\n            }\n            if (muted) {\n                yield this.node.disable();\n            }\n            else {\n                yield this.node.enable();\n            }\n        });\n    }\n    /**\n     * Dispose of the inner workings of the transform device. After this method is called\n     * you will need to create a new device to use Amazon Voice Focus again.\n     */\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.node) {\n                return;\n            }\n            this.node.disconnect();\n            yield this.node.stop();\n        });\n    }\n    /**\n     * If you wish to choose a different inner device, but continue to use Amazon Voice Focus, you\n     * can use this method to efficiently create a new device that will reuse\n     * the same internal state. Only one of the two devices can be used at a time: switch\n     * between them using {@link DeviceController.chooseAudioInputDevice}.\n     *\n     * If the same device is passed as is currently in use, `this` is returned.\n     *\n     * @param inner The new inner device to use.\n     */\n    chooseNewInnerDevice(inner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If the new device is 'default', always recreate. Chrome can switch out\n            // the real device underneath us.\n            if (this.device === inner && !isDefaultDevice(inner)) {\n                return this;\n            }\n            return new VoiceFocusTransformDevice(inner, this.voiceFocus, this.delegate, this.nodeOptions, this.failed, this.node, this.browserBehavior);\n        });\n    }\n    intrinsicDevice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.failed) {\n                return this.device;\n            }\n            // Turn the Device into constraints with appropriate AGC settings.\n            const trackConstraints = {\n                echoCancellation: true,\n                // @ts-ignore\n                googEchoCancellation: true,\n                // @ts-ignore\n                googEchoCancellation2: true,\n                noiseSuppression: false,\n                // @ts-ignore\n                googNoiseSuppression: false,\n                // @ts-ignore\n                googHighpassFilter: false,\n                // @ts-ignore\n                googNoiseSuppression2: false,\n            };\n            let useBuiltInAGC;\n            if (this.nodeOptions && this.nodeOptions.agc !== undefined) {\n                useBuiltInAGC = this.nodeOptions.agc.useBuiltInAGC;\n            }\n            else {\n                useBuiltInAGC = true;\n            }\n            trackConstraints.autoGainControl = useBuiltInAGC;\n            // @ts-ignore\n            trackConstraints.googAutoGainControl = useBuiltInAGC;\n            // @ts-ignore\n            trackConstraints.googAutoGainControl2 = useBuiltInAGC;\n            // Empty string and null.\n            if (!this.device) {\n                return trackConstraints;\n            }\n            // Device ID.\n            if (typeof this.device === 'string') {\n                /* istanbul ignore if */\n                if (this.browserBehavior.requiresNoExactMediaStreamConstraints()) {\n                    trackConstraints.deviceId = this.device;\n                }\n                else {\n                    trackConstraints.deviceId = { exact: this.device };\n                }\n                return trackConstraints;\n            }\n            // It's a stream.\n            if (this.device.id) {\n                // Nothing we can do.\n                return this.device;\n            }\n            // It's constraints.\n            return Object.assign(Object.assign({}, this.device), trackConstraints);\n        });\n    }\n    createAudioNode(context) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (((_a = this.node) === null || _a === void 0 ? void 0 : _a.context) === context) {\n                return {\n                    start: this.node,\n                    end: this.node,\n                };\n            }\n            const agc = { useVoiceFocusAGC: false };\n            const options = Object.assign({ enabled: true, agc }, this.nodeOptions);\n            try {\n                (_b = this.node) === null || _b === void 0 ? void 0 : _b.disconnect();\n                this.node = yield this.voiceFocus.createNode(context, options);\n                const start = this.node;\n                const end = this.node;\n                return { start, end };\n            }\n            catch (e) {\n                // It's better to return some audio stream than nothing.\n                this.failed = true;\n                this.delegate.onFallback(this, e);\n                throw e;\n            }\n        });\n    }\n    /**\n     * Add an observer to receive notifications about Amazon Voice Focus lifecycle events.\n     * See {@link VoiceFocusTransformDeviceObserver} for details.\n     * If the observer has already been added, this method call has no effect.\n     */\n    addObserver(observer) {\n        this.delegate.addObserver(observer);\n    }\n    /**\n     * Remove an existing observer. If the observer has not been previously {@link\n     * VoiceFocusTransformDevice.addObserver|added}, this method call has no effect.\n     */\n    removeObserver(observer) {\n        this.delegate.removeObserver(observer);\n    }\n}\nfunction isDefaultDevice(device) {\n    if (device === 'default') {\n        return true;\n    }\n    if (!device || typeof device !== 'object') {\n        return false;\n    }\n    if ('deviceId' in device && device.deviceId === 'default') {\n        return true;\n    }\n    if ('id' in device && device.id === 'default') {\n        return true;\n    }\n    return false;\n}\nexports.default = VoiceFocusTransformDevice;\n//# sourceMappingURL=VoiceFocusTransformDevice.js.map"]},"metadata":{},"sourceType":"script"}