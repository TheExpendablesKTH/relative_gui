{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst LogLevel_1 = require(\"../logger/LogLevel\");\n\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\n\nconst Log_1 = require(\"./Log\");\n/**\n * `MeetingSessionPOSTLogger` publishes log messages in batches to a URL\n * supplied during its construction.\n *\n * Be sure to call {@link MeetingSessionPOSTLogger.dispose} when you're done\n * with the logger in order to avoid leaks.\n */\n\n\nclass MeetingSessionPOSTLogger {\n  constructor(name, configuration, batchSize, intervalMs, url, level = LogLevel_1.default.WARN) {\n    this.name = name;\n    this.configuration = configuration;\n    this.batchSize = batchSize;\n    this.intervalMs = intervalMs;\n    this.url = url;\n    this.level = level;\n    this.logCapture = [];\n    this.sequenceNumber = 0;\n    this.lock = false;\n    this.startLogPublishScheduler(this.batchSize);\n\n    this.eventListener = () => {\n      this.stop();\n    };\n\n    this.addEventListener();\n  }\n\n  addEventListener() {\n    if (!this.eventListener || !('window' in global) || !window.addEventListener) {\n      return;\n    }\n\n    window.addEventListener('unload', this.eventListener);\n  }\n\n  removeEventListener() {\n    if (!this.eventListener || !('window' in global) || !window.removeEventListener) {\n      return;\n    }\n\n    window.removeEventListener('unload', this.eventListener);\n  }\n\n  debug(debugFunction) {\n    if (LogLevel_1.default.DEBUG < this.level) {\n      return;\n    }\n\n    if (typeof debugFunction === 'string') {\n      this.log(LogLevel_1.default.DEBUG, debugFunction);\n    } else if (debugFunction) {\n      this.log(LogLevel_1.default.DEBUG, debugFunction());\n    } else {\n      this.log(LogLevel_1.default.DEBUG, '' + debugFunction);\n    }\n  }\n\n  info(msg) {\n    this.log(LogLevel_1.default.INFO, msg);\n  }\n\n  warn(msg) {\n    this.log(LogLevel_1.default.WARN, msg);\n  }\n\n  error(msg) {\n    this.log(LogLevel_1.default.ERROR, msg);\n  }\n\n  setLogLevel(level) {\n    this.level = level;\n  }\n\n  getLogLevel() {\n    return this.level;\n  }\n\n  getLogCaptureSize() {\n    return this.logCapture.length;\n  }\n\n  startLogPublishScheduler(batchSize) {\n    var _a;\n\n    this.addEventListener();\n    (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n    this.intervalScheduler = new IntervalScheduler_1.default(this.intervalMs);\n    this.intervalScheduler.start(() => __awaiter(this, void 0, void 0, function* () {\n      if (this.lock === true || this.getLogCaptureSize() === 0) {\n        return;\n      }\n\n      this.lock = true;\n      const batch = this.logCapture.slice(0, batchSize);\n      const body = this.makeRequestBody(batch);\n\n      try {\n        const response = yield fetch(this.url, {\n          method: 'POST',\n          body\n        });\n\n        if (response.status === 200) {\n          this.logCapture = this.logCapture.slice(batch.length);\n        }\n      } catch (error) {\n        console.warn('[MeetingSessionPOSTLogger] ' + error.message);\n      } finally {\n        this.lock = false;\n      }\n    }));\n  }\n\n  stop() {\n    var _a; // Clean up to avoid resource leaks.\n\n\n    (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n    this.intervalScheduler = undefined;\n    this.removeEventListener();\n    const body = this.makeRequestBody(this.logCapture);\n    navigator.sendBeacon(this.url, body);\n  }\n  /**\n   * Permanently clean up the logger. A new logger must be created to\n   * resume logging.\n   */\n\n\n  destroy() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n      this.intervalScheduler = undefined;\n      this.removeEventListener();\n      this.configuration = undefined;\n      this.logCapture = [];\n    });\n  }\n\n  makeRequestBody(batch) {\n    return JSON.stringify({\n      meetingId: this.configuration.meetingId,\n      attendeeId: this.configuration.credentials.attendeeId,\n      appName: this.name,\n      logs: batch\n    });\n  }\n\n  log(type, msg) {\n    if (type < this.level) {\n      return;\n    }\n\n    const now = Date.now(); // Handle undefined.\n\n    this.logCapture.push(new Log_1.default(this.sequenceNumber, msg, now, LogLevel_1.default[type]));\n    this.sequenceNumber += 1;\n  }\n\n}\n\nexports.default = MeetingSessionPOSTLogger;","map":{"version":3,"sources":["../../src/logger/MeetingSessionPOSTLogger.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LogLevel_1 = require(\"../logger/LogLevel\");\nconst IntervalScheduler_1 = require(\"../scheduler/IntervalScheduler\");\nconst Log_1 = require(\"./Log\");\n/**\n * `MeetingSessionPOSTLogger` publishes log messages in batches to a URL\n * supplied during its construction.\n *\n * Be sure to call {@link MeetingSessionPOSTLogger.dispose} when you're done\n * with the logger in order to avoid leaks.\n */\nclass MeetingSessionPOSTLogger {\n    constructor(name, configuration, batchSize, intervalMs, url, level = LogLevel_1.default.WARN) {\n        this.name = name;\n        this.configuration = configuration;\n        this.batchSize = batchSize;\n        this.intervalMs = intervalMs;\n        this.url = url;\n        this.level = level;\n        this.logCapture = [];\n        this.sequenceNumber = 0;\n        this.lock = false;\n        this.startLogPublishScheduler(this.batchSize);\n        this.eventListener = () => {\n            this.stop();\n        };\n        this.addEventListener();\n    }\n    addEventListener() {\n        if (!this.eventListener || !('window' in global) || !window.addEventListener) {\n            return;\n        }\n        window.addEventListener('unload', this.eventListener);\n    }\n    removeEventListener() {\n        if (!this.eventListener || !('window' in global) || !window.removeEventListener) {\n            return;\n        }\n        window.removeEventListener('unload', this.eventListener);\n    }\n    debug(debugFunction) {\n        if (LogLevel_1.default.DEBUG < this.level) {\n            return;\n        }\n        if (typeof debugFunction === 'string') {\n            this.log(LogLevel_1.default.DEBUG, debugFunction);\n        }\n        else if (debugFunction) {\n            this.log(LogLevel_1.default.DEBUG, debugFunction());\n        }\n        else {\n            this.log(LogLevel_1.default.DEBUG, '' + debugFunction);\n        }\n    }\n    info(msg) {\n        this.log(LogLevel_1.default.INFO, msg);\n    }\n    warn(msg) {\n        this.log(LogLevel_1.default.WARN, msg);\n    }\n    error(msg) {\n        this.log(LogLevel_1.default.ERROR, msg);\n    }\n    setLogLevel(level) {\n        this.level = level;\n    }\n    getLogLevel() {\n        return this.level;\n    }\n    getLogCaptureSize() {\n        return this.logCapture.length;\n    }\n    startLogPublishScheduler(batchSize) {\n        var _a;\n        this.addEventListener();\n        (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n        this.intervalScheduler = new IntervalScheduler_1.default(this.intervalMs);\n        this.intervalScheduler.start(() => __awaiter(this, void 0, void 0, function* () {\n            if (this.lock === true || this.getLogCaptureSize() === 0) {\n                return;\n            }\n            this.lock = true;\n            const batch = this.logCapture.slice(0, batchSize);\n            const body = this.makeRequestBody(batch);\n            try {\n                const response = yield fetch(this.url, {\n                    method: 'POST',\n                    body,\n                });\n                if (response.status === 200) {\n                    this.logCapture = this.logCapture.slice(batch.length);\n                }\n            }\n            catch (error) {\n                console.warn('[MeetingSessionPOSTLogger] ' + error.message);\n            }\n            finally {\n                this.lock = false;\n            }\n        }));\n    }\n    stop() {\n        var _a;\n        // Clean up to avoid resource leaks.\n        (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n        this.intervalScheduler = undefined;\n        this.removeEventListener();\n        const body = this.makeRequestBody(this.logCapture);\n        navigator.sendBeacon(this.url, body);\n    }\n    /**\n     * Permanently clean up the logger. A new logger must be created to\n     * resume logging.\n     */\n    destroy() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.intervalScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n            this.intervalScheduler = undefined;\n            this.removeEventListener();\n            this.configuration = undefined;\n            this.logCapture = [];\n        });\n    }\n    makeRequestBody(batch) {\n        return JSON.stringify({\n            meetingId: this.configuration.meetingId,\n            attendeeId: this.configuration.credentials.attendeeId,\n            appName: this.name,\n            logs: batch,\n        });\n    }\n    log(type, msg) {\n        if (type < this.level) {\n            return;\n        }\n        const now = Date.now();\n        // Handle undefined.\n        this.logCapture.push(new Log_1.default(this.sequenceNumber, msg, now, LogLevel_1.default[type]));\n        this.sequenceNumber += 1;\n    }\n}\nexports.default = MeetingSessionPOSTLogger;\n//# sourceMappingURL=MeetingSessionPOSTLogger.js.map"]},"metadata":{},"sourceType":"script"}