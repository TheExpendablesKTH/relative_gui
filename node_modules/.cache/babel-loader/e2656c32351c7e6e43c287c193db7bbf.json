{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ClientMetricReportDirection_1 = require(\"../clientmetricreport/ClientMetricReportDirection\");\n\nconst ContentShareConstants_1 = require(\"../contentsharecontroller/ContentShareConstants\");\n\nconst DefaultVideoStreamIdSet_1 = require(\"../videostreamidset/DefaultVideoStreamIdSet\");\n\nclass LinkMediaStats {\n  constructor() {\n    this.bandwidthEstimateKbps = 0;\n    this.usedBandwidthKbps = 0;\n    this.packetsLost = 0;\n    this.nackCount = 0;\n    this.rttMs = 0;\n  }\n\n}\n\nclass VideoAdaptiveProbePolicy {\n  constructor(logger, tileController) {\n    this.logger = logger;\n    this.tileController = tileController;\n    this.reset();\n  }\n\n  reset() {\n    this.optimalReceiveSet = new DefaultVideoStreamIdSet_1.default();\n    this.subscribedReceiveSet = new DefaultVideoStreamIdSet_1.default();\n    this.logCount = 0;\n    this.startupPeriod = true;\n    this.usingPrevTargetRate = false;\n    this.rateProbeState = \"Not Probing\"\n    /* kNotProbing */\n    ;\n    this.timeFirstEstimate = 0;\n    this.lastUpgradeRateKbps = 0;\n    this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n    this.timeLastProbe = Date.now();\n    this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n    this.downlinkStats = new LinkMediaStats();\n    this.prevDownlinkStats = new LinkMediaStats();\n  }\n\n  updateIndex(videoIndex) {\n    this.videoIndex = videoIndex;\n  }\n\n  updateMetrics(clientMetricReport) {\n    if (this.videoIndex.allStreams().empty()) {\n      return;\n    }\n\n    this.prevDownlinkStats = this.downlinkStats;\n    this.downlinkStats = new LinkMediaStats();\n    const metricReport = clientMetricReport.getObservableMetrics();\n    this.downlinkStats.bandwidthEstimateKbps = metricReport.availableReceiveBandwidth / 1000;\n\n    for (const ssrcStr in clientMetricReport.streamMetricReports) {\n      const ssrc = Number(ssrcStr);\n\n      if (clientMetricReport.streamMetricReports[ssrc].direction === ClientMetricReportDirection_1.default.DOWNSTREAM) {\n        // Only use video stream metrics\n        if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googNacksSent') && clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n          this.downlinkStats.nackCount += clientMetricReport.countPerSecond('googNacksSent', ssrc);\n        }\n\n        if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('packetsLost') && clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n          this.downlinkStats.packetsLost += clientMetricReport.countPerSecond('packetsLost', ssrc);\n        }\n\n        if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('bytesReceived')) {\n          this.downlinkStats.usedBandwidthKbps += clientMetricReport.bitsPerSecond('bytesReceived', ssrc) / 1000;\n        }\n      }\n    }\n  }\n\n  wantsResubscribe() {\n    this.optimalReceiveSet = this.calculateOptimalReceiveSet();\n    return !this.subscribedReceiveSet.equal(this.optimalReceiveSet);\n  }\n\n  chooseSubscriptions() {\n    if (!this.subscribedReceiveSet.equal(this.optimalReceiveSet)) {\n      this.timeLastSubscribe = Date.now();\n    }\n\n    this.subscribedReceiveSet = this.optimalReceiveSet.clone();\n    this.logger.info('bwe: chooseSubscriptions ' + JSON.stringify(this.subscribedReceiveSet));\n    return this.subscribedReceiveSet.clone();\n  }\n\n  calculateOptimalReceiveSet() {\n    const streamSelectionSet = new DefaultVideoStreamIdSet_1.default();\n    const lastProbeState = this.rateProbeState;\n    const remoteInfos = this.videoIndex.remoteStreamDescriptions();\n\n    if (remoteInfos.length === 0) {\n      return streamSelectionSet;\n    }\n\n    const pausedStreamIds = new DefaultVideoStreamIdSet_1.default();\n    this.handlePausedStreams(streamSelectionSet, pausedStreamIds, remoteInfos);\n    const sameStreamChoices = this.availStreamsSameAsLast(remoteInfos); // If no major changes then don't allow subscribes for the allowed amount of time\n\n    if (!this.startupPeriod && sameStreamChoices && Date.now() - this.timeLastSubscribe < this.timeBeforeAllowSubscribeMs) {\n      return this.optimalReceiveSet;\n    } // reset time before allow subscribe to default\n\n\n    this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n    const chosenStreams = []; // Sort streams by bitrate asceending.\n\n    remoteInfos.sort((a, b) => {\n      if (a.maxBitrateKbps === b.maxBitrateKbps) {\n        return a.streamId - b.streamId;\n      }\n\n      return a.maxBitrateKbps - b.maxBitrateKbps;\n    }); // Convert 0 avg bitrates to max and handle special cases\n\n    for (const info of remoteInfos) {\n      if (info.avgBitrateKbps === 0 || info.avgBitrateKbps > info.maxBitrateKbps) {\n        // Content can be a special case\n        if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality) && info.maxBitrateKbps < 100) {\n          info.maxBitrateKbps = info.avgBitrateKbps;\n        } else {\n          info.avgBitrateKbps = info.maxBitrateKbps;\n        }\n      }\n    }\n\n    const targetDownlinkBitrate = this.determineTargetRate(remoteInfos);\n    let deltaToNextUpgrade = 0;\n    let chosenTotalBitrate = 0;\n    let upgradeStream; // If screen share is available, then subscribe to that first before anything else\n\n    chosenTotalBitrate += this.chooseContent(chosenStreams, remoteInfos); // Try to have at least one stream from every group first\n    // Since the streams are sorted this will pick the lowest bitrates first\n\n    for (const info of remoteInfos) {\n      if (info.avgBitrateKbps === 0) {\n        continue;\n      }\n\n      if (chosenStreams.findIndex(stream => stream.groupId === info.groupId) === -1) {\n        if (chosenTotalBitrate + info.avgBitrateKbps <= targetDownlinkBitrate) {\n          chosenStreams.push(info);\n          chosenTotalBitrate += info.avgBitrateKbps;\n        } else if (deltaToNextUpgrade === 0) {\n          // Keep track of step to next upgrade\n          deltaToNextUpgrade = info.avgBitrateKbps;\n          upgradeStream = info;\n        }\n      }\n    } // Look for upgrades until we run out of bandwidth\n\n\n    let lookForUpgrades = true;\n\n    while (lookForUpgrades) {\n      // We will set this to true if we find any new upgrades during the loop over the\n      // chosen streams (i.e. when we do a full loop without an upgrade we will give up)\n      lookForUpgrades = false;\n      chosenStreams.forEach((chosenStream, index) => {\n        for (const info of remoteInfos) {\n          if (info.groupId === chosenStream.groupId && info.streamId !== chosenStream.streamId && info.avgBitrateKbps > chosenStream.avgBitrateKbps) {\n            const increaseKbps = info.avgBitrateKbps - chosenStream.avgBitrateKbps;\n\n            if (chosenTotalBitrate + increaseKbps <= targetDownlinkBitrate) {\n              chosenTotalBitrate += increaseKbps;\n              chosenStreams[index] = info;\n              lookForUpgrades = true;\n            } else if (deltaToNextUpgrade === 0) {\n              // Keep track of step to next upgrade\n              deltaToNextUpgrade = increaseKbps;\n              upgradeStream = info;\n            }\n          }\n        }\n      });\n    }\n\n    let subscriptionChoice = 0\n    /* kNewOptimal */\n    ; // Look for probing or override opportunities\n\n    if (!this.startupPeriod && sameStreamChoices && deltaToNextUpgrade !== 0) {\n      if (this.rateProbeState === \"Probing\"\n      /* kProbing */\n      ) {\n          subscriptionChoice = this.handleProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos);\n        } else {\n        subscriptionChoice = this.maybeOverrideOrProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, chosenTotalBitrate, deltaToNextUpgrade, upgradeStream);\n      }\n    } else {\n      // If there was a change in streams to choose from, then cancel any probing or upgrades\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      this.lastUpgradeRateKbps = 0;\n    }\n\n    let decisionLogStr = this.policyStateLogStr(remoteInfos, targetDownlinkBitrate);\n\n    if (this.logCount % 15 === 0 || this.rateProbeState !== lastProbeState) {\n      this.logger.info(decisionLogStr);\n      this.logCount = 0;\n      decisionLogStr = '';\n    }\n\n    this.logCount++;\n    this.prevTargetRateKbps = targetDownlinkBitrate;\n    this.prevRemoteInfos = remoteInfos;\n\n    if (subscriptionChoice === 1\n    /* kPreviousOptimal */\n    ) {\n        this.logger.info('bwe: keepSameSubscriptions');\n\n        if (decisionLogStr.length > 0) {\n          this.logger.info(decisionLogStr);\n        }\n\n        return this.optimalReceiveSet;\n      } else if (subscriptionChoice === 2\n    /* kPreProbe */\n    ) {\n        const subscribedRate = this.calculateSubscribeRate(remoteInfos, this.preProbeReceiveSet);\n        this.logger.info('bwe: Use Pre-Probe subscription subscribedRate:' + subscribedRate);\n        return this.preProbeReceiveSet;\n      }\n\n    for (const chosenStream of chosenStreams) {\n      streamSelectionSet.add(chosenStream.streamId);\n    }\n\n    if (!this.optimalReceiveSet.equal(streamSelectionSet)) {\n      if (decisionLogStr.length > 0) {\n        this.logger.info(decisionLogStr);\n      }\n\n      const subscribedRate = this.calculateSubscribeRate(remoteInfos, streamSelectionSet);\n      this.logger.info(`bwe: new streamSelection: ${JSON.stringify(streamSelectionSet)} subscribedRate:${subscribedRate}`);\n    }\n\n    return streamSelectionSet;\n  }\n\n  determineTargetRate(remoteInfos) {\n    let targetBitrate = 0; // Estimated downlink bandwidth from WebRTC is dependent on actually receiving data, so if it ever got driven below the bitrate of the lowest\n    // stream (a simulcast stream), and it stops receiving, it will get stuck never being able to resubscribe (as is implemented).\n\n    let minTargetDownlinkBitrate = Number.MAX_VALUE;\n\n    for (const info of remoteInfos) {\n      if (info.avgBitrateKbps !== 0 && info.avgBitrateKbps < minTargetDownlinkBitrate) {\n        minTargetDownlinkBitrate = info.avgBitrateKbps;\n      }\n    }\n\n    const now = Date.now(); // Startup phase handling.  During this period the estimate can be 0 or\n    // could still be slowly hunting for a steady state.  This startup ramp up\n    // can cause a series of subscribes which can be distracting. During this\n    // time just use our configured default value\n\n    if (this.downlinkStats.bandwidthEstimateKbps !== 0) {\n      if (this.timeFirstEstimate === 0) {\n        this.timeFirstEstimate = now;\n      } // handle startup state where estimator is still converging.\n\n\n      if (this.startupPeriod) {\n        // Drop out of startup period if\n        // - estimate is above default\n        // - get packet loss and have a valid estimate\n        // - startup period has expired and rate is not still increasing\n        if (this.downlinkStats.bandwidthEstimateKbps > VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS || this.downlinkStats.packetsLost > 0 || now - this.timeFirstEstimate > VideoAdaptiveProbePolicy.STARTUP_PERIOD_MS && this.downlinkStats.bandwidthEstimateKbps <= this.prevDownlinkStats.bandwidthEstimateKbps) {\n          this.startupPeriod = false;\n          this.prevTargetRateKbps = this.downlinkStats.bandwidthEstimateKbps;\n        }\n      } // If we are in the startup period and we haven't detected any packet loss, then\n      // keep it at the default to let the estimation get to a steady state\n\n\n      if (this.startupPeriod) {\n        targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        targetBitrate = this.downlinkStats.bandwidthEstimateKbps;\n      }\n    } else {\n      if (this.timeFirstEstimate === 0) {\n        targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        targetBitrate = this.prevTargetRateKbps;\n      }\n    }\n\n    targetBitrate = Math.max(minTargetDownlinkBitrate, targetBitrate); // Estimated downlink rate can follow actual bandwidth or fall for a short period of time\n    // due to the absolute send time estimator incorrectly thinking that a delay in packets is\n    // a precursor to packet loss.  We have seen too many false positives on this, so we\n    // will ignore largish drops in the estimate if there is no packet loss\n\n    if (!this.startupPeriod && (this.usingPrevTargetRate && this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps || this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps * (100 - VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT) / 100 || this.downlinkStats.bandwidthEstimateKbps < this.downlinkStats.usedBandwidthKbps * VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT / 100) && this.downlinkStats.packetsLost === 0) {\n      // Set target to be the same as last\n      this.logger.debug(() => {\n        return 'bwe: ValidateRate: Using Previous rate ' + this.prevTargetRateKbps;\n      });\n      this.usingPrevTargetRate = true;\n      targetBitrate = this.prevTargetRateKbps;\n    } else {\n      this.usingPrevTargetRate = false;\n    }\n\n    return targetBitrate;\n  }\n\n  setProbeState(newState) {\n    if (this.rateProbeState === newState) return;\n    const now = Date.now();\n\n    switch (newState) {\n      case \"Not Probing\"\n      /* kNotProbing */\n      :\n        this.timeProbePendingStart = 0;\n        break;\n\n      case \"Probe Pending\"\n      /* kProbePending */\n      :\n        if (this.timeLastProbe === 0 || now - this.timeLastProbe > VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE) {\n          this.timeProbePendingStart = now;\n        } else {\n          // Too soon to do a probe again\n          return false;\n        }\n\n        break;\n\n      case \"Probing\"\n      /* kProbing */\n      :\n        if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n          this.timeLastProbe = now;\n          this.preProbeReceiveSet = this.subscribedReceiveSet; // Increase the time allowed until the next probe\n\n          this.timeBeforeAllowProbeMs = Math.min(this.timeBeforeAllowProbeMs * 2, VideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE);\n        } else {\n          // Too soon to do probe\n          return false;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    this.logger.info('bwe: setProbeState to ' + newState + ' from ' + this.rateProbeState);\n    this.rateProbeState = newState;\n    return true;\n  } // Upgrade the stream id from the appropriate group or add it if it wasn't already in the list.\n  // Return the added amount of bandwidth\n\n\n  upgradeToStream(chosenStreams, upgradeStream) {\n    for (let i = 0; i < chosenStreams.length; i++) {\n      if (chosenStreams[i].groupId === upgradeStream.groupId) {\n        const diffRate = upgradeStream.avgBitrateKbps - chosenStreams[i].avgBitrateKbps;\n        this.logger.info('bwe: upgradeStream from ' + JSON.stringify(chosenStreams[i]) + ' to ' + JSON.stringify(upgradeStream));\n        this.lastUpgradeRateKbps = diffRate;\n        chosenStreams[i] = upgradeStream;\n        return diffRate;\n      }\n    } // We are adding a stream and not upgrading.\n\n\n    chosenStreams.push(upgradeStream);\n    this.lastUpgradeRateKbps = upgradeStream.avgBitrateKbps;\n    return this.lastUpgradeRateKbps;\n  } // Do specific behavior while we are currently in probing state and metrics\n  // indicate environment is still valid to do probing.\n  // Return true if the caller should not change from the previous subscriptions.\n\n\n  handleProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos) {\n    if (this.rateProbeState !== \"Probing\"\n    /* kProbing */\n    ) {\n        return 0\n        /* kNewOptimal */\n        ;\n      } // Don't allow probe to happen indefinitely\n\n\n    if (Date.now() - this.timeLastProbe > VideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS) {\n      this.logger.info(`bwe: Canceling probe due to timeout`);\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      return 0\n      /* kNewOptimal */\n      ;\n    }\n\n    if (this.downlinkStats.packetsLost > 0) {\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE * 3;\n      return 2\n      /* kPreProbe */\n      ;\n    }\n\n    const subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n\n    if (this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds) || targetDownlinkBitrate > subscribedRate) {\n      let avgRate = 0;\n\n      for (const chosenStream of chosenStreams) {\n        avgRate += chosenStream.avgBitrateKbps;\n      }\n\n      if (targetDownlinkBitrate > avgRate) {\n        // If target bitrate can sustain probe rate, then probe was successful.\n        this.setProbeState(\"Not Probing\"\n        /* kNotProbing */\n        ); // Reset the time allowed between probes since this was successful\n\n        this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n        return 0\n        /* kNewOptimal */\n        ;\n      }\n    }\n\n    return 1\n    /* kPreviousOptimal */\n    ;\n  }\n\n  maybeOverrideOrProbe(chosenStreams, pausedStreamIds, chosenTotalBitrate, targetDownlinkBitrate, deltaToNextUpgrade, upgradeStream) {\n    const sameSubscriptions = this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds);\n    let useLastSubscriptions = 0\n    /* kNewOptimal */\n    ;\n    const now = Date.now(); // We want to minimize thrashing between between low res and high res of different\n    // participants due to avg bitrate fluctuations. If there hasn't been much of a change in estimated bandwidth\n    // and the number of streams and their max rates are the same, then reuse the previous subscription\n\n    const triggerPercent = targetDownlinkBitrate > VideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS ? VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT : VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT * 2;\n    const minTargetBitrateDelta = targetDownlinkBitrate * triggerPercent / 100;\n\n    if (!sameSubscriptions && Math.abs(targetDownlinkBitrate - this.prevTargetRateKbps) < minTargetBitrateDelta) {\n      this.logger.info('bwe: MaybeOverrideOrProbe: Reuse last decision based on delta rate. {' + JSON.stringify(this.subscribedReceiveSet) + `}`);\n      useLastSubscriptions = 1\n      /* kPreviousOptimal */\n      ;\n    } // If there has been packet loss, then reset to no probing state\n\n\n    if (this.downlinkStats.packetsLost > this.prevDownlinkStats.packetsLost) {\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      this.lastUpgradeRateKbps = 0;\n      return useLastSubscriptions;\n    }\n\n    if (sameSubscriptions || useLastSubscriptions) {\n      // If planned subscriptions are same as last, then either move to probe pending state\n      // or move to probing state if enough time has passed.\n      switch (this.rateProbeState) {\n        case \"Not Probing\"\n        /* kNotProbing */\n        :\n          this.setProbeState(\"Probe Pending\"\n          /* kProbePending */\n          );\n          break;\n\n        case \"Probe Pending\"\n        /* kProbePending */\n        :\n          if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n            if (this.setProbeState(\"Probing\"\n            /* kProbing */\n            )) {\n              this.timeBeforeAllowSubscribeMs = 800;\n              this.upgradeToStream(chosenStreams, upgradeStream);\n              useLastSubscriptions = 0\n              /* kNewOptimal */\n              ;\n            }\n          }\n\n          break;\n\n        default:\n          this.logger.info('bwe: MaybeOverrideOrProbe: Unhandled condition ' + this.rateProbeState);\n          break;\n      }\n    } else {\n      // At this point the current expectation is to subscribe for a new set of\n      // streams, and environment is not right for probing.  If target rate is within\n      // the threshold of doing an upgrade, then do it and if we are lucky will be the\n      // same set of streams as last and no new subscription will be done.\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n\n      if (targetDownlinkBitrate + minTargetBitrateDelta > chosenTotalBitrate + deltaToNextUpgrade) {\n        this.logger.info('bwe: MaybeOverrideOrProbe: Upgrade since we are within threshold');\n        this.upgradeToStream(chosenStreams, upgradeStream);\n      }\n    }\n\n    return useLastSubscriptions;\n  } // Utility function to find max rate of streams in current decision\n\n\n  calculateSubscribeRate(streams, streamSet) {\n    let subscribeRate = 0;\n\n    for (const index of streamSet.array()) {\n      const streamMatch = streams.find(stream => stream.streamId === index);\n\n      if (streamMatch !== undefined) {\n        subscribeRate += streamMatch.maxBitrateKbps;\n      }\n    }\n\n    return subscribeRate;\n  }\n\n  handlePausedStreams(streamSelectionSet, pausedStreamIds, remoteInfos) {\n    const remoteTiles = this.tileController.getAllRemoteVideoTiles();\n\n    for (let i = 0; i < remoteTiles.length; i++) {\n      const tile = remoteTiles[i];\n      const state = tile.state();\n\n      if (state.paused) {\n        let j = remoteInfos.length;\n\n        while (j--) {\n          if (remoteInfos[j].attendeeId === state.boundAttendeeId) {\n            this.logger.info('bwe: removed paused attendee ' + state.boundAttendeeId + ' streamId: ' + remoteInfos[j].streamId);\n            pausedStreamIds.add(remoteInfos[j].streamId); // Add the stream to the selection set to keep the tile around\n\n            if (this.subscribedReceiveSet.contain(remoteInfos[j].streamId)) {\n              streamSelectionSet.add(remoteInfos[j].streamId);\n            }\n\n            remoteInfos.splice(j, 1);\n          }\n        }\n      }\n    }\n  }\n\n  chooseContent(chosenStreams, remoteInfos) {\n    let contentRate = 0;\n\n    for (const info of remoteInfos) {\n      // For now always subscribe to content even if higher bandwidth then target\n      if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality)) {\n        chosenStreams.push(info);\n        contentRate += info.avgBitrateKbps;\n      }\n    }\n\n    return contentRate;\n  }\n\n  availStreamsSameAsLast(remoteInfos) {\n    if (this.prevRemoteInfos === undefined || remoteInfos.length !== this.prevRemoteInfos.length) {\n      return false;\n    }\n\n    for (const info of remoteInfos) {\n      const infoMatch = this.prevRemoteInfos.find(prevInfo => prevInfo.groupId === info.groupId && prevInfo.streamId === info.streamId && prevInfo.maxBitrateKbps === info.maxBitrateKbps);\n\n      if (infoMatch === undefined) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  chosenStreamsSameAsLast(chosenStreams, pausedStreamIds) {\n    const lastStreams = this.optimalReceiveSet.array();\n\n    for (const id of lastStreams) {\n      if (!pausedStreamIds.contain(id) && chosenStreams.findIndex(chosenStream => chosenStream.streamId === id) === -1) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  policyStateLogStr(remoteInfos, targetDownlinkBitrate) {\n    const subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n    const optimalReceiveSet = {\n      targetBitrate: targetDownlinkBitrate,\n      subscribedRate: subscribedRate,\n      probeState: this.rateProbeState,\n      startupPeriod: this.startupPeriod\n    }; // Reduced remote info logging:\n\n    let remoteInfoStr = `remoteInfos: [`;\n\n    for (const info of remoteInfos) {\n      remoteInfoStr += `{grpId:${info.groupId} strId:${info.streamId} maxBr:${info.maxBitrateKbps} avgBr:${info.avgBitrateKbps}}, `;\n    }\n\n    remoteInfoStr += `]`;\n    const logString = `bwe: optimalReceiveSet ${JSON.stringify(optimalReceiveSet)}\\n` + `bwe:   prev ${JSON.stringify(this.prevDownlinkStats)}\\n` + `bwe:   now  ${JSON.stringify(this.downlinkStats)}\\n` + `bwe:   ${remoteInfoStr}`;\n    return logString;\n  }\n\n}\n\nexports.default = VideoAdaptiveProbePolicy;\nVideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS = 2800;\nVideoAdaptiveProbePolicy.STARTUP_PERIOD_MS = 6000;\nVideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT = 20;\nVideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT = 15;\nVideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS = 300;\nVideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE = 5000;\nVideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE = 2000;\nVideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE = 60000;\nVideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS = 60000;","map":{"version":3,"sources":["../../src/videodownlinkbandwidthpolicy/VideoAdaptiveProbePolicy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ClientMetricReportDirection_1 = require(\"../clientmetricreport/ClientMetricReportDirection\");\nconst ContentShareConstants_1 = require(\"../contentsharecontroller/ContentShareConstants\");\nconst DefaultVideoStreamIdSet_1 = require(\"../videostreamidset/DefaultVideoStreamIdSet\");\nclass LinkMediaStats {\n    constructor() {\n        this.bandwidthEstimateKbps = 0;\n        this.usedBandwidthKbps = 0;\n        this.packetsLost = 0;\n        this.nackCount = 0;\n        this.rttMs = 0;\n    }\n}\nclass VideoAdaptiveProbePolicy {\n    constructor(logger, tileController) {\n        this.logger = logger;\n        this.tileController = tileController;\n        this.reset();\n    }\n    reset() {\n        this.optimalReceiveSet = new DefaultVideoStreamIdSet_1.default();\n        this.subscribedReceiveSet = new DefaultVideoStreamIdSet_1.default();\n        this.logCount = 0;\n        this.startupPeriod = true;\n        this.usingPrevTargetRate = false;\n        this.rateProbeState = \"Not Probing\" /* kNotProbing */;\n        this.timeFirstEstimate = 0;\n        this.lastUpgradeRateKbps = 0;\n        this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n        this.timeLastProbe = Date.now();\n        this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n        this.downlinkStats = new LinkMediaStats();\n        this.prevDownlinkStats = new LinkMediaStats();\n    }\n    updateIndex(videoIndex) {\n        this.videoIndex = videoIndex;\n    }\n    updateMetrics(clientMetricReport) {\n        if (this.videoIndex.allStreams().empty()) {\n            return;\n        }\n        this.prevDownlinkStats = this.downlinkStats;\n        this.downlinkStats = new LinkMediaStats();\n        const metricReport = clientMetricReport.getObservableMetrics();\n        this.downlinkStats.bandwidthEstimateKbps = metricReport.availableReceiveBandwidth / 1000;\n        for (const ssrcStr in clientMetricReport.streamMetricReports) {\n            const ssrc = Number(ssrcStr);\n            if (clientMetricReport.streamMetricReports[ssrc].direction === ClientMetricReportDirection_1.default.DOWNSTREAM) {\n                // Only use video stream metrics\n                if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googNacksSent') &&\n                    clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n                    this.downlinkStats.nackCount += clientMetricReport.countPerSecond('googNacksSent', ssrc);\n                }\n                if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('packetsLost') &&\n                    clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n                    this.downlinkStats.packetsLost += clientMetricReport.countPerSecond('packetsLost', ssrc);\n                }\n                if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('bytesReceived')) {\n                    this.downlinkStats.usedBandwidthKbps +=\n                        clientMetricReport.bitsPerSecond('bytesReceived', ssrc) / 1000;\n                }\n            }\n        }\n    }\n    wantsResubscribe() {\n        this.optimalReceiveSet = this.calculateOptimalReceiveSet();\n        return !this.subscribedReceiveSet.equal(this.optimalReceiveSet);\n    }\n    chooseSubscriptions() {\n        if (!this.subscribedReceiveSet.equal(this.optimalReceiveSet)) {\n            this.timeLastSubscribe = Date.now();\n        }\n        this.subscribedReceiveSet = this.optimalReceiveSet.clone();\n        this.logger.info('bwe: chooseSubscriptions ' + JSON.stringify(this.subscribedReceiveSet));\n        return this.subscribedReceiveSet.clone();\n    }\n    calculateOptimalReceiveSet() {\n        const streamSelectionSet = new DefaultVideoStreamIdSet_1.default();\n        const lastProbeState = this.rateProbeState;\n        const remoteInfos = this.videoIndex.remoteStreamDescriptions();\n        if (remoteInfos.length === 0) {\n            return streamSelectionSet;\n        }\n        const pausedStreamIds = new DefaultVideoStreamIdSet_1.default();\n        this.handlePausedStreams(streamSelectionSet, pausedStreamIds, remoteInfos);\n        const sameStreamChoices = this.availStreamsSameAsLast(remoteInfos);\n        // If no major changes then don't allow subscribes for the allowed amount of time\n        if (!this.startupPeriod &&\n            sameStreamChoices &&\n            Date.now() - this.timeLastSubscribe < this.timeBeforeAllowSubscribeMs) {\n            return this.optimalReceiveSet;\n        }\n        // reset time before allow subscribe to default\n        this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n        const chosenStreams = [];\n        // Sort streams by bitrate asceending.\n        remoteInfos.sort((a, b) => {\n            if (a.maxBitrateKbps === b.maxBitrateKbps) {\n                return a.streamId - b.streamId;\n            }\n            return a.maxBitrateKbps - b.maxBitrateKbps;\n        });\n        // Convert 0 avg bitrates to max and handle special cases\n        for (const info of remoteInfos) {\n            if (info.avgBitrateKbps === 0 || info.avgBitrateKbps > info.maxBitrateKbps) {\n                // Content can be a special case\n                if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality) && info.maxBitrateKbps < 100) {\n                    info.maxBitrateKbps = info.avgBitrateKbps;\n                }\n                else {\n                    info.avgBitrateKbps = info.maxBitrateKbps;\n                }\n            }\n        }\n        const targetDownlinkBitrate = this.determineTargetRate(remoteInfos);\n        let deltaToNextUpgrade = 0;\n        let chosenTotalBitrate = 0;\n        let upgradeStream;\n        // If screen share is available, then subscribe to that first before anything else\n        chosenTotalBitrate += this.chooseContent(chosenStreams, remoteInfos);\n        // Try to have at least one stream from every group first\n        // Since the streams are sorted this will pick the lowest bitrates first\n        for (const info of remoteInfos) {\n            if (info.avgBitrateKbps === 0) {\n                continue;\n            }\n            if (chosenStreams.findIndex(stream => stream.groupId === info.groupId) === -1) {\n                if (chosenTotalBitrate + info.avgBitrateKbps <= targetDownlinkBitrate) {\n                    chosenStreams.push(info);\n                    chosenTotalBitrate += info.avgBitrateKbps;\n                }\n                else if (deltaToNextUpgrade === 0) {\n                    // Keep track of step to next upgrade\n                    deltaToNextUpgrade = info.avgBitrateKbps;\n                    upgradeStream = info;\n                }\n            }\n        }\n        // Look for upgrades until we run out of bandwidth\n        let lookForUpgrades = true;\n        while (lookForUpgrades) {\n            // We will set this to true if we find any new upgrades during the loop over the\n            // chosen streams (i.e. when we do a full loop without an upgrade we will give up)\n            lookForUpgrades = false;\n            chosenStreams.forEach((chosenStream, index) => {\n                for (const info of remoteInfos) {\n                    if (info.groupId === chosenStream.groupId &&\n                        info.streamId !== chosenStream.streamId &&\n                        info.avgBitrateKbps > chosenStream.avgBitrateKbps) {\n                        const increaseKbps = info.avgBitrateKbps - chosenStream.avgBitrateKbps;\n                        if (chosenTotalBitrate + increaseKbps <= targetDownlinkBitrate) {\n                            chosenTotalBitrate += increaseKbps;\n                            chosenStreams[index] = info;\n                            lookForUpgrades = true;\n                        }\n                        else if (deltaToNextUpgrade === 0) {\n                            // Keep track of step to next upgrade\n                            deltaToNextUpgrade = increaseKbps;\n                            upgradeStream = info;\n                        }\n                    }\n                }\n            });\n        }\n        let subscriptionChoice = 0 /* kNewOptimal */;\n        // Look for probing or override opportunities\n        if (!this.startupPeriod && sameStreamChoices && deltaToNextUpgrade !== 0) {\n            if (this.rateProbeState === \"Probing\" /* kProbing */) {\n                subscriptionChoice = this.handleProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos);\n            }\n            else {\n                subscriptionChoice = this.maybeOverrideOrProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, chosenTotalBitrate, deltaToNextUpgrade, upgradeStream);\n            }\n        }\n        else {\n            // If there was a change in streams to choose from, then cancel any probing or upgrades\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            this.lastUpgradeRateKbps = 0;\n        }\n        let decisionLogStr = this.policyStateLogStr(remoteInfos, targetDownlinkBitrate);\n        if (this.logCount % 15 === 0 || this.rateProbeState !== lastProbeState) {\n            this.logger.info(decisionLogStr);\n            this.logCount = 0;\n            decisionLogStr = '';\n        }\n        this.logCount++;\n        this.prevTargetRateKbps = targetDownlinkBitrate;\n        this.prevRemoteInfos = remoteInfos;\n        if (subscriptionChoice === 1 /* kPreviousOptimal */) {\n            this.logger.info('bwe: keepSameSubscriptions');\n            if (decisionLogStr.length > 0) {\n                this.logger.info(decisionLogStr);\n            }\n            return this.optimalReceiveSet;\n        }\n        else if (subscriptionChoice === 2 /* kPreProbe */) {\n            const subscribedRate = this.calculateSubscribeRate(remoteInfos, this.preProbeReceiveSet);\n            this.logger.info('bwe: Use Pre-Probe subscription subscribedRate:' + subscribedRate);\n            return this.preProbeReceiveSet;\n        }\n        for (const chosenStream of chosenStreams) {\n            streamSelectionSet.add(chosenStream.streamId);\n        }\n        if (!this.optimalReceiveSet.equal(streamSelectionSet)) {\n            if (decisionLogStr.length > 0) {\n                this.logger.info(decisionLogStr);\n            }\n            const subscribedRate = this.calculateSubscribeRate(remoteInfos, streamSelectionSet);\n            this.logger.info(`bwe: new streamSelection: ${JSON.stringify(streamSelectionSet)} subscribedRate:${subscribedRate}`);\n        }\n        return streamSelectionSet;\n    }\n    determineTargetRate(remoteInfos) {\n        let targetBitrate = 0;\n        // Estimated downlink bandwidth from WebRTC is dependent on actually receiving data, so if it ever got driven below the bitrate of the lowest\n        // stream (a simulcast stream), and it stops receiving, it will get stuck never being able to resubscribe (as is implemented).\n        let minTargetDownlinkBitrate = Number.MAX_VALUE;\n        for (const info of remoteInfos) {\n            if (info.avgBitrateKbps !== 0 && info.avgBitrateKbps < minTargetDownlinkBitrate) {\n                minTargetDownlinkBitrate = info.avgBitrateKbps;\n            }\n        }\n        const now = Date.now();\n        // Startup phase handling.  During this period the estimate can be 0 or\n        // could still be slowly hunting for a steady state.  This startup ramp up\n        // can cause a series of subscribes which can be distracting. During this\n        // time just use our configured default value\n        if (this.downlinkStats.bandwidthEstimateKbps !== 0) {\n            if (this.timeFirstEstimate === 0) {\n                this.timeFirstEstimate = now;\n            }\n            // handle startup state where estimator is still converging.\n            if (this.startupPeriod) {\n                // Drop out of startup period if\n                // - estimate is above default\n                // - get packet loss and have a valid estimate\n                // - startup period has expired and rate is not still increasing\n                if (this.downlinkStats.bandwidthEstimateKbps >\n                    VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS ||\n                    this.downlinkStats.packetsLost > 0 ||\n                    (now - this.timeFirstEstimate > VideoAdaptiveProbePolicy.STARTUP_PERIOD_MS &&\n                        this.downlinkStats.bandwidthEstimateKbps <=\n                            this.prevDownlinkStats.bandwidthEstimateKbps)) {\n                    this.startupPeriod = false;\n                    this.prevTargetRateKbps = this.downlinkStats.bandwidthEstimateKbps;\n                }\n            }\n            // If we are in the startup period and we haven't detected any packet loss, then\n            // keep it at the default to let the estimation get to a steady state\n            if (this.startupPeriod) {\n                targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n            }\n            else {\n                targetBitrate = this.downlinkStats.bandwidthEstimateKbps;\n            }\n        }\n        else {\n            if (this.timeFirstEstimate === 0) {\n                targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n            }\n            else {\n                targetBitrate = this.prevTargetRateKbps;\n            }\n        }\n        targetBitrate = Math.max(minTargetDownlinkBitrate, targetBitrate);\n        // Estimated downlink rate can follow actual bandwidth or fall for a short period of time\n        // due to the absolute send time estimator incorrectly thinking that a delay in packets is\n        // a precursor to packet loss.  We have seen too many false positives on this, so we\n        // will ignore largish drops in the estimate if there is no packet loss\n        if (!this.startupPeriod &&\n            ((this.usingPrevTargetRate &&\n                this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps) ||\n                this.downlinkStats.bandwidthEstimateKbps <\n                    (this.prevTargetRateKbps *\n                        (100 - VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT)) /\n                        100 ||\n                this.downlinkStats.bandwidthEstimateKbps <\n                    (this.downlinkStats.usedBandwidthKbps *\n                        VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT) /\n                        100) &&\n            this.downlinkStats.packetsLost === 0) {\n            // Set target to be the same as last\n            this.logger.debug(() => {\n                return 'bwe: ValidateRate: Using Previous rate ' + this.prevTargetRateKbps;\n            });\n            this.usingPrevTargetRate = true;\n            targetBitrate = this.prevTargetRateKbps;\n        }\n        else {\n            this.usingPrevTargetRate = false;\n        }\n        return targetBitrate;\n    }\n    setProbeState(newState) {\n        if (this.rateProbeState === newState)\n            return;\n        const now = Date.now();\n        switch (newState) {\n            case \"Not Probing\" /* kNotProbing */:\n                this.timeProbePendingStart = 0;\n                break;\n            case \"Probe Pending\" /* kProbePending */:\n                if (this.timeLastProbe === 0 ||\n                    now - this.timeLastProbe > VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE) {\n                    this.timeProbePendingStart = now;\n                }\n                else {\n                    // Too soon to do a probe again\n                    return false;\n                }\n                break;\n            case \"Probing\" /* kProbing */:\n                if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n                    this.timeLastProbe = now;\n                    this.preProbeReceiveSet = this.subscribedReceiveSet;\n                    // Increase the time allowed until the next probe\n                    this.timeBeforeAllowProbeMs = Math.min(this.timeBeforeAllowProbeMs * 2, VideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE);\n                }\n                else {\n                    // Too soon to do probe\n                    return false;\n                }\n                break;\n            default:\n                break;\n        }\n        this.logger.info('bwe: setProbeState to ' + newState + ' from ' + this.rateProbeState);\n        this.rateProbeState = newState;\n        return true;\n    }\n    // Upgrade the stream id from the appropriate group or add it if it wasn't already in the list.\n    // Return the added amount of bandwidth\n    upgradeToStream(chosenStreams, upgradeStream) {\n        for (let i = 0; i < chosenStreams.length; i++) {\n            if (chosenStreams[i].groupId === upgradeStream.groupId) {\n                const diffRate = upgradeStream.avgBitrateKbps - chosenStreams[i].avgBitrateKbps;\n                this.logger.info('bwe: upgradeStream from ' +\n                    JSON.stringify(chosenStreams[i]) +\n                    ' to ' +\n                    JSON.stringify(upgradeStream));\n                this.lastUpgradeRateKbps = diffRate;\n                chosenStreams[i] = upgradeStream;\n                return diffRate;\n            }\n        }\n        // We are adding a stream and not upgrading.\n        chosenStreams.push(upgradeStream);\n        this.lastUpgradeRateKbps = upgradeStream.avgBitrateKbps;\n        return this.lastUpgradeRateKbps;\n    }\n    // Do specific behavior while we are currently in probing state and metrics\n    // indicate environment is still valid to do probing.\n    // Return true if the caller should not change from the previous subscriptions.\n    handleProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos) {\n        if (this.rateProbeState !== \"Probing\" /* kProbing */) {\n            return 0 /* kNewOptimal */;\n        }\n        // Don't allow probe to happen indefinitely\n        if (Date.now() - this.timeLastProbe > VideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS) {\n            this.logger.info(`bwe: Canceling probe due to timeout`);\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            return 0 /* kNewOptimal */;\n        }\n        if (this.downlinkStats.packetsLost > 0) {\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE * 3;\n            return 2 /* kPreProbe */;\n        }\n        const subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n        if (this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds) ||\n            targetDownlinkBitrate > subscribedRate) {\n            let avgRate = 0;\n            for (const chosenStream of chosenStreams) {\n                avgRate += chosenStream.avgBitrateKbps;\n            }\n            if (targetDownlinkBitrate > avgRate) {\n                // If target bitrate can sustain probe rate, then probe was successful.\n                this.setProbeState(\"Not Probing\" /* kNotProbing */);\n                // Reset the time allowed between probes since this was successful\n                this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n                return 0 /* kNewOptimal */;\n            }\n        }\n        return 1 /* kPreviousOptimal */;\n    }\n    maybeOverrideOrProbe(chosenStreams, pausedStreamIds, chosenTotalBitrate, targetDownlinkBitrate, deltaToNextUpgrade, upgradeStream) {\n        const sameSubscriptions = this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds);\n        let useLastSubscriptions = 0 /* kNewOptimal */;\n        const now = Date.now();\n        // We want to minimize thrashing between between low res and high res of different\n        // participants due to avg bitrate fluctuations. If there hasn't been much of a change in estimated bandwidth\n        // and the number of streams and their max rates are the same, then reuse the previous subscription\n        const triggerPercent = targetDownlinkBitrate > VideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS\n            ? VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT\n            : VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT * 2;\n        const minTargetBitrateDelta = (targetDownlinkBitrate * triggerPercent) / 100;\n        if (!sameSubscriptions &&\n            Math.abs(targetDownlinkBitrate - this.prevTargetRateKbps) < minTargetBitrateDelta) {\n            this.logger.info('bwe: MaybeOverrideOrProbe: Reuse last decision based on delta rate. {' +\n                JSON.stringify(this.subscribedReceiveSet) +\n                `}`);\n            useLastSubscriptions = 1 /* kPreviousOptimal */;\n        }\n        // If there has been packet loss, then reset to no probing state\n        if (this.downlinkStats.packetsLost > this.prevDownlinkStats.packetsLost) {\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            this.lastUpgradeRateKbps = 0;\n            return useLastSubscriptions;\n        }\n        if (sameSubscriptions || useLastSubscriptions) {\n            // If planned subscriptions are same as last, then either move to probe pending state\n            // or move to probing state if enough time has passed.\n            switch (this.rateProbeState) {\n                case \"Not Probing\" /* kNotProbing */:\n                    this.setProbeState(\"Probe Pending\" /* kProbePending */);\n                    break;\n                case \"Probe Pending\" /* kProbePending */:\n                    if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n                        if (this.setProbeState(\"Probing\" /* kProbing */)) {\n                            this.timeBeforeAllowSubscribeMs = 800;\n                            this.upgradeToStream(chosenStreams, upgradeStream);\n                            useLastSubscriptions = 0 /* kNewOptimal */;\n                        }\n                    }\n                    break;\n                default:\n                    this.logger.info('bwe: MaybeOverrideOrProbe: Unhandled condition ' + this.rateProbeState);\n                    break;\n            }\n        }\n        else {\n            // At this point the current expectation is to subscribe for a new set of\n            // streams, and environment is not right for probing.  If target rate is within\n            // the threshold of doing an upgrade, then do it and if we are lucky will be the\n            // same set of streams as last and no new subscription will be done.\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            if (targetDownlinkBitrate + minTargetBitrateDelta > chosenTotalBitrate + deltaToNextUpgrade) {\n                this.logger.info('bwe: MaybeOverrideOrProbe: Upgrade since we are within threshold');\n                this.upgradeToStream(chosenStreams, upgradeStream);\n            }\n        }\n        return useLastSubscriptions;\n    }\n    // Utility function to find max rate of streams in current decision\n    calculateSubscribeRate(streams, streamSet) {\n        let subscribeRate = 0;\n        for (const index of streamSet.array()) {\n            const streamMatch = streams.find(stream => stream.streamId === index);\n            if (streamMatch !== undefined) {\n                subscribeRate += streamMatch.maxBitrateKbps;\n            }\n        }\n        return subscribeRate;\n    }\n    handlePausedStreams(streamSelectionSet, pausedStreamIds, remoteInfos) {\n        const remoteTiles = this.tileController.getAllRemoteVideoTiles();\n        for (let i = 0; i < remoteTiles.length; i++) {\n            const tile = remoteTiles[i];\n            const state = tile.state();\n            if (state.paused) {\n                let j = remoteInfos.length;\n                while (j--) {\n                    if (remoteInfos[j].attendeeId === state.boundAttendeeId) {\n                        this.logger.info('bwe: removed paused attendee ' +\n                            state.boundAttendeeId +\n                            ' streamId: ' +\n                            remoteInfos[j].streamId);\n                        pausedStreamIds.add(remoteInfos[j].streamId);\n                        // Add the stream to the selection set to keep the tile around\n                        if (this.subscribedReceiveSet.contain(remoteInfos[j].streamId)) {\n                            streamSelectionSet.add(remoteInfos[j].streamId);\n                        }\n                        remoteInfos.splice(j, 1);\n                    }\n                }\n            }\n        }\n    }\n    chooseContent(chosenStreams, remoteInfos) {\n        let contentRate = 0;\n        for (const info of remoteInfos) {\n            // For now always subscribe to content even if higher bandwidth then target\n            if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality)) {\n                chosenStreams.push(info);\n                contentRate += info.avgBitrateKbps;\n            }\n        }\n        return contentRate;\n    }\n    availStreamsSameAsLast(remoteInfos) {\n        if (this.prevRemoteInfos === undefined || remoteInfos.length !== this.prevRemoteInfos.length) {\n            return false;\n        }\n        for (const info of remoteInfos) {\n            const infoMatch = this.prevRemoteInfos.find(prevInfo => prevInfo.groupId === info.groupId &&\n                prevInfo.streamId === info.streamId &&\n                prevInfo.maxBitrateKbps === info.maxBitrateKbps);\n            if (infoMatch === undefined) {\n                return false;\n            }\n        }\n        return true;\n    }\n    chosenStreamsSameAsLast(chosenStreams, pausedStreamIds) {\n        const lastStreams = this.optimalReceiveSet.array();\n        for (const id of lastStreams) {\n            if (!pausedStreamIds.contain(id) &&\n                chosenStreams.findIndex(chosenStream => chosenStream.streamId === id) === -1) {\n                return false;\n            }\n        }\n        return true;\n    }\n    policyStateLogStr(remoteInfos, targetDownlinkBitrate) {\n        const subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n        const optimalReceiveSet = {\n            targetBitrate: targetDownlinkBitrate,\n            subscribedRate: subscribedRate,\n            probeState: this.rateProbeState,\n            startupPeriod: this.startupPeriod,\n        };\n        // Reduced remote info logging:\n        let remoteInfoStr = `remoteInfos: [`;\n        for (const info of remoteInfos) {\n            remoteInfoStr += `{grpId:${info.groupId} strId:${info.streamId} maxBr:${info.maxBitrateKbps} avgBr:${info.avgBitrateKbps}}, `;\n        }\n        remoteInfoStr += `]`;\n        const logString = `bwe: optimalReceiveSet ${JSON.stringify(optimalReceiveSet)}\\n` +\n            `bwe:   prev ${JSON.stringify(this.prevDownlinkStats)}\\n` +\n            `bwe:   now  ${JSON.stringify(this.downlinkStats)}\\n` +\n            `bwe:   ${remoteInfoStr}`;\n        return logString;\n    }\n}\nexports.default = VideoAdaptiveProbePolicy;\nVideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS = 2800;\nVideoAdaptiveProbePolicy.STARTUP_PERIOD_MS = 6000;\nVideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT = 20;\nVideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT = 15;\nVideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS = 300;\nVideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE = 5000;\nVideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE = 2000;\nVideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE = 60000;\nVideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS = 60000;\n//# sourceMappingURL=VideoAdaptiveProbePolicy.js.map"]},"metadata":{},"sourceType":"script"}