{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[CreatePeerConnectionTask]] sets up the peer connection object.\n */\n\n\nclass CreatePeerConnectionTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'CreatePeerConnectionTask';\n    this.removeTrackAddedEventListener = null;\n    this.removeTrackRemovedEventListeners = {};\n    this.trackEvents = ['ended', 'mute', 'unmute', 'isolationchange', 'overconstrained'];\n    this.removeVideoTrackEventListeners = {};\n\n    this.trackAddedHandler = event => {\n      const track = event.track;\n      this.context.logger.info(`received track event: kind=${track.kind} id=${track.id} label=${track.label}`);\n\n      if (event.transceiver && event.transceiver.currentDirection === 'inactive') {\n        return;\n      }\n\n      if (event.streams.length === 0) {\n        this.context.logger.warn(`Track event but no stream`);\n        return;\n      }\n\n      const stream = event.streams[0];\n\n      if (track.kind === 'audio') {\n        this.context.audioMixController.bindAudioStream(stream);\n      } else if (track.kind === 'video' && !this.trackIsVideoInput(track)) {\n        this.addRemoteVideoTrack(track, stream);\n      }\n    };\n  }\n\n  removeObserver() {\n    this.removeTrackAddedEventListener && this.removeTrackAddedEventListener();\n\n    for (const trackId in this.removeTrackRemovedEventListeners) {\n      this.removeTrackRemovedEventListeners[trackId]();\n    }\n  }\n\n  addPeerConnectionEventLogger() {\n    const peer = this.context.peer;\n    peer.addEventListener('connectionstatechange', () => {\n      this.context.logger.info(`peer connection state changed: ${peer.connectionState}`);\n    });\n    peer.addEventListener('negotiationneeded', () => {\n      this.context.logger.info('peer connection negotiation is needed');\n    });\n    peer.addEventListener('icegatheringstatechange', () => {\n      this.context.logger.info(`peer connection ice gathering state changed: ${peer.iceGatheringState}`);\n    });\n    peer.addEventListener('icecandidate', event => {\n      this.context.logger.info(`peer connection ice candidate: ${event.candidate ? event.candidate.candidate : '(null)'}`);\n    });\n    peer.addEventListener('iceconnectionstatechange', () => {\n      this.context.logger.info(`peer connection ice connection state changed: ${peer.iceConnectionState}`);\n    });\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.context.removableObservers.push(this);\n      const hasTurnCredentials = this.context.turnCredentials && this.context.turnCredentials.uris.length > 0;\n      const configuration = hasTurnCredentials ? {\n        iceServers: [{\n          urls: this.context.turnCredentials.uris,\n          username: this.context.turnCredentials.username,\n          credential: this.context.turnCredentials.password,\n          credentialType: 'password'\n        }],\n        iceTransportPolicy: 'relay'\n      } : {};\n      configuration.bundlePolicy = this.context.browserBehavior.requiresBundlePolicy(); // @ts-ignore\n\n      configuration.sdpSemantics = this.context.browserBehavior.requiresUnifiedPlan() ? 'unified-plan' : 'plan-b'; // @ts-ignore\n\n      this.logger.info(`SDP semantics are ${configuration.sdpSemantics}`);\n      const connectionConstraints = {\n        optional: [{\n          googHighStartBitrate: 0\n        }, {\n          googCpuOveruseDetection: false\n        }, {\n          googCpuOveruseEncodeUsage: false\n        }, {\n          googCpuUnderuseThreshold: 55\n        }, {\n          googCpuOveruseThreshold: 150\n        }, {\n          googCombinedAudioVideoBwe: true\n        }]\n      };\n\n      if (this.context.peer) {\n        this.context.logger.info('reusing peer connection');\n      } else {\n        this.context.logger.info('creating new peer connection'); // @ts-ignore\n\n        this.context.peer = new RTCPeerConnection(configuration, connectionConstraints);\n        this.addPeerConnectionEventLogger();\n      }\n\n      this.removeTrackAddedEventListener = () => {\n        if (this.context.peer) {\n          this.context.peer.removeEventListener('track', this.trackAddedHandler);\n        }\n\n        this.removeTrackAddedEventListener = null;\n      };\n\n      this.context.peer.addEventListener('track', this.trackAddedHandler);\n    });\n  }\n\n  trackIsVideoInput(track) {\n    if (this.context.transceiverController.useTransceivers()) {\n      this.logger.debug(() => {\n        return `getting video track type (unified-plan)`;\n      });\n      return this.context.transceiverController.trackIsVideoInput(track);\n    }\n\n    this.logger.debug(() => {\n      return `getting video track type (plan-b)`;\n    });\n\n    if (this.context.activeVideoInput) {\n      const tracks = this.context.activeVideoInput.getVideoTracks();\n\n      if (tracks && tracks.length > 0 && tracks[0].id === track.id) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  addRemoteVideoTrack(track, stream) {\n    let trackId = stream.id;\n\n    if (!this.context.browserBehavior.requiresUnifiedPlan()) {\n      stream = new MediaStream([track]);\n      trackId = track.id;\n    }\n\n    const attendeeId = this.context.videoStreamIndex.attendeeIdForTrack(trackId);\n\n    if (this.context.videoTileController.haveVideoTileForAttendeeId(attendeeId)) {\n      this.context.logger.info(`Not adding remote track. Already have tile for attendeeId:  ${attendeeId}`);\n      return;\n    }\n\n    const tile = this.context.videoTileController.addVideoTile();\n    let streamId = this.context.videoStreamIndex.streamIdForTrack(trackId);\n\n    if (typeof streamId === 'undefined') {\n      this.logger.warn(`stream not found for tile=${tile.id()} track=${trackId}`);\n      streamId = null;\n    }\n\n    for (let i = 0; i < this.trackEvents.length; i++) {\n      const trackEvent = this.trackEvents[i];\n      const videoTracks = stream.getVideoTracks();\n\n      if (videoTracks && videoTracks.length) {\n        const videoTrack = videoTracks[0];\n\n        const callback = () => {\n          this.context.logger.info(`received the ${trackEvent} event for tile=${tile.id()} id=${track.id} streamId=${streamId}`);\n\n          if (trackEvent === 'ended' && this.context.browserBehavior.requiresUnifiedPlan()) {\n            this.removeRemoteVideoTrack(track, tile.state());\n          }\n        };\n\n        videoTrack.addEventListener(trackEvent, callback);\n\n        if (!this.removeVideoTrackEventListeners[track.id]) {\n          this.removeVideoTrackEventListeners[track.id] = [];\n        }\n\n        this.removeVideoTrackEventListeners[track.id].push(() => {\n          videoTrack.removeEventListener(trackEvent, callback);\n        });\n      }\n    }\n\n    let width;\n    let height;\n\n    if (track.getSettings) {\n      const cap = track.getSettings();\n      width = cap.width;\n      height = cap.height;\n    } else {\n      const cap = track.getCapabilities();\n      width = cap.width;\n      height = cap.height;\n    }\n\n    const externalUserId = this.context.videoStreamIndex.externalUserIdForTrack(trackId);\n    tile.bindVideoStream(attendeeId, false, stream, width, height, streamId, externalUserId);\n    this.logger.info(`video track added, created tile=${tile.id()} track=${trackId} streamId=${streamId}`);\n    let endEvent = 'removetrack';\n    let target = stream;\n\n    if (!this.context.browserBehavior.requiresUnifiedPlan()) {\n      this.logger.debug(() => {\n        return 'updating end event and target track (plan-b)';\n      });\n      endEvent = 'ended'; // @ts-ignore\n\n      target = track;\n    }\n\n    const trackRemovedHandler = () => this.removeRemoteVideoTrack(track, tile.state());\n\n    this.removeTrackRemovedEventListeners[track.id] = () => {\n      target.removeEventListener(endEvent, trackRemovedHandler);\n      delete this.removeTrackRemovedEventListeners[track.id];\n    };\n\n    target.addEventListener(endEvent, trackRemovedHandler);\n  }\n\n  removeRemoteVideoTrack(track, tileState) {\n    if (this.removeTrackRemovedEventListeners.hasOwnProperty(track.id)) {\n      this.removeTrackRemovedEventListeners[track.id]();\n\n      for (const removeVideoTrackEventListener of this.removeVideoTrackEventListeners[track.id]) {\n        removeVideoTrackEventListener();\n      }\n\n      delete this.removeVideoTrackEventListeners[track.id];\n    }\n\n    this.logger.info(`video track ended, removing tile=${tileState.tileId} id=${track.id} stream=${tileState.streamId}`);\n\n    if (tileState.streamId) {\n      this.context.videosPaused.remove(tileState.streamId);\n    } else {\n      this.logger.warn(`no stream found for tile=${tileState.tileId}`);\n    }\n\n    this.context.videoTileController.removeVideoTile(tileState.tileId);\n  }\n\n}\n\nexports.default = CreatePeerConnectionTask;\nCreatePeerConnectionTask.REMOVE_HANDLER_INTERVAL_MS = 10000;","map":{"version":3,"sources":["../../src/task/CreatePeerConnectionTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BaseTask_1 = require(\"./BaseTask\");\n/*\n * [[CreatePeerConnectionTask]] sets up the peer connection object.\n */\nclass CreatePeerConnectionTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'CreatePeerConnectionTask';\n        this.removeTrackAddedEventListener = null;\n        this.removeTrackRemovedEventListeners = {};\n        this.trackEvents = [\n            'ended',\n            'mute',\n            'unmute',\n            'isolationchange',\n            'overconstrained',\n        ];\n        this.removeVideoTrackEventListeners = {};\n        this.trackAddedHandler = (event) => {\n            const track = event.track;\n            this.context.logger.info(`received track event: kind=${track.kind} id=${track.id} label=${track.label}`);\n            if (event.transceiver && event.transceiver.currentDirection === 'inactive') {\n                return;\n            }\n            if (event.streams.length === 0) {\n                this.context.logger.warn(`Track event but no stream`);\n                return;\n            }\n            const stream = event.streams[0];\n            if (track.kind === 'audio') {\n                this.context.audioMixController.bindAudioStream(stream);\n            }\n            else if (track.kind === 'video' && !this.trackIsVideoInput(track)) {\n                this.addRemoteVideoTrack(track, stream);\n            }\n        };\n    }\n    removeObserver() {\n        this.removeTrackAddedEventListener && this.removeTrackAddedEventListener();\n        for (const trackId in this.removeTrackRemovedEventListeners) {\n            this.removeTrackRemovedEventListeners[trackId]();\n        }\n    }\n    addPeerConnectionEventLogger() {\n        const peer = this.context.peer;\n        peer.addEventListener('connectionstatechange', () => {\n            this.context.logger.info(`peer connection state changed: ${peer.connectionState}`);\n        });\n        peer.addEventListener('negotiationneeded', () => {\n            this.context.logger.info('peer connection negotiation is needed');\n        });\n        peer.addEventListener('icegatheringstatechange', () => {\n            this.context.logger.info(`peer connection ice gathering state changed: ${peer.iceGatheringState}`);\n        });\n        peer.addEventListener('icecandidate', (event) => {\n            this.context.logger.info(`peer connection ice candidate: ${event.candidate ? event.candidate.candidate : '(null)'}`);\n        });\n        peer.addEventListener('iceconnectionstatechange', () => {\n            this.context.logger.info(`peer connection ice connection state changed: ${peer.iceConnectionState}`);\n        });\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.context.removableObservers.push(this);\n            const hasTurnCredentials = this.context.turnCredentials && this.context.turnCredentials.uris.length > 0;\n            const configuration = hasTurnCredentials\n                ? {\n                    iceServers: [\n                        {\n                            urls: this.context.turnCredentials.uris,\n                            username: this.context.turnCredentials.username,\n                            credential: this.context.turnCredentials.password,\n                            credentialType: 'password',\n                        },\n                    ],\n                    iceTransportPolicy: 'relay',\n                }\n                : {};\n            configuration.bundlePolicy = this.context.browserBehavior.requiresBundlePolicy();\n            // @ts-ignore\n            configuration.sdpSemantics = this.context.browserBehavior.requiresUnifiedPlan()\n                ? 'unified-plan'\n                : 'plan-b';\n            // @ts-ignore\n            this.logger.info(`SDP semantics are ${configuration.sdpSemantics}`);\n            const connectionConstraints = {\n                optional: [\n                    { googHighStartBitrate: 0 },\n                    { googCpuOveruseDetection: false },\n                    { googCpuOveruseEncodeUsage: false },\n                    { googCpuUnderuseThreshold: 55 },\n                    { googCpuOveruseThreshold: 150 },\n                    { googCombinedAudioVideoBwe: true },\n                ],\n            };\n            if (this.context.peer) {\n                this.context.logger.info('reusing peer connection');\n            }\n            else {\n                this.context.logger.info('creating new peer connection');\n                // @ts-ignore\n                this.context.peer = new RTCPeerConnection(configuration, connectionConstraints);\n                this.addPeerConnectionEventLogger();\n            }\n            this.removeTrackAddedEventListener = () => {\n                if (this.context.peer) {\n                    this.context.peer.removeEventListener('track', this.trackAddedHandler);\n                }\n                this.removeTrackAddedEventListener = null;\n            };\n            this.context.peer.addEventListener('track', this.trackAddedHandler);\n        });\n    }\n    trackIsVideoInput(track) {\n        if (this.context.transceiverController.useTransceivers()) {\n            this.logger.debug(() => {\n                return `getting video track type (unified-plan)`;\n            });\n            return this.context.transceiverController.trackIsVideoInput(track);\n        }\n        this.logger.debug(() => {\n            return `getting video track type (plan-b)`;\n        });\n        if (this.context.activeVideoInput) {\n            const tracks = this.context.activeVideoInput.getVideoTracks();\n            if (tracks && tracks.length > 0 && tracks[0].id === track.id) {\n                return true;\n            }\n        }\n        return false;\n    }\n    addRemoteVideoTrack(track, stream) {\n        let trackId = stream.id;\n        if (!this.context.browserBehavior.requiresUnifiedPlan()) {\n            stream = new MediaStream([track]);\n            trackId = track.id;\n        }\n        const attendeeId = this.context.videoStreamIndex.attendeeIdForTrack(trackId);\n        if (this.context.videoTileController.haveVideoTileForAttendeeId(attendeeId)) {\n            this.context.logger.info(`Not adding remote track. Already have tile for attendeeId:  ${attendeeId}`);\n            return;\n        }\n        const tile = this.context.videoTileController.addVideoTile();\n        let streamId = this.context.videoStreamIndex.streamIdForTrack(trackId);\n        if (typeof streamId === 'undefined') {\n            this.logger.warn(`stream not found for tile=${tile.id()} track=${trackId}`);\n            streamId = null;\n        }\n        for (let i = 0; i < this.trackEvents.length; i++) {\n            const trackEvent = this.trackEvents[i];\n            const videoTracks = stream.getVideoTracks();\n            if (videoTracks && videoTracks.length) {\n                const videoTrack = videoTracks[0];\n                const callback = () => {\n                    this.context.logger.info(`received the ${trackEvent} event for tile=${tile.id()} id=${track.id} streamId=${streamId}`);\n                    if (trackEvent === 'ended' && this.context.browserBehavior.requiresUnifiedPlan()) {\n                        this.removeRemoteVideoTrack(track, tile.state());\n                    }\n                };\n                videoTrack.addEventListener(trackEvent, callback);\n                if (!this.removeVideoTrackEventListeners[track.id]) {\n                    this.removeVideoTrackEventListeners[track.id] = [];\n                }\n                this.removeVideoTrackEventListeners[track.id].push(() => {\n                    videoTrack.removeEventListener(trackEvent, callback);\n                });\n            }\n        }\n        let width;\n        let height;\n        if (track.getSettings) {\n            const cap = track.getSettings();\n            width = cap.width;\n            height = cap.height;\n        }\n        else {\n            const cap = track.getCapabilities();\n            width = cap.width;\n            height = cap.height;\n        }\n        const externalUserId = this.context.videoStreamIndex.externalUserIdForTrack(trackId);\n        tile.bindVideoStream(attendeeId, false, stream, width, height, streamId, externalUserId);\n        this.logger.info(`video track added, created tile=${tile.id()} track=${trackId} streamId=${streamId}`);\n        let endEvent = 'removetrack';\n        let target = stream;\n        if (!this.context.browserBehavior.requiresUnifiedPlan()) {\n            this.logger.debug(() => {\n                return 'updating end event and target track (plan-b)';\n            });\n            endEvent = 'ended';\n            // @ts-ignore\n            target = track;\n        }\n        const trackRemovedHandler = () => this.removeRemoteVideoTrack(track, tile.state());\n        this.removeTrackRemovedEventListeners[track.id] = () => {\n            target.removeEventListener(endEvent, trackRemovedHandler);\n            delete this.removeTrackRemovedEventListeners[track.id];\n        };\n        target.addEventListener(endEvent, trackRemovedHandler);\n    }\n    removeRemoteVideoTrack(track, tileState) {\n        if (this.removeTrackRemovedEventListeners.hasOwnProperty(track.id)) {\n            this.removeTrackRemovedEventListeners[track.id]();\n            for (const removeVideoTrackEventListener of this.removeVideoTrackEventListeners[track.id]) {\n                removeVideoTrackEventListener();\n            }\n            delete this.removeVideoTrackEventListeners[track.id];\n        }\n        this.logger.info(`video track ended, removing tile=${tileState.tileId} id=${track.id} stream=${tileState.streamId}`);\n        if (tileState.streamId) {\n            this.context.videosPaused.remove(tileState.streamId);\n        }\n        else {\n            this.logger.warn(`no stream found for tile=${tileState.tileId}`);\n        }\n        this.context.videoTileController.removeVideoTile(tileState.tileId);\n    }\n}\nexports.default = CreatePeerConnectionTask;\nCreatePeerConnectionTask.REMOVE_HANDLER_INTERVAL_MS = 10000;\n//# sourceMappingURL=CreatePeerConnectionTask.js.map"]},"metadata":{},"sourceType":"script"}