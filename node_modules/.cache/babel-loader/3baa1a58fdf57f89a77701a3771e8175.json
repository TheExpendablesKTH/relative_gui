{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\n\nconst BaseTask_1 = require(\"./BaseTask\");\n\nclass CleanStoppedSessionTask extends BaseTask_1.default {\n  constructor(context) {\n    super(context.logger);\n    this.context = context;\n    this.taskName = 'CleanStoppedSessionTask';\n    this.taskCanceler = null;\n  }\n\n  cancel() {\n    if (this.taskCanceler) {\n      this.taskCanceler.cancel();\n      this.taskCanceler = null;\n    }\n  }\n\n  run() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.context.signalingClient.ready()) {\n          this.context.signalingClient.closeConnection();\n          yield this.receiveWebSocketClosedEvent();\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        for (const observer of this.context.removableObservers) {\n          observer.removeObserver();\n        }\n\n        this.context.statsCollector.stop();\n        this.context.statsCollector = null;\n        this.context.connectionMonitor.stop();\n        this.context.connectionMonitor = null;\n\n        if (this.context.peer) {\n          this.context.peer.close();\n        }\n\n        this.context.peer = null;\n        this.context.localVideoSender = null;\n        this.context.sdpAnswer = null;\n        this.context.sdpOfferInit = null;\n        this.context.indexFrame = null;\n        this.context.videoDownlinkBandwidthPolicy.reset();\n        this.context.iceCandidateHandler = null;\n        this.context.iceCandidates = [];\n        this.context.turnCredentials = null;\n        this.context.videoSubscriptions = null;\n        this.context.transceiverController.reset(); // This should really be a _device deselection_ operation,\n        // allowing the device controller to clean up any selected transform\n        // device or other resources.\n        //\n        // We can't fix it within the current API because CSST only knows about\n        // `MediaStreamBroker`, not about `DeviceController` — it only knows how\n        // to // release media streams that are tracked in the\n        // `AudioVideoControllerState`, not how to unselect a device.\n        //\n        // The issue here is that we now work with much more than streams, and\n        // this API hasn't kept pace with the complexity of the rest of the SDK.\n        //\n        // It's currently up to the developer's application to manage which device\n        // is currently selected and `DDC` has to figure out from the stream\n        // passed here which device to clean up.\n        //\n        // This can be addressed in a future v3.0.\n\n        this.context.mediaStreamBroker.releaseMediaStream(this.context.activeAudioInput);\n        this.context.activeAudioInput = null;\n        this.context.mediaStreamBroker.releaseMediaStream(this.context.activeVideoInput);\n        this.context.activeVideoInput = null;\n        this.context.realtimeController.realtimeSetLocalAudioInput(null);\n        const tile = this.context.videoTileController.getLocalVideoTile();\n\n        if (tile) {\n          tile.bindVideoStream('', true, null, null, null, null);\n        }\n\n        this.context.videoTileController.removeAllVideoTiles();\n      }\n    });\n  }\n\n  receiveWebSocketClosedEvent() {\n    return new Promise((resolve, reject) => {\n      class Interceptor {\n        constructor(signalingClient) {\n          this.signalingClient = signalingClient;\n        }\n\n        cancel() {\n          this.signalingClient.removeObserver(this);\n          reject(new Error(`CleanStoppedSessionTask got canceled while waiting for the WebSocket closed event`));\n        }\n\n        handleSignalingClientEvent(event) {\n          if (event.type === SignalingClientEventType_1.default.WebSocketClosed) {\n            this.signalingClient.removeObserver(this);\n            resolve();\n          }\n        }\n\n      }\n\n      const interceptor = new Interceptor(this.context.signalingClient);\n      this.taskCanceler = interceptor;\n      this.context.signalingClient.registerObserver(interceptor);\n    });\n  }\n\n}\n\nexports.default = CleanStoppedSessionTask;","map":{"version":3,"sources":["../../src/task/CleanStoppedSessionTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SignalingClientEventType_1 = require(\"../signalingclient/SignalingClientEventType\");\nconst BaseTask_1 = require(\"./BaseTask\");\nclass CleanStoppedSessionTask extends BaseTask_1.default {\n    constructor(context) {\n        super(context.logger);\n        this.context = context;\n        this.taskName = 'CleanStoppedSessionTask';\n        this.taskCanceler = null;\n    }\n    cancel() {\n        if (this.taskCanceler) {\n            this.taskCanceler.cancel();\n            this.taskCanceler = null;\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.context.signalingClient.ready()) {\n                    this.context.signalingClient.closeConnection();\n                    yield this.receiveWebSocketClosedEvent();\n                }\n            }\n            catch (error) {\n                throw error;\n            }\n            finally {\n                for (const observer of this.context.removableObservers) {\n                    observer.removeObserver();\n                }\n                this.context.statsCollector.stop();\n                this.context.statsCollector = null;\n                this.context.connectionMonitor.stop();\n                this.context.connectionMonitor = null;\n                if (this.context.peer) {\n                    this.context.peer.close();\n                }\n                this.context.peer = null;\n                this.context.localVideoSender = null;\n                this.context.sdpAnswer = null;\n                this.context.sdpOfferInit = null;\n                this.context.indexFrame = null;\n                this.context.videoDownlinkBandwidthPolicy.reset();\n                this.context.iceCandidateHandler = null;\n                this.context.iceCandidates = [];\n                this.context.turnCredentials = null;\n                this.context.videoSubscriptions = null;\n                this.context.transceiverController.reset();\n                // This should really be a _device deselection_ operation,\n                // allowing the device controller to clean up any selected transform\n                // device or other resources.\n                //\n                // We can't fix it within the current API because CSST only knows about\n                // `MediaStreamBroker`, not about `DeviceController` — it only knows how\n                // to // release media streams that are tracked in the\n                // `AudioVideoControllerState`, not how to unselect a device.\n                //\n                // The issue here is that we now work with much more than streams, and\n                // this API hasn't kept pace with the complexity of the rest of the SDK.\n                //\n                // It's currently up to the developer's application to manage which device\n                // is currently selected and `DDC` has to figure out from the stream\n                // passed here which device to clean up.\n                //\n                // This can be addressed in a future v3.0.\n                this.context.mediaStreamBroker.releaseMediaStream(this.context.activeAudioInput);\n                this.context.activeAudioInput = null;\n                this.context.mediaStreamBroker.releaseMediaStream(this.context.activeVideoInput);\n                this.context.activeVideoInput = null;\n                this.context.realtimeController.realtimeSetLocalAudioInput(null);\n                const tile = this.context.videoTileController.getLocalVideoTile();\n                if (tile) {\n                    tile.bindVideoStream('', true, null, null, null, null);\n                }\n                this.context.videoTileController.removeAllVideoTiles();\n            }\n        });\n    }\n    receiveWebSocketClosedEvent() {\n        return new Promise((resolve, reject) => {\n            class Interceptor {\n                constructor(signalingClient) {\n                    this.signalingClient = signalingClient;\n                }\n                cancel() {\n                    this.signalingClient.removeObserver(this);\n                    reject(new Error(`CleanStoppedSessionTask got canceled while waiting for the WebSocket closed event`));\n                }\n                handleSignalingClientEvent(event) {\n                    if (event.type === SignalingClientEventType_1.default.WebSocketClosed) {\n                        this.signalingClient.removeObserver(this);\n                        resolve();\n                    }\n                }\n            }\n            const interceptor = new Interceptor(this.context.signalingClient);\n            this.taskCanceler = interceptor;\n            this.context.signalingClient.registerObserver(interceptor);\n        });\n    }\n}\nexports.default = CleanStoppedSessionTask;\n//# sourceMappingURL=CleanStoppedSessionTask.js.map"]},"metadata":{},"sourceType":"script"}