{"ast":null,"code":"\"use strict\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\n\nconst DefaultModality_1 = require(\"../modality/DefaultModality\");\n\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\n\nconst VideoTileState_1 = require(\"./VideoTileState\");\n\nclass DefaultVideoTile {\n  constructor(tileId, localTile, tileController, devicePixelRatioMonitor) {\n    this.tileController = tileController;\n    this.devicePixelRatioMonitor = devicePixelRatioMonitor;\n    this.tileState = new VideoTileState_1.default();\n    this.tileState.tileId = tileId;\n    this.tileState.localTile = localTile;\n    this.devicePixelRatioMonitor.registerObserver(this);\n  }\n\n  static connectVideoStreamToVideoElement(videoStream, videoElement, localTile) {\n    const transform = localTile && videoStream.getVideoTracks()[0].getSettings().facingMode !== 'environment' ? 'rotateY(180deg)' : '';\n    DefaultVideoTile.setVideoElementFlag(videoElement, 'disablePictureInPicture', localTile);\n    DefaultVideoTile.setVideoElementFlag(videoElement, 'disableRemotePlayback', localTile);\n\n    if (videoElement.style.transform !== transform) {\n      videoElement.style.transform = transform;\n    }\n\n    if (videoElement.hasAttribute('controls')) {\n      videoElement.removeAttribute('controls');\n    }\n\n    if (!videoElement.hasAttribute('autoplay')) {\n      videoElement.setAttribute('autoplay', 'true');\n    } // playsinline is needed for video to play in iPhone in non-fullscreen mode.\n    // See https://developer.apple.com/documentation/webkit/safari_tools_and_features/delivering_video_content_for_safari#3030250\n\n\n    if (!videoElement.hasAttribute('playsinline')) {\n      videoElement.setAttribute('playsinline', 'true');\n    } // Note that setting the *attribute* 'muted' affects whether the element\n    // is muted *by default* (`.defaultMuted`), not whether it is currently muted (`.muted`).\n    // https://html.spec.whatwg.org/#dom-media-defaultmuted\n\n\n    if (!videoElement.hasAttribute('muted')) {\n      // The default value…\n      videoElement.setAttribute('muted', 'true'); // … and the value right now.\n\n      videoElement.muted = true;\n    }\n\n    if (videoElement.srcObject !== videoStream) {\n      videoElement.srcObject = videoStream;\n    }\n\n    if (new DefaultBrowserBehavior_1.default().requiresVideoElementWorkaround()) {\n      AsyncScheduler_1.default.nextTick(() => __awaiter(this, void 0, void 0, function* () {\n        try {\n          yield videoElement.play();\n        } catch (error) {}\n      }));\n    }\n  }\n\n  static disconnectVideoStreamFromVideoElement(videoElement, dueToPause) {\n    if (!videoElement) {\n      return;\n    }\n\n    if (dueToPause) {\n      videoElement.srcObject = null;\n      videoElement.style.transform = '';\n    } else {\n      if (!videoElement.srcObject) {\n        return;\n      }\n\n      videoElement.pause();\n      videoElement.style.transform = '';\n      DefaultVideoTile.setVideoElementFlag(videoElement, 'disablePictureInPicture', false);\n      DefaultVideoTile.setVideoElementFlag(videoElement, 'disableRemotePlayback', false); // We must remove all the tracks from the MediaStream before\n      // clearing the `srcObject` to prevent Safari from crashing.\n\n      const mediaStream = videoElement.srcObject;\n      const tracks = mediaStream.getTracks();\n\n      for (const track of tracks) {\n        track.stop();\n        mediaStream.removeTrack(track);\n      } // Need to yield the message loop before clearing `srcObject` to\n      // prevent Safari from crashing.\n\n\n      if (new DefaultBrowserBehavior_1.default().requiresVideoElementWorkaround()) {\n        AsyncScheduler_1.default.nextTick(() => {\n          videoElement.srcObject = null;\n        });\n      } else {\n        videoElement.srcObject = null;\n      }\n    }\n  }\n\n  destroy() {\n    this.devicePixelRatioMonitor.removeObserver(this);\n\n    if (this.tileState.boundVideoElement && this.tileState.boundVideoElement.srcObject === this.tileState.boundVideoStream) {\n      DefaultVideoTile.disconnectVideoStreamFromVideoElement(this.tileState.boundVideoElement, false);\n    }\n\n    this.tileState = new VideoTileState_1.default();\n  }\n\n  devicePixelRatioChanged(newDevicePixelRatio) {\n    this.tileState.devicePixelRatio = newDevicePixelRatio;\n    this.sendTileStateUpdate();\n  }\n\n  id() {\n    return this.tileState.tileId;\n  }\n\n  state() {\n    return this.tileState.clone();\n  }\n\n  stateRef() {\n    return this.tileState;\n  }\n\n  bindVideoStream(attendeeId, localTile, mediaStream, contentWidth, contentHeight, streamId, externalUserId) {\n    let tileUpdated = false;\n\n    if (this.tileState.boundAttendeeId !== attendeeId) {\n      this.tileState.boundAttendeeId = attendeeId;\n\n      if (new DefaultModality_1.default(attendeeId).hasModality(DefaultModality_1.default.MODALITY_CONTENT)) {\n        this.tileState.isContent = true;\n      }\n\n      tileUpdated = true;\n    }\n\n    if (this.tileState.boundExternalUserId !== externalUserId) {\n      this.tileState.boundExternalUserId = externalUserId;\n      tileUpdated = true;\n    }\n\n    if (this.tileState.localTile !== localTile) {\n      this.tileState.localTile = localTile;\n      tileUpdated = true;\n    }\n\n    if (this.tileState.boundVideoStream !== mediaStream) {\n      this.tileState.boundVideoStream = mediaStream;\n      tileUpdated = true;\n    }\n\n    if (this.tileState.videoStreamContentWidth !== contentWidth) {\n      this.tileState.videoStreamContentWidth = contentWidth;\n      tileUpdated = true;\n    }\n\n    if (this.tileState.videoStreamContentHeight !== contentHeight) {\n      this.tileState.videoStreamContentHeight = contentHeight;\n      tileUpdated = true;\n    }\n\n    if (this.tileState.streamId !== streamId) {\n      this.tileState.streamId = streamId;\n      tileUpdated = true;\n    }\n\n    if (tileUpdated) {\n      this.sendTileStateUpdate();\n    }\n  }\n\n  bindVideoElement(videoElement) {\n    let tileUpdated = false;\n\n    if (this.tileState.boundVideoElement !== videoElement) {\n      this.tileState.boundVideoElement = videoElement;\n      tileUpdated = true;\n    }\n\n    if (this.tileState.boundVideoElement !== null) {\n      if (this.tileState.videoElementCSSWidthPixels !== videoElement.clientWidth) {\n        this.tileState.videoElementCSSWidthPixels = videoElement.clientWidth;\n        tileUpdated = true;\n      }\n\n      if (this.tileState.videoElementCSSHeightPixels !== videoElement.clientHeight) {\n        this.tileState.videoElementCSSHeightPixels = videoElement.clientHeight;\n        tileUpdated = true;\n      }\n    } else {\n      this.tileState.videoElementCSSWidthPixels = null;\n      this.tileState.videoElementCSSHeightPixels = null;\n    }\n\n    if (tileUpdated) {\n      this.sendTileStateUpdate();\n    }\n  }\n\n  pause() {\n    if (!this.tileState.paused) {\n      this.tileState.paused = true;\n      this.sendTileStateUpdate();\n    }\n  }\n\n  unpause() {\n    if (this.tileState.paused) {\n      this.tileState.paused = false;\n      this.sendTileStateUpdate();\n    }\n  }\n\n  markPoorConnection() {\n    if (this.tileState.poorConnection) {\n      return false;\n    }\n\n    this.tileState.poorConnection = true;\n    this.sendTileStateUpdate();\n    return true;\n  }\n\n  unmarkPoorConnection() {\n    if (!this.tileState.poorConnection) {\n      return false;\n    }\n\n    this.tileState.poorConnection = false;\n    this.sendTileStateUpdate();\n    return true;\n  }\n\n  capture() {\n    if (!this.tileState.active) {\n      return null;\n    }\n\n    const canvas = document.createElement('canvas');\n    const video = this.tileState.boundVideoElement;\n    canvas.width = video.videoWidth || video.width;\n    canvas.height = video.videoHeight || video.height;\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n    return ctx.getImageData(0, 0, canvas.width, canvas.height);\n  }\n\n  sendTileStateUpdate() {\n    this.updateActiveState();\n    this.updateVideoStreamOnVideoElement();\n    this.updateVideoElementPhysicalPixels();\n    this.tileController.sendTileStateUpdate(this.state());\n  }\n\n  updateActiveState() {\n    this.tileState.active = !!(!this.tileState.paused && !this.tileState.poorConnection && this.tileState.boundAttendeeId && this.tileState.boundVideoElement && this.tileState.boundVideoStream);\n  }\n\n  updateVideoElementPhysicalPixels() {\n    if (typeof this.tileState.videoElementCSSWidthPixels === 'number' && typeof this.tileState.videoElementCSSHeightPixels === 'number') {\n      this.tileState.videoElementPhysicalWidthPixels = this.tileState.devicePixelRatio * this.tileState.videoElementCSSWidthPixels;\n      this.tileState.videoElementPhysicalHeightPixels = this.tileState.devicePixelRatio * this.tileState.videoElementCSSHeightPixels;\n    } else {\n      this.tileState.videoElementPhysicalWidthPixels = null;\n      this.tileState.videoElementPhysicalHeightPixels = null;\n    }\n  }\n\n  updateVideoStreamOnVideoElement() {\n    if (this.tileState.active) {\n      DefaultVideoTile.connectVideoStreamToVideoElement(this.tileState.boundVideoStream, this.tileState.boundVideoElement, this.tileState.localTile);\n    } else {\n      DefaultVideoTile.disconnectVideoStreamFromVideoElement(this.tileState.boundVideoElement, this.tileState.paused);\n    }\n  }\n\n  static setVideoElementFlag(videoElement, flag, value) {\n    if (flag in videoElement) {\n      // @ts-ignore\n      videoElement[flag] = value;\n    }\n  }\n\n}\n\nexports.default = DefaultVideoTile;","map":{"version":3,"sources":["../../src/videotile/DefaultVideoTile.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DefaultBrowserBehavior_1 = require(\"../browserbehavior/DefaultBrowserBehavior\");\nconst DefaultModality_1 = require(\"../modality/DefaultModality\");\nconst AsyncScheduler_1 = require(\"../scheduler/AsyncScheduler\");\nconst VideoTileState_1 = require(\"./VideoTileState\");\nclass DefaultVideoTile {\n    constructor(tileId, localTile, tileController, devicePixelRatioMonitor) {\n        this.tileController = tileController;\n        this.devicePixelRatioMonitor = devicePixelRatioMonitor;\n        this.tileState = new VideoTileState_1.default();\n        this.tileState.tileId = tileId;\n        this.tileState.localTile = localTile;\n        this.devicePixelRatioMonitor.registerObserver(this);\n    }\n    static connectVideoStreamToVideoElement(videoStream, videoElement, localTile) {\n        const transform = localTile && videoStream.getVideoTracks()[0].getSettings().facingMode !== 'environment'\n            ? 'rotateY(180deg)'\n            : '';\n        DefaultVideoTile.setVideoElementFlag(videoElement, 'disablePictureInPicture', localTile);\n        DefaultVideoTile.setVideoElementFlag(videoElement, 'disableRemotePlayback', localTile);\n        if (videoElement.style.transform !== transform) {\n            videoElement.style.transform = transform;\n        }\n        if (videoElement.hasAttribute('controls')) {\n            videoElement.removeAttribute('controls');\n        }\n        if (!videoElement.hasAttribute('autoplay')) {\n            videoElement.setAttribute('autoplay', 'true');\n        }\n        // playsinline is needed for video to play in iPhone in non-fullscreen mode.\n        // See https://developer.apple.com/documentation/webkit/safari_tools_and_features/delivering_video_content_for_safari#3030250\n        if (!videoElement.hasAttribute('playsinline')) {\n            videoElement.setAttribute('playsinline', 'true');\n        }\n        // Note that setting the *attribute* 'muted' affects whether the element\n        // is muted *by default* (`.defaultMuted`), not whether it is currently muted (`.muted`).\n        // https://html.spec.whatwg.org/#dom-media-defaultmuted\n        if (!videoElement.hasAttribute('muted')) {\n            // The default value…\n            videoElement.setAttribute('muted', 'true');\n            // … and the value right now.\n            videoElement.muted = true;\n        }\n        if (videoElement.srcObject !== videoStream) {\n            videoElement.srcObject = videoStream;\n        }\n        if (new DefaultBrowserBehavior_1.default().requiresVideoElementWorkaround()) {\n            AsyncScheduler_1.default.nextTick(() => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield videoElement.play();\n                }\n                catch (error) { }\n            }));\n        }\n    }\n    static disconnectVideoStreamFromVideoElement(videoElement, dueToPause) {\n        if (!videoElement) {\n            return;\n        }\n        if (dueToPause) {\n            videoElement.srcObject = null;\n            videoElement.style.transform = '';\n        }\n        else {\n            if (!videoElement.srcObject) {\n                return;\n            }\n            videoElement.pause();\n            videoElement.style.transform = '';\n            DefaultVideoTile.setVideoElementFlag(videoElement, 'disablePictureInPicture', false);\n            DefaultVideoTile.setVideoElementFlag(videoElement, 'disableRemotePlayback', false);\n            // We must remove all the tracks from the MediaStream before\n            // clearing the `srcObject` to prevent Safari from crashing.\n            const mediaStream = videoElement.srcObject;\n            const tracks = mediaStream.getTracks();\n            for (const track of tracks) {\n                track.stop();\n                mediaStream.removeTrack(track);\n            }\n            // Need to yield the message loop before clearing `srcObject` to\n            // prevent Safari from crashing.\n            if (new DefaultBrowserBehavior_1.default().requiresVideoElementWorkaround()) {\n                AsyncScheduler_1.default.nextTick(() => {\n                    videoElement.srcObject = null;\n                });\n            }\n            else {\n                videoElement.srcObject = null;\n            }\n        }\n    }\n    destroy() {\n        this.devicePixelRatioMonitor.removeObserver(this);\n        if (this.tileState.boundVideoElement &&\n            this.tileState.boundVideoElement.srcObject === this.tileState.boundVideoStream) {\n            DefaultVideoTile.disconnectVideoStreamFromVideoElement(this.tileState.boundVideoElement, false);\n        }\n        this.tileState = new VideoTileState_1.default();\n    }\n    devicePixelRatioChanged(newDevicePixelRatio) {\n        this.tileState.devicePixelRatio = newDevicePixelRatio;\n        this.sendTileStateUpdate();\n    }\n    id() {\n        return this.tileState.tileId;\n    }\n    state() {\n        return this.tileState.clone();\n    }\n    stateRef() {\n        return this.tileState;\n    }\n    bindVideoStream(attendeeId, localTile, mediaStream, contentWidth, contentHeight, streamId, externalUserId) {\n        let tileUpdated = false;\n        if (this.tileState.boundAttendeeId !== attendeeId) {\n            this.tileState.boundAttendeeId = attendeeId;\n            if (new DefaultModality_1.default(attendeeId).hasModality(DefaultModality_1.default.MODALITY_CONTENT)) {\n                this.tileState.isContent = true;\n            }\n            tileUpdated = true;\n        }\n        if (this.tileState.boundExternalUserId !== externalUserId) {\n            this.tileState.boundExternalUserId = externalUserId;\n            tileUpdated = true;\n        }\n        if (this.tileState.localTile !== localTile) {\n            this.tileState.localTile = localTile;\n            tileUpdated = true;\n        }\n        if (this.tileState.boundVideoStream !== mediaStream) {\n            this.tileState.boundVideoStream = mediaStream;\n            tileUpdated = true;\n        }\n        if (this.tileState.videoStreamContentWidth !== contentWidth) {\n            this.tileState.videoStreamContentWidth = contentWidth;\n            tileUpdated = true;\n        }\n        if (this.tileState.videoStreamContentHeight !== contentHeight) {\n            this.tileState.videoStreamContentHeight = contentHeight;\n            tileUpdated = true;\n        }\n        if (this.tileState.streamId !== streamId) {\n            this.tileState.streamId = streamId;\n            tileUpdated = true;\n        }\n        if (tileUpdated) {\n            this.sendTileStateUpdate();\n        }\n    }\n    bindVideoElement(videoElement) {\n        let tileUpdated = false;\n        if (this.tileState.boundVideoElement !== videoElement) {\n            this.tileState.boundVideoElement = videoElement;\n            tileUpdated = true;\n        }\n        if (this.tileState.boundVideoElement !== null) {\n            if (this.tileState.videoElementCSSWidthPixels !== videoElement.clientWidth) {\n                this.tileState.videoElementCSSWidthPixels = videoElement.clientWidth;\n                tileUpdated = true;\n            }\n            if (this.tileState.videoElementCSSHeightPixels !== videoElement.clientHeight) {\n                this.tileState.videoElementCSSHeightPixels = videoElement.clientHeight;\n                tileUpdated = true;\n            }\n        }\n        else {\n            this.tileState.videoElementCSSWidthPixels = null;\n            this.tileState.videoElementCSSHeightPixels = null;\n        }\n        if (tileUpdated) {\n            this.sendTileStateUpdate();\n        }\n    }\n    pause() {\n        if (!this.tileState.paused) {\n            this.tileState.paused = true;\n            this.sendTileStateUpdate();\n        }\n    }\n    unpause() {\n        if (this.tileState.paused) {\n            this.tileState.paused = false;\n            this.sendTileStateUpdate();\n        }\n    }\n    markPoorConnection() {\n        if (this.tileState.poorConnection) {\n            return false;\n        }\n        this.tileState.poorConnection = true;\n        this.sendTileStateUpdate();\n        return true;\n    }\n    unmarkPoorConnection() {\n        if (!this.tileState.poorConnection) {\n            return false;\n        }\n        this.tileState.poorConnection = false;\n        this.sendTileStateUpdate();\n        return true;\n    }\n    capture() {\n        if (!this.tileState.active) {\n            return null;\n        }\n        const canvas = document.createElement('canvas');\n        const video = this.tileState.boundVideoElement;\n        canvas.width = video.videoWidth || video.width;\n        canvas.height = video.videoHeight || video.height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        return ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n    sendTileStateUpdate() {\n        this.updateActiveState();\n        this.updateVideoStreamOnVideoElement();\n        this.updateVideoElementPhysicalPixels();\n        this.tileController.sendTileStateUpdate(this.state());\n    }\n    updateActiveState() {\n        this.tileState.active = !!(!this.tileState.paused &&\n            !this.tileState.poorConnection &&\n            this.tileState.boundAttendeeId &&\n            this.tileState.boundVideoElement &&\n            this.tileState.boundVideoStream);\n    }\n    updateVideoElementPhysicalPixels() {\n        if (typeof this.tileState.videoElementCSSWidthPixels === 'number' &&\n            typeof this.tileState.videoElementCSSHeightPixels === 'number') {\n            this.tileState.videoElementPhysicalWidthPixels =\n                this.tileState.devicePixelRatio * this.tileState.videoElementCSSWidthPixels;\n            this.tileState.videoElementPhysicalHeightPixels =\n                this.tileState.devicePixelRatio * this.tileState.videoElementCSSHeightPixels;\n        }\n        else {\n            this.tileState.videoElementPhysicalWidthPixels = null;\n            this.tileState.videoElementPhysicalHeightPixels = null;\n        }\n    }\n    updateVideoStreamOnVideoElement() {\n        if (this.tileState.active) {\n            DefaultVideoTile.connectVideoStreamToVideoElement(this.tileState.boundVideoStream, this.tileState.boundVideoElement, this.tileState.localTile);\n        }\n        else {\n            DefaultVideoTile.disconnectVideoStreamFromVideoElement(this.tileState.boundVideoElement, this.tileState.paused);\n        }\n    }\n    static setVideoElementFlag(videoElement, flag, value) {\n        if (flag in videoElement) {\n            // @ts-ignore\n            videoElement[flag] = value;\n        }\n    }\n}\nexports.default = DefaultVideoTile;\n//# sourceMappingURL=DefaultVideoTile.js.map"]},"metadata":{},"sourceType":"script"}